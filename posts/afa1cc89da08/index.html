<!DOCTYPE html>


<html lang="zh-CN">
  

    <head>
      <meta charset="utf-8" />
       
      <meta name="keywords" content="前端 web react" />
       
      <meta name="description" content="前端技术与生活。" />
      
      <meta
        name="viewport"
        content="width=device-width, initial-scale=1, maximum-scale=1"
      />
      <title>React原理 生命周期 |  四月八日</title>
  <meta name="generator" content="hexo-theme-ayer">
      
      <link rel="shortcut icon" href="/favicon.ico" />
       
<link rel="stylesheet" href="/dist/main.css">
 
<link rel="stylesheet" href="/css/fonts/remixicon.css">
 
<link rel="stylesheet" href="/css/custom.css">
 
      <script src="/js/pace.min.js"></script>
       
 

      <link rel="stylesheet" href="/css/bulma.min.css" />
      <script src="/js/sweetalert2.min.js"></script>

      <!-- mermaid -->
      
      <script src="https://cdn.staticfile.org/mermaid/8.14.0/mermaid.min.js"></script>
      
      <style>
        .swal2-styled.swal2-confirm {
          font-size: 1.6rem;
        }
      </style>
    <!-- hexo injector head_end start -->
<link rel="stylesheet" href="/css/katex.min.css">

<link rel="stylesheet" href="/css/style.css">
<!-- hexo injector head_end end --></head>
  </html>
</html>


<body>
  <div id="app">
    
      
    <main class="content on">
      <section class="outer">
  <article
  id="post-react/④(原理)react生命周期"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h1 class="article-title sea-center" style="border-left:0" itemprop="name">
  React原理 生命周期
</h1>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/posts/afa1cc89da08/" class="article-date">
  <time datetime="2021-09-08T04:30:13.000Z" itemprop="datePublished">2021-09-08</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/React/">React</a>
  </div>
  
<div class="word_count">
    <span class="post-time">
        <span class="post-meta-item-icon">
            <i class="ri-quill-pen-line"></i>
            <span class="post-meta-item-text"> 字数统计:</span>
            <span class="post-count">5k</span>
        </span>
    </span>

    <span class="post-time">
        &nbsp; | &nbsp;
        <span class="post-meta-item-icon">
            <i class="ri-book-open-line"></i>
            <span class="post-meta-item-text"> 阅读时长≈</span>
            <span class="post-count">21 分钟</span>
        </span>
    </span>
</div>
 
    </div>
      
    <div class="tocbot"></div>




  
    <div class="article-entry" itemprop="articleBody">
       
  <h4 id="预备"><a href="#预备" class="headerlink" title="预备"></a>预备</h4><p>React 有两个重要阶段，render 阶段和 commit 阶段，React 在调和( render )阶段会深度遍历 React fiber 树，目的就是发现不同( diff )，不同的地方就是接下来需要更新的地方，对于变化的组件，就会执行 render 函数。在一次调和过程完毕之后，就到了commit 阶段，commit 阶段会创建修改真实的 DOM 节点。</p>
<blockquote>
<p>类组件的处理逻辑在<a href="/posts/72e97988/#%E7%BB%84%E4%BB%B6%E7%9A%84%E6%9C%AC%E8%B4%A8">beginWork</a>中被调用，react-reconciler&#x2F;src&#x2F;ReactFiberBeginWork.js</p>
</blockquote>
<p>① instance 类组件对应实例。<br>② workInProgress 树，当前正在调和的 fiber 树 ，一次更新中，React 会自上而下深度遍历子代 fiber ，如果遍历到一个 fiber ，会把当前 fiber 指向 workInProgress。<br>③ current 树，在初始化更新中，current &#x3D; null ，在第一次 fiber 调和之后，会将 workInProgress 树赋值给 current 树。React 来用workInProgress 和 current 来确保一次更新中，快速构建，并且状态不丢失。<br>④ Component 就是项目中的 class 组件。<br>⑤ nextProps 作为组件在一次更新中新的 props 。<br>⑥ renderLanes 作为下一次渲染的优先级。</p>
<p>在组件实例上可以通过 <code>_reactInternals</code> 属性来访问组件对应的 <code>fiber</code> 对象。在 <code>fiber</code> 对象上，可以通过 <code>stateNode</code> 来访问当前 <code>fiber</code> 对应的组件实例。</p>
<p><code>class Instance</code> . <code>_reactInternals</code> &#x3D;&gt; <code>class Fiber</code></p>
<p><code>class Fiber</code> . <code>stateNode</code> &#x3D;&gt; <code>class Instance</code></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">updateClassComponent</span>(<span class="params"></span></span><br><span class="line"><span class="params">  current: Fiber | <span class="literal">null</span>,</span></span><br><span class="line"><span class="params">  workInProgress: Fiber,</span></span><br><span class="line"><span class="params">  Component: any,</span></span><br><span class="line"><span class="params">  nextProps: any,</span></span><br><span class="line"><span class="params">  renderLanes: Lanes,</span></span><br><span class="line"><span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// stateNode 是 fiber 指向 类组件实例的指针。</span></span><br><span class="line">  <span class="keyword">const</span> instance = workInProgress.<span class="property">stateNode</span>;</span><br><span class="line">  <span class="keyword">let</span> shouldUpdate;</span><br><span class="line">  <span class="comment">// instance 为组件实例,如果组件实例不存在，证明该类组件没有被挂载过，那么会走初始化流程</span></span><br><span class="line">  <span class="keyword">if</span> (instance === <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 在这个方法中组件通过new被实例化</span></span><br><span class="line">    <span class="title function_">constructClassInstance</span>(workInProgress, <span class="title class_">Component</span>, nextProps);</span><br><span class="line">    <span class="comment">// 初始化挂载组件流程</span></span><br><span class="line">    <span class="title function_">mountClassInstance</span>(workInProgress, <span class="title class_">Component</span>, nextProps, renderLanes);</span><br><span class="line">    <span class="comment">// shouldUpdate 标识用来证明 组件是否需要更新。</span></span><br><span class="line">    shouldUpdate = <span class="literal">true</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (current === <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 已经存在了一个实例可以被复用</span></span><br><span class="line">    shouldUpdate = <span class="title function_">resumeMountClassInstance</span>(</span><br><span class="line">      workInProgress,</span><br><span class="line">      <span class="title class_">Component</span>,</span><br><span class="line">      nextProps,</span><br><span class="line">      renderLanes,</span><br><span class="line">    );</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 更新组件流程</span></span><br><span class="line">    shouldUpdate = <span class="title function_">updateClassInstance</span>(</span><br><span class="line">      current,</span><br><span class="line">      workInProgress,</span><br><span class="line">      <span class="title class_">Component</span>,</span><br><span class="line">      nextProps,</span><br><span class="line">      renderLanes,</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> nextUnitOfWork = <span class="title function_">finishClassComponent</span>(</span><br><span class="line">    current,</span><br><span class="line">    workInProgress,</span><br><span class="line">    <span class="title class_">Component</span>,</span><br><span class="line">    shouldUpdate,</span><br><span class="line">    hasContext,</span><br><span class="line">    renderLanes,</span><br><span class="line">  );</span><br><span class="line">  <span class="keyword">return</span> nextUnitOfWork;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">finishClassComponent</span>(<span class="params"></span></span><br><span class="line"><span class="params">  current: Fiber | <span class="literal">null</span>,</span></span><br><span class="line"><span class="params">  workInProgress: Fiber,</span></span><br><span class="line"><span class="params">  Component: any,</span></span><br><span class="line"><span class="params">  shouldUpdate: boolean,</span></span><br><span class="line"><span class="params">  hasContext: boolean,</span></span><br><span class="line"><span class="params">  renderLanes: Lanes,</span></span><br><span class="line"><span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// 即使 shouldComponentUpdate 返回了 false,Refs也应该被更新</span></span><br><span class="line">  <span class="title function_">markRef</span>(current, workInProgress);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> instance = workInProgress.<span class="property">stateNode</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Rerender</span></span><br><span class="line">  <span class="title class_">ReactCurrentOwner</span>.<span class="property">current</span> = workInProgress;</span><br><span class="line">  <span class="comment">// 获取子节点</span></span><br><span class="line">  <span class="keyword">let</span> nextChildren = instance.<span class="title function_">render</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 调和子节点</span></span><br><span class="line">  <span class="title function_">reconcileChildren</span>(current, workInProgress, nextChildren, renderLanes);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Memoize state using the values we just used to render.</span></span><br><span class="line">  <span class="comment">// <span class="doctag">TODO:</span> Restructure so we never read values from the instance.</span></span><br><span class="line">  workInProgress.<span class="property">memoizedState</span> = instance.<span class="property">state</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// The context might have changed so we need to recalculate it.</span></span><br><span class="line">  <span class="keyword">if</span> (hasContext) &#123;</span><br><span class="line">    <span class="title function_">invalidateContextProvider</span>(workInProgress, <span class="title class_">Component</span>, <span class="literal">true</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> workInProgress.<span class="property">child</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="初始化阶段"><a href="#初始化阶段" class="headerlink" title="初始化阶段"></a>初始化阶段</h4><p><code>constructClassInstance</code>构建了组件的<a href="/posts/72e97988/#%E7%BB%84%E4%BB%B6%E7%9A%84%E6%9C%AC%E8%B4%A8">实例</a>，在实例化组件之后，会调用 <code>mountClassInstance</code> 组件初始化。</p>
<blockquote>
<p>react-reconciler&#x2F;src&#x2F;ReactFiberClassComponent.js</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在从没有渲染过的实例上执行挂载生命周期</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">mountClassInstance</span>(<span class="params"></span></span><br><span class="line"><span class="params">  workInProgress: Fiber,</span></span><br><span class="line"><span class="params">  ctor: any,</span></span><br><span class="line"><span class="params">  newProps: any,</span></span><br><span class="line"><span class="params">  renderLanes: Lanes,</span></span><br><span class="line"><span class="params"></span>): <span class="keyword">void</span> &#123;</span><br><span class="line">  <span class="comment">// 组件实例</span></span><br><span class="line">  <span class="keyword">const</span> instance = workInProgress.<span class="property">stateNode</span>;</span><br><span class="line">  instance.<span class="property">props</span> = newProps;</span><br><span class="line">  instance.<span class="property">state</span> = workInProgress.<span class="property">memoizedState</span>;</span><br><span class="line">  instance.<span class="property">refs</span> = emptyRefsObject;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">initializeUpdateQueue</span>(workInProgress);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 拿到类组件构造函数的静态方法</span></span><br><span class="line">  <span class="keyword">const</span> getDerivedStateFromProps = ctor.<span class="property">getDerivedStateFromProps</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> getDerivedStateFromProps === <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">var</span> prevState = workInProgress.<span class="property">memoizedState</span>;</span><br><span class="line">        <span class="comment">// 返回更新之后的state</span></span><br><span class="line">        <span class="keyword">var</span> partialState = <span class="title function_">getDerivedStateFromProps</span>(nextProps, prevState);</span><br><span class="line">        <span class="comment">// 如果返回的state不合法，使用原有状态，否则合并两个状态生成一个新的state对象</span></span><br><span class="line">        <span class="keyword">var</span> memoizedState = partialState === <span class="literal">null</span> || partialState === <span class="literal">undefined</span> ? prevState : <span class="title function_">_assign</span>(&#123;&#125;, prevState, partialState);</span><br><span class="line">        workInProgress.<span class="property">memoizedState</span> = memoizedState; </span><br><span class="line">        </span><br><span class="line">        <span class="comment">// Once the update queue is empty, persist the derived state onto the</span></span><br><span class="line">        <span class="comment">// base state.</span></span><br><span class="line">        <span class="keyword">if</span> (workInProgress.<span class="property">lanes</span> === <span class="title class_">NoLanes</span>) &#123;</span><br><span class="line">            <span class="comment">// Queue is always non-null for classes</span></span><br><span class="line">            <span class="keyword">var</span> updateQueue = workInProgress.<span class="property">updateQueue</span>;</span><br><span class="line">            updateQueue.<span class="property">baseState</span> = memoizedState;</span><br><span class="line">        &#125;</span><br><span class="line">        instance.<span class="property">state</span> = workInProgress.<span class="property">memoizedState</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> instance.<span class="property">componentDidMount</span> === <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">    workInProgress.<span class="property">flags</span> |= fiberFlags;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong><code>render</code> 函数执行</strong></p>
<p>到此为止 <code>mountClassInstance</code> 函数完成，但是上面 <code>updateClassComponent</code> 函数， 在执行完 <code>mountClassInstance</code> 后，执行了 <code>render</code> 渲染函数，形成了 children ， 接下来 React 调用 <code>reconcileChildren</code> 方法深度调和 <code>children</code> 。</p>
<p><strong><code>componentDidMount</code>函数执行</strong></p>
<p>上述提及的几生命周期都是在 render 阶段执行的。一旦 React 调和完所有的 fiber 节点，就会到 commit 阶段，在组件初始化 commit 阶段，会调用 componentDidMount 生命周期。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">commitRootImpl</span>(<span class="params">root, renderPriorityLevel</span>)&#123;</span><br><span class="line">    <span class="keyword">const</span> finishedWork = root.<span class="property">finishedWork</span>;</span><br><span class="line">    <span class="title function_">commitLayoutEffects</span>(finishedWork, root, lanes);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>17.0.2</code></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">commitLifeCycles</span>(<span class="params">finishedRoot,current,finishedWork</span>)&#123;</span><br><span class="line">     <span class="keyword">switch</span> (finishedWork.<span class="property">tag</span>)&#123;                             <span class="comment">/* fiber tag 在第一节讲了不同fiber类型 */</span></span><br><span class="line">        <span class="keyword">case</span> <span class="title class_">ClassComponent</span>: &#123;                              <span class="comment">/* 如果是 类组件 类型 */</span></span><br><span class="line">             <span class="keyword">const</span> instance = finishedWork.<span class="property">stateNode</span>        <span class="comment">/* 类实例 */</span></span><br><span class="line">             <span class="keyword">if</span>(current === <span class="literal">null</span>)&#123;                          <span class="comment">/* 类组件第一次调和渲染 */</span></span><br><span class="line">                instance.<span class="title function_">componentDidMount</span>() </span><br><span class="line">             &#125;<span class="keyword">else</span>&#123;                                         <span class="comment">/* 类组件更新 */</span></span><br><span class="line">                instance.<span class="title function_">componentDidUpdate</span>(prevProps,prevState，instance.<span class="property">__reactInternalSnapshotBeforeUpdate</span>); </span><br><span class="line">             &#125;</span><br><span class="line">        &#125;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>17.0.3</code></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">commitLayoutEffectOnFiber</span>(<span class="params"></span></span><br><span class="line"><span class="params">  finishedRoot: FiberRoot,</span></span><br><span class="line"><span class="params">  current: Fiber | <span class="literal">null</span>,</span></span><br><span class="line"><span class="params">  finishedWork: Fiber,</span></span><br><span class="line"><span class="params">  committedLanes: Lanes,</span></span><br><span class="line"><span class="params"></span>): <span class="keyword">void</span> &#123;</span><br><span class="line">    <span class="keyword">switch</span> (finishedWork.<span class="property">tag</span>) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="title class_">ClassComponent</span>: &#123;</span><br><span class="line">            <span class="keyword">const</span> instance = finishedWork.<span class="property">stateNode</span>;</span><br><span class="line">            <span class="keyword">if</span> (!offscreenSubtreeWasHidden) &#123;</span><br><span class="line">                <span class="keyword">if</span> (</span><br><span class="line">                    enableProfilerTimer &amp;&amp;</span><br><span class="line">                    enableProfilerCommitHooks &amp;&amp;</span><br><span class="line">                    finishedWork.<span class="property">mode</span> &amp; <span class="title class_">ProfileMode</span></span><br><span class="line">                ) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="title function_">startLayoutEffectTimer</span>();</span><br><span class="line">                    instance.<span class="title function_">componentDidMount</span>();</span><br><span class="line">                    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="title function_">recordLayoutEffectDuration</span>(finishedWork);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    instance.<span class="title function_">componentDidMount</span>();</span><br><span class="line">                &#125;</span><br><span class="line">               </span><br><span class="line">            <span class="title function_">commitUpdateQueue</span>(finishedWork, updateQueue, instance);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="更新阶段"><a href="#更新阶段" class="headerlink" title="更新阶段"></a>更新阶段</h4><p>回到了最开始 updateClassComponent 函数了，当发现 current 不为 null 的情况时，说明该类组件被挂载过，那么直接按照更新逻辑来处理。</p>
<blockquote>
<p>react-reconciler&#x2F;src&#x2F;ReactFiberClassComponent.js</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">updateClassInstance</span>(<span class="params">current,workInProgress,ctor,newProps,renderExpirationTime</span>)&#123;</span><br><span class="line">    <span class="comment">// 类组件实例</span></span><br><span class="line">    <span class="keyword">const</span> instance = workInProgress.<span class="property">stateNode</span>;</span><br><span class="line">    <span class="comment">// 判断是否具有 getDerivedStateFromProps 生命周期</span></span><br><span class="line">    <span class="keyword">const</span> hasNewLifecycles =  <span class="keyword">typeof</span> ctor.<span class="property">getDerivedStateFromProps</span> === <span class="string">&#x27;function&#x27;</span></span><br><span class="line">    <span class="keyword">if</span>(!hasNewLifecycles &amp;&amp; <span class="keyword">typeof</span> instance.<span class="property">componentWillReceiveProps</span> === <span class="string">&#x27;function&#x27;</span> )&#123;</span><br><span class="line">        <span class="comment">// 浅比较 props 不相等</span></span><br><span class="line">         <span class="keyword">if</span> (oldProps !== newProps || oldContext !== nextContext) &#123;</span><br><span class="line">            <span class="comment">// 执行生命周期 componentWillReceiveProps</span></span><br><span class="line">            instance.<span class="title function_">componentWillReceiveProps</span>(newProps, nextContext);</span><br><span class="line">         &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> newState = (instance.<span class="property">state</span> = oldState);</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> getDerivedStateFromProps === <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">        <span class="comment">/* 执行生命周期getDerivedStateFromProps  ，逻辑和mounted类似 ，合并state  */</span></span><br><span class="line">        ctor.<span class="title function_">getDerivedStateFromProps</span>(nextProps,prevState)  </span><br><span class="line">        newState = workInProgress.<span class="property">memoizedState</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> shouldUpdate = <span class="literal">true</span></span><br><span class="line">    <span class="comment">/* 执行生命周期 shouldComponentUpdate 返回值决定是否执行render ，调和子节点 */</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">typeof</span> instance.<span class="property">shouldComponentUpdate</span> === <span class="string">&#x27;function&#x27;</span> )&#123; </span><br><span class="line">        shouldUpdate = instance.<span class="title function_">shouldComponentUpdate</span>(newProps,newState,nextContext,);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(shouldUpdate)&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> instance.<span class="property">componentWillUpdate</span> === <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">            <span class="comment">/* 执行生命周期 componentWillUpdate  */</span></span><br><span class="line">            instance.<span class="title function_">componentWillUpdate</span>(); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> shouldUpdate</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>getSnapshotBeforeUpdate</strong> 的执行也是在 commit 阶段，commit 阶段细分为 before Mutation( DOM 修改前)，Mutation ( DOM 修改)，Layout( DOM 修改后) 三个阶段，getSnapshotBeforeUpdate 发生在before Mutation 阶段</p>
<h4 id="销毁阶段"><a href="#销毁阶段" class="headerlink" title="销毁阶段"></a>销毁阶段</h4><p>在一次调和更新中，如果发现元素被移除，就会打对应的 Deletion 标签 ，然后在 commit 阶段就会调用 <code>componentWillUnmount</code> 生命周期，接下来统一卸载组件以及 DOM 元素。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> callComponentWillUnmountWithTimer = <span class="keyword">function</span> (<span class="params">current, instance</span>) &#123;</span><br><span class="line">  instance.<span class="property">props</span> = current.<span class="property">memoizedProps</span>;</span><br><span class="line">  instance.<span class="property">state</span> = current.<span class="property">memoizedState</span>;</span><br><span class="line"></span><br><span class="line">  &#123;</span><br><span class="line">    instance.<span class="title function_">componentWillUnmount</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><img src="/posts/afa1cc89da08/0001.jpg"></p>
<h4 id="各生命周期最佳实践"><a href="#各生命周期最佳实践" class="headerlink" title="各生命周期最佳实践"></a>各生命周期最佳实践</h4><h5 id="constructor-NaN"><a href="#constructor-NaN" class="headerlink" title="constructor"></a>constructor</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">constructor</span>(<span class="params">props</span>)&#123;</span><br><span class="line">    <span class="variable language_">super</span>(props)        <span class="comment">// 执行 super ，别忘了传递props,才能在接下来的上下文中，获取到props。</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">state</span>=&#123;       <span class="comment">//① 可以用来初始化state，比如可以用来获取路由中的</span></span><br><span class="line">        <span class="attr">name</span>:<span class="string">&#x27;alien&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">handleClick</span> = <span class="variable language_">this</span>.<span class="property">handleClick</span>.<span class="title function_">bind</span>(<span class="variable language_">this</span>) <span class="comment">/* ② 绑定 this */</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">handleInputChange</span> = <span class="title function_">debounce</span>(<span class="variable language_">this</span>.<span class="property">handleInputChange</span> , <span class="number">500</span>) <span class="comment">/* ③ 绑定防抖函数，防抖 500 毫秒 */</span></span><br><span class="line">    <span class="keyword">const</span> _render = <span class="variable language_">this</span>.<span class="property">render</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">render</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> _render.<span class="title function_">bind</span>(<span class="variable language_">this</span>)  <span class="comment">/* ④ 劫持修改类组件上的一些生命周期 */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="UNSAFE-componentWillMount"><a href="#UNSAFE-componentWillMount" class="headerlink" title="UNSAFE_componentWillMount"></a>UNSAFE_componentWillMount</h5><p>在新版本的react（v16.3）中<code>componentWillMount</code>已经变更为<code>UNSAFE_componentWillMount</code>,而且不在推荐使用，其中很大一部分原因是经常被滥用</p>
<ul>
<li>初始化状态</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ExampleComponent</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">props</span>)&#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">state</span> = &#123;</span><br><span class="line">      <span class="attr">color</span>: <span class="string">&quot;red&quot;</span></span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  state = &#123;</span><br><span class="line">    <span class="attr">color</span>: <span class="string">&quot;red&quot;</span></span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="title function_">componentWillMount</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 应该将初始化状态放到构造函数或属性的初始化状态中</span></span><br><span class="line">    <span class="comment">// this.setState(&#123;</span></span><br><span class="line">    <span class="comment">//   color: &quot;red&quot;</span></span><br><span class="line">    <span class="comment">// &#125;);</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>获取异步的外部数据</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Before</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ExampleComponent</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">  state = &#123;</span><br><span class="line">    <span class="attr">externalData</span>: <span class="literal">null</span>,</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">componentWillMount</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">_asyncRequest</span> = <span class="title function_">loadMyAsyncData</span>().<span class="title function_">then</span>(</span><br><span class="line">      <span class="function"><span class="params">externalData</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">_asyncRequest</span> = <span class="literal">null</span>;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123;externalData&#125;);</span><br><span class="line">      &#125;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">componentWillUnmount</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">_asyncRequest</span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">_asyncRequest</span>.<span class="title function_">cancel</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">externalData</span> === <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">// 渲染加载状态 ...</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 渲染真实 UI ...</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码对于服务器渲染（异步的请求数据不会被放到state中）和即将推出的异步渲染模式（可能执行多次）都存在问题。通常会把上面的操作放到 <code>componentDidMount</code> </p>
<p>另一个问题是，<code>componentWillMount</code>的名字比较反直觉，听起来觉得在这个生命周期中获取数据，可以避免第一次<code>render</code>的时候进行一次空渲染，单实际上 <code>componentWillMount</code>执行后 <code>render</code>方法会立即执行，如果<code>componentWillMount</code> 没有获取到可用数据，<code>render</code>方法中同样获取不到数据。</p>
<p>如果想稍微提前一点请求，从而适应低性能的设备可以使用下面的方法</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// This is an advanced example! It is not intended for use in application code.</span></span><br><span class="line"><span class="comment">// Libraries like Relay may make use of this technique to save some time on low-end mobile devices.</span></span><br><span class="line"><span class="comment">// Most components should just initiate async requests in componentDidMount.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ExampleComponent</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">  _hasUnmounted = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  state = &#123;</span><br><span class="line">    <span class="attr">externalData</span>: <span class="literal">null</span>,</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">props</span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>(props);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Prime an external cache as early as possible.</span></span><br><span class="line">    <span class="comment">// Async requests are unlikely to complete before render anyway,</span></span><br><span class="line">    <span class="comment">// So we aren&#x27;t missing out by not providing a callback here.</span></span><br><span class="line">    <span class="title function_">asyncLoadData</span>(<span class="variable language_">this</span>.<span class="property">props</span>.<span class="property">someId</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">componentDidMount</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// Now that this component has mounted,</span></span><br><span class="line">    <span class="comment">// Wait for earlier pre-fetch to complete and update its state.</span></span><br><span class="line">    <span class="comment">// (This assumes some kind of external cache to avoid duplicate requests.)</span></span><br><span class="line">    <span class="title function_">asyncLoadData</span>(<span class="variable language_">this</span>.<span class="property">props</span>.<span class="property">someId</span>).<span class="title function_">then</span>(<span class="function"><span class="params">externalData</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (!<span class="variable language_">this</span>.<span class="property">_hasUnmounted</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123; externalData &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">componentWillUnmount</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">_hasUnmounted</span> = <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">externalData</span> === <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">// Render loading state ...</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// Render real UI ...</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>事件监听</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Before</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ExampleComponent</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">  <span class="title function_">componentWillMount</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123;</span><br><span class="line">      <span class="attr">subscribedValue</span>: <span class="variable language_">this</span>.<span class="property">props</span>.<span class="property">dataSource</span>.<span class="property">value</span>,</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">// 这是不安全的，它会导致内存泄漏！</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">props</span>.<span class="property">dataSource</span>.<span class="title function_">subscribe</span>(</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">handleSubscriptionChange</span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">componentWillUnmount</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">props</span>.<span class="property">dataSource</span>.<span class="title function_">unsubscribe</span>(</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">handleSubscriptionChange</span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleSubscriptionChange = <span class="function"><span class="params">dataSource</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123;</span><br><span class="line">      <span class="attr">subscribedValue</span>: dataSource.<span class="property">value</span>,</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码在服务端可能永远不会调用 <code>componentWillUnmount</code>, 或者在渲染完成之前可能被中断，导致不调用 <code>componentWillUnmount</code>,这两种场景都可能导致内存泄露，推荐的做法是移到<code>componentDidMount</code> </p>
<p>订阅的触发，导致属性和状态的改变，<code>Redux</code> 或 <code>MobX</code> 会帮助我们实现，对于应用开发场景可以使用 <a target="_blank" rel="noopener" href="https://github.com/facebook/react/tree/main/packages/create-subscription"><code>create-subscription</code></a>, 在这里可以看到源码分析。</p>
<h5 id="UNSAFE-componentWillReceiveProps-getDerivedStateFromProps"><a href="#UNSAFE-componentWillReceiveProps-getDerivedStateFromProps" class="headerlink" title="UNSAFE_componentWillReceiveProps getDerivedStateFromProps"></a>UNSAFE_componentWillReceiveProps getDerivedStateFromProps</h5><p>首先明确一下这个两个方法在使用时，最常见的错误</p>
<ol>
<li>直接复制 props 到 state 上</li>
<li>如果 props 和 state 不一致就更新 state</li>
<li>经常被误解只有<code>props</code>改变时这两个方法才会调用，实际上只要父组件重新渲染这两个方法就会被调用</li>
</ol>
<p>想说清楚造成这两个错误的原因，需要先了解一个概念叫做 <strong>受控</strong></p>
<p><strong>受控</strong>和<strong>非受控</strong>通常用来指代表单的 <code>inputs</code>,但是也可以用来描述数据频繁更新的组件。如果组件完全依赖于外部传入的<code>props</code>,可以认为是受控状态，因为组件完全被父组件的<code>props</code>控制。如果组件的状态只保存在组件（state）内部，可以认为是非受控的，因为组件有自己的状态，不受父组件的控制。</p>
<p>而组件中一旦将两种模式混为一谈（同时包含<code>props</code>和<code>state</code>）就会造成问题</p>
<p><strong>直接复制 props 到 state 上造成的问题</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">EmailInput</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Component</span> &#123;</span><br><span class="line">  state = &#123; <span class="attr">email</span>: <span class="variable language_">this</span>.<span class="property">props</span>.<span class="property">email</span> &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">onChange</span>=<span class="string">&#123;this.handleChange&#125;</span> <span class="attr">value</span>=<span class="string">&#123;this.state.email&#125;</span> /&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleChange = <span class="function"><span class="params">event</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123; <span class="attr">email</span>: event.<span class="property">target</span>.<span class="property">value</span> &#125;);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">componentWillReceiveProps</span>(<span class="params">nextProps</span>) &#123;</span><br><span class="line">    <span class="comment">// 这会覆盖所有组件内的 state 更新！</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123; <span class="attr">email</span>: nextProps.<span class="property">email</span> &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>初看还觉得可以，但是问题很严重，当通过<code>input</code>的输入改变了组件的状态，这时如果父组件更新就会触发<code>componentWillReceiveProps</code>方法，会将<code>state.email</code>状态重写，覆盖了刚才通过<code>input</code>输入更新的状态，导致状态丢失，这是两种模式混用最明显的错误。在实际的使用中会有多个<code>props</code>属性，任意一个属性的更新都会导致内部状态可能被覆盖。</p>
<p>既然这样，可以很容易想到，能不能只用<code>props</code>来更新组件，不让组件有自己的内部状态</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">EmailInput</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Component</span> &#123;</span><br><span class="line">  state = &#123;</span><br><span class="line">    <span class="attr">email</span>: <span class="variable language_">this</span>.<span class="property">props</span>.<span class="property">email</span></span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">componentWillReceiveProps</span>(<span class="params">nextProps</span>) &#123;</span><br><span class="line">    <span class="comment">// 只要 props.email 改变，就改变 state</span></span><br><span class="line">    <span class="keyword">if</span> (nextProps.<span class="property">email</span> !== <span class="variable language_">this</span>.<span class="property">props</span>.<span class="property">email</span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123;</span><br><span class="line">        <span class="attr">email</span>: nextProps.<span class="property">email</span></span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>但是仍然有个问题。想象一下，如果这是一个密码输入组件，拥有同样 email 的两个账户(假设一个邮箱可以注册多个账户)进行切换时，这个输入框不会重置（用来让用户重新登录）。因为父组件传来的 <code>prop</code> 值没有变化！这会让用户非常惊讶，因为这看起来像是帮助一个用户分享了另外一个用户的密码</p>
<p><strong>最佳实践:完全可控的组件</strong></p>
<p>从组件里面删除<code>state</code>,完全让外部的<code>props</code>的接管组件的状态</p>
<p><strong>最佳实践：有 key 的非可控组件</strong></p>
<p>让组件自己存储临时的 email state。在这种情况下，组件仍然可以从 prop 接收“初始值”，但是更改之后的值就和 prop 没关系了</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">EmailInput</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Component</span> &#123;</span><br><span class="line">  state = &#123; <span class="attr">email</span>: <span class="variable language_">this</span>.<span class="property">props</span>.<span class="property">defaultEmail</span> &#125;;</span><br><span class="line"></span><br><span class="line">  handleChange = <span class="function"><span class="params">event</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123; <span class="attr">email</span>: event.<span class="property">target</span>.<span class="property">value</span> &#125;);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">onChange</span>=<span class="string">&#123;this.handleChange&#125;</span> <span class="attr">value</span>=<span class="string">&#123;this.state.email&#125;</span> /&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以使用 key 这个特殊的 React 属性。当 key 变化时， React 会创建一个新的而不是更新一个既有的组件。 Keys 一般用来渲染动态列表，但是这里也可以使用。在这个示例里，当用户输入时，我们使用 user ID 当作 key 重新创建一个新的 email input 组件</p>
<p>不用为每次输入都添加 key，在整个表单上添加 key 更有位合理。每次 key 变化，表单里的所有组件都会用新的初始值重新创建。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="title class_">EmailInput</span></span><br><span class="line">  defaultEmail=&#123;<span class="variable language_">this</span>.<span class="property">props</span>.<span class="property">user</span>.<span class="property">email</span>&#125;</span><br><span class="line">  key=&#123;<span class="variable language_">this</span>.<span class="property">props</span>.<span class="property">user</span>.<span class="property">id</span>&#125;</span><br><span class="line">/&gt;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这听起来很慢，但是这点的性能是可以忽略的。如果在组件树的更新上有很重的逻辑，这样反而会更快，因为省略了子组件 diff。</p>
</blockquote>
<p><strong>备选：用 prop 的 ID 重置非受控组件</strong></p>
<p>如果某些情况下 key 不起作用（可能是组件初始化的开销太大），一个麻烦但是可行的方案是在 getDerivedStateFromProps 观察 userID 的变化：、</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">EmailInput</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Component</span> &#123;</span><br><span class="line">  state = &#123;</span><br><span class="line">    <span class="attr">email</span>: <span class="variable language_">this</span>.<span class="property">props</span>.<span class="property">defaultEmail</span>,</span><br><span class="line">    <span class="attr">prevPropsUserID</span>: <span class="variable language_">this</span>.<span class="property">props</span>.<span class="property">userID</span></span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> <span class="title function_">getDerivedStateFromProps</span>(<span class="params">props, state</span>) &#123;</span><br><span class="line">    <span class="comment">// 只要当前 user 变化，</span></span><br><span class="line">    <span class="comment">// 重置所有跟 user 相关的状态。</span></span><br><span class="line">    <span class="comment">// 这个例子中，只有 email 和 user 相关。</span></span><br><span class="line">    <span class="keyword">if</span> (props.<span class="property">userID</span> !== state.<span class="property">prevPropsUserID</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="attr">prevPropsUserID</span>: props.<span class="property">userID</span>,</span><br><span class="line">        <span class="attr">email</span>: props.<span class="property">defaultEmail</span></span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>getDerivedStateFromProps</code> 的存在只有一个目的：让组件在 props 变化时更新 state。 代替了原来的<code>componentWillReceiveProps</code></p>
<p><code>nextProps</code> 父组件新传递的 <code>props</code> ;</p>
<p>你可能想知道为什么我们不将上一个 props 作为参数传递给 getDerivedStateFromProps。我们在设计 API 时考虑过这个方案，但最终决定不采用它，原因有两个：</p>
<ul>
<li><p>prevProps 参数在第一次调用 getDerivedStateFromProps（实例化之后）时为 null，需要在每次访问 prevProps 时添加 if-not-null 检查。</p>
</li>
<li><p>在 React 的未来版本中，不传递上一个 props 给这个方法是为了释放内存。（如果 React 无需传递上一个 props 给生命周期，那么它就无需保存上一个 props 对象在内存中。）</p>
</li>
</ul>
<p><code>prevState</code> 组件在此次更新前的 <code>state</code> 。</p>
<p>需要注意每次组件更新时<code>getDerivedStateFromProps</code>都会执行，无论是以哪那种方式更新</p>
<p>通常用于吧<code>props</code>混入<code>state</code>作为初始状态，合并后的<code>state</code>可以作为 <code>shouldComponentUpdate</code> 第二个参数 <code>newState</code> ，可以判断是否渲染组件。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">getDerivedStateFromProps</span>(nextProps,prevState)</span><br></pre></td></tr></table></figure>

<p><strong>总结</strong></p>
<p>最重要的是确定组件是受控组件还是非受控组件。不要直接复制（mirror） props 的值到 state 中，而是去实现一个受控的组件，然后在父组件里合并两个值。</p>
<p>对于不受控的组件，当你想在 prop 变化（通常是 ID ）时重置 state 的话，可以选择以下几种方式：</p>
<p>建议: 重置内部所有的初始 state，使用 key 属性<br>选项一：仅更改某些字段，观察特殊属性的变化（比如 props.userID）。</p>
<h5 id="UNSAFE-componentWillUpdate-getSnapshotBeforeUpdate"><a href="#UNSAFE-componentWillUpdate-getSnapshotBeforeUpdate" class="headerlink" title="UNSAFE_componentWillUpdate getSnapshotBeforeUpdate"></a>UNSAFE_componentWillUpdate getSnapshotBeforeUpdate</h5><p>当组件收到新的 <code>props</code> 或 <code>state</code> 时，会在渲染之前调用 <code>UNSAFE_componentWillUpdate()</code>。 有时人们使用 <code>componentWillUpdate</code> 是出于一种反直觉，当 <code>componentDidUpdate</code> 触发时，更新其他组件的 <code>state</code> 已经”太晚”了。事实并非如此。在UI渲染之前，<code>componentWillUpdate</code>和<code>componentDidUpdate</code>中的<code>state</code>改变都将被记录。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">getSnapshotBeforeUpdate</span>(prevProps, prevState)</span><br></pre></td></tr></table></figure>

<p><code>componentWillUpdate</code>常见的错误是在生命周期中使用异步获取数据的方法，因为任何<code>state</code>的更新和父组件的重新渲染会触发<code>componentWillUpdate</code>重新执行，所有获取数据的方法可能被执行多次。相反，应该使用 <code>componentDidUpdate</code> 生命周期，因为它保证每次更新只调用一次。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ExampleComponent</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">  <span class="title function_">componentDidUpdate</span>(<span class="params">prevProps, prevState</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">someStatefulValue</span> !==</span><br><span class="line">      prevState.<span class="property">someStatefulValue</span></span><br><span class="line">    ) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">props</span>.<span class="title function_">onChange</span>(<span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">someStatefulValue</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>更新前读取 DOM 属性</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ListBox</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">  ref = <span class="title class_">React</span>.<span class="title function_">createRef</span>();</span><br><span class="line">  previousScrollOffset=<span class="number">0</span>;</span><br><span class="line">  <span class="comment">// 在列表更新的时候，读取DOM属性</span></span><br><span class="line">  <span class="title function_">componentWillUpdate</span>(<span class="params">nextProps, nextState</span>) &#123;</span><br><span class="line">    <span class="comment">// 当列列表个数被改变的时候计算偏移量</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">props</span>.<span class="property">list</span>.<span class="property">length</span> &lt; nextProps.<span class="property">list</span>.<span class="property">length</span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">previousScrollOffset</span> =</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">ref</span>.<span class="property">current</span>.<span class="property">scrollHeight</span> - <span class="variable language_">this</span>.<span class="property">ref</span>.<span class="property">current</span>.<span class="property">scrollTop</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 在列表被挂载的时候修改DOM属性</span></span><br><span class="line">  <span class="title function_">componentDidUpdate</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="comment">// previousScrollOffset ！== 容器高度时(2px是边框高度)，表示滚动条没有滚动到底部，可能在查看历史记录的状态</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="variable language_">this</span>.<span class="property">previousScrollOffset</span>!== <span class="variable language_">this</span>.<span class="property">ref</span>.<span class="property">current</span>.<span class="property">offsetHeight</span>-<span class="number">2</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// newScrollHeight - oldScrollHeight + lastScrollTop</span></span><br><span class="line">    <span class="comment">// 相当于在上一次的scrollTop上加上ScrollHeight的增量</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">ref</span>.<span class="property">current</span>.<span class="property">scrollTop</span> =  (<span class="variable language_">this</span>.<span class="property">ref</span>.<span class="property">current</span>.<span class="property">scrollHeight</span> -　<span class="variable language_">this</span>.<span class="property">previousScrollOffset</span>　)</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">previousScrollOffset</span> = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&#123;&#123;</span> <span class="attr">width:</span> <span class="attr">300</span>, <span class="attr">height:</span> <span class="attr">200</span>, <span class="attr">overflow:</span> &#x27;<span class="attr">auto</span>&#x27;, <span class="attr">border:</span> &#x27;<span class="attr">1px</span> <span class="attr">solid</span>&#x27; &#125;&#125; <span class="attr">ref</span>=<span class="string">&#123;this.ref&#125;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      &#123;this.props.list.map(item =&gt; <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&#123;&#123;</span> <span class="attr">height:</span> <span class="attr">20</span> &#125;&#125;&gt;</span>&#123;item.val&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span>)&#125;</span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的示例中，componentWillUpdate 用于读取 DOM 属性。但是，对于异步渲染，“渲染”阶段的生命周期（如 componentWillUpdate 和 render）和”提交”阶段的生命周期（如 componentDidUpdate）之间可能存在延迟。如果用户在这段时间内调整窗口大小，那么从 componentWillUpdate 读取的 scrollHeight 值将过时。</p>
<p>这个问题的解决方案是使用新的“提交”阶段生命周期 <code>getSnapshotBeforeUpdate</code>。这个方法在发生变化 前立即 被调用（例如在更新 DOM 之前）。它可以返回一个 React 的值作为参数传递给 componentDidUpdate 方法，该方法在发生变化 后立即 被调用。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ListBox</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">  ref = <span class="title class_">React</span>.<span class="title function_">createRef</span>();</span><br><span class="line">  <span class="title function_">getSnapshotBeforeUpdate</span>(<span class="params">prevProps, nextState</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">props</span>.<span class="property">list</span>.<span class="property">length</span> &gt; prevProps.<span class="property">list</span>.<span class="property">length</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">ref</span>.<span class="property">current</span>.<span class="property">scrollHeight</span> - <span class="variable language_">this</span>.<span class="property">ref</span>.<span class="property">current</span>.<span class="property">scrollTop</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">componentDidUpdate</span>(<span class="params">prevProps, prevState, snapshot</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(snapshot&gt;<span class="variable language_">this</span>.<span class="property">ref</span>.<span class="property">current</span>.<span class="property">offsetHeight</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">ref</span>.<span class="property">current</span>.<span class="property">scrollTop</span> =  (<span class="variable language_">this</span>.<span class="property">ref</span>.<span class="property">current</span>.<span class="property">scrollHeight</span> -　snapshot　)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">ref</span>.<span class="property">current</span>.<span class="property">scrollTop</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&#123;&#123;</span> <span class="attr">width:</span> <span class="attr">300</span>, <span class="attr">height:</span> <span class="attr">200</span>, <span class="attr">overflow:</span> &#x27;<span class="attr">auto</span>&#x27;, <span class="attr">border:</span> &#x27;<span class="attr">1px</span> <span class="attr">solid</span>&#x27; &#125;&#125; <span class="attr">ref</span>=<span class="string">&#123;this.ref&#125;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      &#123;this.props.list.map(item =&gt; <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&#123;&#123;</span> <span class="attr">height:</span> <span class="attr">20</span> &#125;&#125;&gt;</span>&#123;item.val&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span>)&#125;</span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h5 id="componentDidMount"><a href="#componentDidMount" class="headerlink" title="componentDidMount"></a>componentDidMount</h5><p>componentDidMount() 会在组件挂载后（插入 DOM 树中）立即调用。依赖于 DOM 节点的初始化应该放在这里。如需通过网络请求获取数据，此处是实例化请求的好地方。</p>
<p>这个方法是比较适合添加订阅的地方。如果添加了订阅，请不要忘记在 componentWillUnmount() 里取消订阅</p>
<p>你可以在 componentDidMount() 里直接调用 setState()。它将触发额外渲染，但此渲染会发生在浏览器更新屏幕之前。如此保证了即使在 render() 两次调用的情况下，用户也不会看到中间状态。请谨慎使用该模式，因为它会导致性能问题。通常，你应该在 constructor() 中初始化 state。如果你的渲染依赖于 DOM 节点的大小或位置，比如实现 modals 和 tooltips 等情况下，你可以使用此方式处理</p>
<h5 id="useEffect-和-useLayoutEffect"><a href="#useEffect-和-useLayoutEffect" class="headerlink" title="useEffect 和 useLayoutEffect"></a>useEffect 和 useLayoutEffect</h5><p>对于 <code>useEffect</code> 执行， <code>React</code> 处理逻辑是采用异步调用 ，对于每一个 <code>effect</code> 的 <code>callback，</code> React 会像 <code>setTimeout</code>回调函数一样，放入任务队列，等到主线程任务完成，DOM 更新，js 执行完成，视图绘制完毕，才执行。所以 <code>effect</code> 回调函数不会阻塞浏览器绘制视图。</p>
<p><code>useLayoutEffect</code> 和 <code>useEffect</code> 不同的地方是采用了同步执行</p>
<p>首先 <code>useLayoutEffect</code> 是在 DOM 绘制之前，这样可以方便修改 DOM ，这样浏览器只会绘制一次，如果修改 DOM 布局放在 <code>useEffect</code> ，那 <code>useEffect</code> 执行是在浏览器绘制视图之后，接下来又改 DOM ，就可能会导致浏览器再次回流和重绘。而且由于两次绘制，视图上可能会造成闪现突兀的效果。<code>useLayoutEffect</code> callback 中代码执行会阻塞浏览器绘制。</p>
<p>useEffect 对 React 执行栈来看是异步执行的，而 componentDidMount &#x2F; componentDidUpdate 是同步执行的，useEffect代码不会阻塞浏览器绘制。在时机上 ，componentDidMount &#x2F; componentDidUpdate 和 useLayoutEffect 更类似。</p>
 
      <!-- reward -->
      
      <div id="reword-out">
        <div id="reward-btn">
          打赏
        </div>
      </div>
      
    </div>
    

    <!-- copyright -->
    
    <div class="declare">
      <ul class="post-copyright">
        <li>
          <i class="ri-copyright-line"></i>
          <strong>版权声明： </strong>
          
          本博客所有文章除特别声明外，著作权归作者所有。转载请注明出处！
          
        </li>
      </ul>
    </div>
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/React/" rel="tag">React</a></li></ul>

    </footer>
  </div>

   
  <nav class="article-nav">
    
      <a href="/posts/45921b9c4451/" class="article-nav-link">
        <strong class="article-nav-caption">上一篇</strong>
        <div class="article-nav-title">
          
            ESLint 和 Prettier 区别
          
        </div>
      </a>
    
    
      <a href="/posts/8d49fda41a82/" class="article-nav-link">
        <strong class="article-nav-caption">下一篇</strong>
        <div class="article-nav-title">React原理 props深入</div>
      </a>
    
  </nav>

  
   
<div class="gitalk" id="gitalk-container"></div>

<link rel="stylesheet" href="https://cdn.staticfile.org/gitalk/1.7.2/gitalk.min.css">


<script src="https://cdn.staticfile.org/gitalk/1.7.2/gitalk.min.js"></script>


<script src="https://cdn.staticfile.org/blueimp-md5/2.19.0/js/md5.min.js"></script>

<script type="text/javascript">
  var gitalk = new Gitalk({
    clientID: 'bce2317b25da7c3c18f6',
    clientSecret: 'e0ab868ca9054234798be82c2b1c0c9dd8632307',
    repo: 'noopn.github.io',
    owner: 'noopn',
    admin: ['noopn'],
    // id: location.pathname,      // Ensure uniqueness and length less than 50
    id: md5(location.pathname),
    distractionFreeMode: false,  // Facebook-like distraction free mode
    pagerDirection: 'last'
  })

  gitalk.render('gitalk-container')
</script>

     
</article>

</section>
      <footer class="footer">
  <div class="outer">
    <ul>
      <li>
        Copyrights &copy;
        2015-2024
        <i class="ri-heart-fill heart_icon"></i> SunZhiqi
      </li>
    </ul>
    <ul>
      <li>
        
      </li>
    </ul>
    <ul>
      <li>
        
      </li>
    </ul>
    <ul>
      
    </ul>
    <ul>
      
    </ul>
    <ul>
      <li>
        <!-- cnzz统计 -->
        
      </li>
    </ul>
  </div>
</footer>    
    </main>
    <div class="float_btns">
      <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>

    </div>
    <aside class="sidebar on">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/ayer-side.png" alt="四月八日"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">归档</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories">分类</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags">标签</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags/Essay">随笔</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="搜索">
        <i class="ri-search-line"></i>
      </a>
      
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>此时无声胜有声！</p>
  <div class="reward-box">
    
    <div class="reward-item">
      <img class="reward-img" src="/images/alipay.jpg">
      <span class="reward-type">支付宝</span>
    </div>
    
    
    <div class="reward-item">
      <img class="reward-img" src="/images/wechat.jpg">
      <span class="reward-type">微信</span>
    </div>
    
  </div>
</div>
    
<script src="/js/jquery-3.6.0.min.js"></script>
 
<script src="/js/lazyload.min.js"></script>

<!-- Tocbot -->
 
<script src="/js/tocbot.min.js"></script>

<script>
  tocbot.init({
    tocSelector: ".tocbot",
    contentSelector: ".article-entry",
    headingSelector: "h1, h2, h3, h4, h5, h6",
    hasInnerContainers: true,
    scrollSmooth: true,
    scrollContainer: "main",
    positionFixedSelector: ".tocbot",
    positionFixedClass: "is-position-fixed",
    fixedSidebarOffset: "auto",
  });
</script>

<script src="/js/jquery.modal.min.js"></script>
<link rel="stylesheet" href="/css/jquery.modal.min.css" />
<script src="/js/jquery.justifiedGallery.min.js"></script>

<script src="/dist/main.js"></script>

<!-- ImageViewer -->
 <!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">
  <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
  <div class="pswp__bg"></div>

  <!-- Slides wrapper with overflow:hidden. -->
  <div class="pswp__scroll-wrap">
    <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
    <div class="pswp__container">
      <div class="pswp__item"></div>
      <div class="pswp__item"></div>
      <div class="pswp__item"></div>
    </div>

    <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
    <div class="pswp__ui pswp__ui--hidden">
      <div class="pswp__top-bar">
        <!--  Controls are self-explanatory. Order can be changed. -->

        <div class="pswp__counter"></div>

        <button
          class="pswp__button pswp__button--close"
          title="Close (Esc)"
        ></button>

        <button
          class="pswp__button pswp__button--share"
          style="display: none"
          title="Share"
        ></button>

        <button
          class="pswp__button pswp__button--fs"
          title="Toggle fullscreen"
        ></button>

        <button
          class="pswp__button pswp__button--zoom"
          title="Zoom in/out"
        ></button>

        <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
        <!-- element will get class pswp__preloader--active when preloader is running -->
        <div class="pswp__preloader">
          <div class="pswp__preloader__icn">
            <div class="pswp__preloader__cut">
              <div class="pswp__preloader__donut"></div>
            </div>
          </div>
        </div>
      </div>

      <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
        <div class="pswp__share-tooltip"></div>
      </div>

      <button
        class="pswp__button pswp__button--arrow--left"
        title="Previous (arrow left)"
      ></button>

      <button
        class="pswp__button pswp__button--arrow--right"
        title="Next (arrow right)"
      ></button>

      <div class="pswp__caption">
        <div class="pswp__caption__center"></div>
      </div>
    </div>
  </div>
</div>

<link rel="stylesheet" href="/css/photoswipe.min.css" />
<link rel="stylesheet" href="/css/default-skin.min.css" />
<script src="/js/photoswipe.min.js"></script>
<script src="/js/photoswipe-ui-default.min.js"></script>

<script>
  function viewer_init() {
    let pswpElement = document.querySelectorAll(".pswp")[0];
    let $imgArr = document.querySelectorAll(
      ".article-entry img:not(.reward-img)"
    );

    $imgArr.forEach(($em, i) => {
      $em.onclick = () => {
        // slider展开状态
        // todo: 这样不好，后面改成状态
        if (document.querySelector(".left-col.show")) return;
        let items = [];
        $imgArr.forEach(($em2, i2) => {
          let img = $em2.getAttribute("data-idx", i2);
          let src =
            $em2.getAttribute("data-target") || $em2.getAttribute("src");
          let title = $em2.getAttribute("alt");
          // 获得原图尺寸
          const image = new Image();
          image.src = src;
          items.push({
            src: src,
            w: image.width || $em2.width,
            h: image.height || $em2.height,
            title: title,
          });
        });
        var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
          index: parseInt(i),
        });
        gallery.init();
      };
    });
  }
  viewer_init();
</script>
 
<!-- MathJax -->
 <script type="text/x-mathjax-config">
  MathJax.Hub.Config({
      tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
  });

  MathJax.Hub.Queue(function() {
      var all = MathJax.Hub.getAllJax(), i;
      for(i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
      }
  });
</script>

<script src="/js/MathJax.js"></script>
<script src="/js/TeX-AMS-MML_HTMLorMML-full.js"></script>

<script>
  var ayerConfig = {
    mathjax: true,
  };
</script>

<!-- Katex -->

<!-- busuanzi  -->

<!-- ClickLove -->

<!-- ClickBoom1 -->

<!-- ClickBoom2 -->

<!-- CodeCopy -->
 
<link rel="stylesheet" href="/css/clipboard.css">
 <script src="/js/clipboard.min.js"></script>
<script>
  function wait(callback, seconds) {
    var timelag = null;
    timelag = window.setTimeout(callback, seconds);
  }
  !(function (e, t, a) {
    var initCopyCode = function () {
      var copyHtml = "";
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="ri-file-copy-2-line"></i><span>COPY</span>';
      copyHtml += "</button>";
      $(".highlight .code pre").before(copyHtml);
      $(".article pre code").before(copyHtml);
      var clipboard = new ClipboardJS(".btn-copy", {
        target: function (trigger) {
          return trigger.nextElementSibling;
        },
      });
      clipboard.on("success", function (e) {
        let $btn = $(e.trigger);
        $btn.addClass("copied");
        let $icon = $($btn.find("i"));
        $icon.removeClass("ri-file-copy-2-line");
        $icon.addClass("ri-checkbox-circle-line");
        let $span = $($btn.find("span"));
        $span[0].innerText = "COPIED";

        wait(function () {
          // 等待两秒钟后恢复
          $icon.removeClass("ri-checkbox-circle-line");
          $icon.addClass("ri-file-copy-2-line");
          $span[0].innerText = "COPY";
        }, 2000);
      });
      clipboard.on("error", function (e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass("copy-failed");
        let $icon = $($btn.find("i"));
        $icon.removeClass("ri-file-copy-2-line");
        $icon.addClass("ri-time-line");
        let $span = $($btn.find("span"));
        $span[0].innerText = "COPY FAILED";

        wait(function () {
          // 等待两秒钟后恢复
          $icon.removeClass("ri-time-line");
          $icon.addClass("ri-file-copy-2-line");
          $span[0].innerText = "COPY";
        }, 2000);
      });
    };
    initCopyCode();
  })(window, document);
</script>
 
<!-- CanvasBackground -->

<script>
  if (window.mermaid) {
    mermaid.initialize({ theme: "default" });
  }
</script>


    
    

  </div>
</body>

</html>