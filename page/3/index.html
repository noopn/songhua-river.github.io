<!DOCTYPE html>


<html lang="zh-CN">
  

    <head>
      <meta charset="utf-8" />
       
      <meta name="keywords" content="前端 web react" />
       
      <meta name="description" content="前端技术与生活。" />
      
      <meta
        name="viewport"
        content="width=device-width, initial-scale=1, maximum-scale=1"
      />
      <title> 四月八日</title>
  <meta name="generator" content="hexo-theme-ayer">
      
      <link rel="shortcut icon" href="/favicon.ico" />
       
<link rel="stylesheet" href="/dist/main.css">
 
<link rel="stylesheet" href="/css/fonts/remixicon.css">
 
<link rel="stylesheet" href="/css/custom.css">
 
      <script src="/js/pace.min.js"></script>
       
 

      <link rel="stylesheet" href="/css/bulma.min.css" />
      <script src="/js/sweetalert2.min.js"></script>

      <!-- mermaid -->
      
      <script src="https://cdn.staticfile.org/mermaid/8.14.0/mermaid.min.js"></script>
      
      <style>
        .swal2-styled.swal2-confirm {
          font-size: 1.6rem;
        }
      </style>
    <!-- hexo injector head_end start -->
<link rel="stylesheet" href="/css/katex.min.css">

<link rel="stylesheet" href="/css/style.css">
<!-- hexo injector head_end end --></head>
  </html>
</html>


<body>
  <div id="app">
    
      
    <main class="content on">
      
<section class="cover">
    
  <div class="cover-frame">
    <div class="bg-box">
      <img src="/images/cover1.jpg" alt="image frame" />
    </div>
    <div class="cover-inner text-center text-white">
      <h1><a href="/">四月八日</a></h1>
      <div id="subtitle-box">
        
        <span id="subtitle"></span>
        
      </div>
      <div>
        
      </div>
    </div>
  </div>
  <div class="cover-learn-more">
    <a href="javascript:void(0)" class="anchor"><i class="ri-arrow-down-line"></i></a>
  </div>
</section>



<script src="https://cdn.staticfile.org/typed.js/2.0.12/typed.min.js"></script>


<!-- Subtitle -->

  <script>
    try {
      var typed = new Typed("#subtitle", {
        strings: ['愿你足够强大，也要足够温柔', '最轻的并不是一根羽毛，而是一双飞鸟的翅膀', ''],
        startDelay: 0,
        typeSpeed: 200,
        loop: true,
        backSpeed: 100,
        showCursor: true
      });
    } catch (err) {
      console.log(err)
    }
  </script>
  
<div id="main">
  <section class="outer">
  
  
  <article class="articles">
    
    
    
    
    <article
  id="posts-design/pattern/②观察者模式"
  class="article article-type-posts"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/posts/22f2c2b24324/"
    >②发布+订阅=观察者模式</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/posts/22f2c2b24324/" class="article-date">
  <time datetime="2022-12-27T04:49:16.000Z" itemprop="datePublished">2022-12-27</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">设计模式</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h4 id="像广播一样发消息"><a href="#像广播一样发消息" class="headerlink" title="像广播一样发消息"></a>像广播一样发消息</h4><p>思考一个问题，有没有一种可能，另一个人<strong>A</strong>,不知道你这个人的存在，但是却可以给你发消息。A 就像是一个广播站一样，将你们联系在一起的就是手中的收音机，你等待着 A 发布消息，而你等待消息就是一个订阅的行为。</p>
<p>或者换一种说法，你就像是一个观察者一样，观察消息有没有到来。无论哪种定义无非都是在描述一种关系，接受消息者和发送消息者之间的关系。</p>
<p>下面要实现一个新闻广播站，每当有新的新闻，会调用新闻对象的<code>broadcastNews</code>,并向观察者们推送消息。下面是一个非常不好的写法：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Observer</span> &#123;</span><br><span class="line">  <span class="title function_">update</span>(message?: &#123; <span class="attr">news</span>: <span class="built_in">string</span>[] &#125;): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NewsObserver</span> <span class="keyword">implements</span> <span class="title class_">Observer</span> &#123;</span><br><span class="line">  <span class="title function_">update</span>(message): <span class="built_in">void</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(message);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> new1 = <span class="keyword">new</span> <span class="title class_">NewsObserver</span>();</span><br><span class="line"><span class="keyword">const</span> new2 = <span class="keyword">new</span> <span class="title class_">NewsObserver</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Subscribe</span> &#123;</span><br><span class="line">  <span class="title function_">register</span>(<span class="attr">observer</span>: <span class="title class_">Observer</span>): <span class="built_in">void</span>;</span><br><span class="line">  <span class="title function_">unregister</span>(<span class="attr">observer</span>: <span class="title class_">Observer</span>): <span class="built_in">void</span>;</span><br><span class="line">  <span class="title function_">getWeather</span>(<span class="attr">city</span>: <span class="built_in">string</span>): <span class="title class_">NewsInfo</span>;</span><br><span class="line">  <span class="title function_">notify</span>(): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NewsSubscribe</span> &#123;</span><br><span class="line">  <span class="title function_">getNews</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;获取到新闻&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">broadcastNews</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> news = <span class="variable language_">this</span>.<span class="title function_">getNews</span>();</span><br><span class="line">    new1.<span class="title function_">update</span>(news);</span><br><span class="line">    new2.<span class="title function_">update</span>(news);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> newsSubscribe = <span class="keyword">new</span> <span class="title class_">NewsSubscribe</span>();</span><br></pre></td></tr></table></figure>

<p>这种写法存在着很多严重的问题：</p>
<ul>
<li>观察者与被观察者紧耦合在了一起</li>
<li>没办法在程序执行的时候动态添加或删除观察者</li>
<li>观察者是会动态变化的对象，但是没有独立且封装</li>
</ul>
<h4 id="设计观察者模式"><a href="#设计观察者模式" class="headerlink" title="设计观察者模式"></a>设计观察者模式</h4><p>首先我们让被观察者有注册观察者和取消注册观察者的能力。这样能让观察者与被观察者解耦，并在程序执行的时候动态的添加或删除。</p>
<p><strong>观察者模式定义了对象之间的一对多依赖，这样一来，当一个对象改变状态时，它的所有依赖者都会收到通知并自动更新。</strong></p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">NewsSubscribe</span> <span class="keyword">implements</span> <span class="title class_">Subscribe</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="attr">observerList</span>: <span class="title class_">Observer</span>[];</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">observerList</span> = [];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">register</span>(<span class="attr">observer</span>: <span class="title class_">Observer</span>): <span class="built_in">void</span> &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">observerList</span>.<span class="title function_">push</span>(observer);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">unregister</span>(<span class="attr">observer</span>: <span class="title class_">Observer</span>): <span class="built_in">void</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> index = <span class="variable language_">this</span>.<span class="property">observerList</span>.<span class="title function_">indexOf</span>(observer);</span><br><span class="line">    <span class="keyword">if</span> (index &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">observerList</span>.<span class="title function_">splice</span>(index, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">notify</span>(): <span class="built_in">void</span> &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">observerList</span>.<span class="title function_">forEach</span>(<span class="function">(<span class="params">observer</span>) =&gt;</span> &#123;</span><br><span class="line">      observer.<span class="title function_">update</span>();</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>被观察者不知道观察者的细节，只知道观察者实现了观察者接口。</strong></p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">NewsInfo</span> &#123;</span><br><span class="line">  <span class="attr">news</span>: <span class="built_in">string</span>[];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Observer</span> &#123;</span><br><span class="line">  <span class="title function_">update</span>(<span class="attr">subscribe</span>: <span class="title class_">NewsSubscribe</span>): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NewsObserver</span> <span class="keyword">implements</span> <span class="title class_">Observer</span> &#123;</span><br><span class="line">  <span class="title function_">update</span>(<span class="attr">subscribe</span>: <span class="title class_">NewsSubscribe</span>): <span class="built_in">void</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(subscribe.<span class="title function_">getNews</span>());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> new1 = <span class="keyword">new</span> <span class="title class_">NewsObserver</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Subscribe</span> &#123;</span><br><span class="line">  <span class="title function_">register</span>(<span class="attr">observer</span>: <span class="title class_">Observer</span>): <span class="built_in">void</span>;</span><br><span class="line">  <span class="title function_">unregister</span>(<span class="attr">observer</span>: <span class="title class_">Observer</span>): <span class="built_in">void</span>;</span><br><span class="line">  <span class="title function_">getNews</span>(<span class="attr">city</span>: <span class="built_in">string</span>): <span class="title class_">NewsInfo</span>;</span><br><span class="line">  <span class="title function_">notify</span>(): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NewsSubscribe</span> <span class="keyword">implements</span> <span class="title class_">Subscribe</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="attr">observerList</span>: <span class="title class_">Observer</span>[];</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">observerList</span> = [];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">register</span>(<span class="attr">observer</span>: <span class="title class_">Observer</span>): <span class="built_in">void</span> &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">observerList</span>.<span class="title function_">push</span>(observer);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">unregister</span>(<span class="attr">observer</span>: <span class="title class_">Observer</span>): <span class="built_in">void</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> index = <span class="variable language_">this</span>.<span class="property">observerList</span>.<span class="title function_">indexOf</span>(observer);</span><br><span class="line">    <span class="keyword">if</span> (index &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">observerList</span>.<span class="title function_">splice</span>(index, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">notify</span>(): <span class="built_in">void</span> &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">observerList</span>.<span class="title function_">forEach</span>(<span class="function">(<span class="params">observer</span>) =&gt;</span> &#123;</span><br><span class="line">      observer.<span class="title function_">update</span>(<span class="variable language_">this</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">getNews</span>(): <span class="title class_">NewsInfo</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="attr">news</span>: [<span class="string">&quot;新闻&quot;</span>],</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> newsSubscribe = <span class="keyword">new</span> <span class="title class_">NewsSubscribe</span>();</span><br><span class="line">newsSubscribe.<span class="title function_">register</span>(<span class="keyword">new</span> <span class="title class_">NewsObserver</span>());</span><br><span class="line">newsSubscribe.<span class="title function_">register</span>(<span class="keyword">new</span> <span class="title class_">NewsObserver</span>());</span><br><span class="line"></span><br><span class="line">newsSubscribe.<span class="title function_">notify</span>();</span><br></pre></td></tr></table></figure>

<ul>
<li>可以为观察者模式设置 <code>setChanged</code>  <code>hasChanged</code> 方法，此方法可以控制通知的条件，避免通知的频率过高</li>
<li>观察者模式定义了对象之间一对多的关系。主题 (也就是可观察者) 用共同的接口来更新观察者</li>
<li>观察者和可观察者之间用松耦合方式结合 (loosecoupling)，可观察者不知道观察者的细节，只知道观察者实现了观察者接口。<br>有弹</li>
<li>使用此模式时，你可从被观察者处推 (push)或拉 (pul1)数据(然而，推的方式被认为更“正确”)。</li>
<li>有多个观察者时，不可以依赖特定的通知次序</li>
</ul>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" rel="tag">设计模式</a></li></ul>

    </footer>
  </div>

   
    
</article>

    
    <article
  id="posts-webpack/webpack执行流程"
  class="article article-type-posts"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/posts/7a682c5de361/"
    >webpack执行流程</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/posts/7a682c5de361/" class="article-date">
  <time datetime="2022-11-15T01:50:56.000Z" itemprop="datePublished">2022-11-15</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/webpack/">webpack</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h3 id="主要流程"><a href="#主要流程" class="headerlink" title="主要流程"></a>主要流程</h3><ul>
<li><p>初始化阶段（Initialization）:</p>
<p>解析配置：Webpack 开始处理配置文件（如 webpack.config.js），包括解析入口点、加载器、插件等。<br>初始化插件：加载并初始化配置中指定的插件。<br>环境准备：设置编译环境，例如选择开发模式或生产模式。</p>
</li>
<li><p>编译阶段（Compilation）:</p>
<p>创建编译器：Webpack 创建一个编译器实例，它管理整个编译过程。<br>创建编译对象：创建一个新的编译对象，它包含了此次编译的所有细节。<br>读取记录：从之前的编译中读取记录（如果有），以优化编译。<br>解析入口：根据配置的入口点，分析出所有依赖的模块。</p>
</li>
<li><p>构建阶段（Building）:</p>
<p>加载模块：Webpack 递归地加载每个依赖模块，这可能涉及到使用不同的加载器处理不同类型的文件。<br>模块转换：应用加载器和插件，转换模块内容（如 TS 转 JS，SASS 转 CSS）。<br>构建依赖图：构建模块间的依赖关系图。</p>
</li>
<li><p>优化阶段（Optimization）:</p>
<p>优化模块：应用各种优化策略，以减小最终资产的大小。<br>代码分割：根据需要将代码分割成不同的块。<br>树摇（Tree Shaking）：移除未使用的代码。</p>
</li>
<li><p>输出阶段（Output）:</p>
<p>生成资产：根据依赖图，Webpack 将所有模块打包成<br>少量的打包文件（资产），通常是一个或多个 JavaScript 文件、CSS 文件和其他静态资源文件。</p>
</li>
<li><p>输出资源：将生成的打包文件写入到文件系统中，通常是输出到指定的 dist 目录。</p>
<p>完成阶段（Completion）:<br>执行插件：执行各种插件的完成钩子，完成额外的任务或清理工作。<br>输出结果：Webpack 提供编译过程的摘要和详情，如编译时间、打包后的文件大小等。<br>监听模式：如果启用了监听模式（watch mode），Webpack 将保持活跃状态，并在源文件更改时重新编译。<br>在这个过程中，Webpack 通过其强大的插件系统和加载器机制，提供了高度的可扩展性和灵活性，允许开发人员针对不同的需求和场景进行定制和优化。</p>
</li>
</ul>
<h3 id="Initialization"><a href="#Initialization" class="headerlink" title="Initialization"></a>Initialization</h3><h4 id="cli-run"><a href="#cli-run" class="headerlink" title="cli.run"></a>cli.run</h4><p>使用 commander 处理命令行参数</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 重写异常退出</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">program</span>.<span class="title function_">exitOverride</span>(<span class="title function_">async</span>(<span class="function">(<span class="params"><span class="keyword">async</span></span>) =&gt;</span> &#123;&#125;));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 监听选项 以及选项触发时的处理函数</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">program</span>.<span class="title function_">option</span>(<span class="string">&quot;--no-color&quot;</span>, <span class="string">&quot;Disable colors on console.&quot;</span>);</span><br><span class="line"><span class="variable language_">this</span>.<span class="property">program</span>.<span class="title function_">on</span>(<span class="string">&quot;option:no-color&quot;</span>, <span class="keyword">function</span> (<span class="params"></span>) &#123;&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 绑定处理函数</span></span><br><span class="line"><span class="comment">// 最终执行webpack</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">program</span>.<span class="title function_">action</span>(<span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  compiler = <span class="variable language_">this</span>.<span class="title function_">webpack</span>(config.<span class="property">options</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h4 id="创建-compiler"><a href="#创建-compiler" class="headerlink" title="创建 compiler"></a>创建 compiler</h4><blockquote>
<blockquote>
<p>node_modules\webpack\lib\webpack.js</p>
</blockquote>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">createCompiler</span> = (<span class="params">rawOptions</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> options = <span class="title function_">getNormalizedWebpackOptions</span>(rawOptions);</span><br><span class="line">  <span class="title function_">applyWebpackOptionsBaseDefaults</span>(options);</span><br><span class="line">  <span class="keyword">const</span> compiler = <span class="keyword">new</span> <span class="title class_">Compiler</span>(options);</span><br><span class="line">  <span class="keyword">new</span> <span class="title class_">NodeEnvironmentPlugin</span>(&#123;</span><br><span class="line">    <span class="attr">infrastructureLogging</span>: options.<span class="property">infrastructureLogging</span>,</span><br><span class="line">  &#125;).<span class="title function_">apply</span>(compiler);</span><br><span class="line">  <span class="comment">// 初始化所有的插件</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="title class_">Array</span>.<span class="title function_">isArray</span>(options.<span class="property">plugins</span>)) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> plugin <span class="keyword">of</span> options.<span class="property">plugins</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">typeof</span> plugin === <span class="string">&quot;function&quot;</span>) &#123;</span><br><span class="line">        plugin.<span class="title function_">call</span>(compiler, compiler);</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (plugin) &#123;</span><br><span class="line">        plugin.<span class="title function_">apply</span>(compiler);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">applyWebpackOptionsDefaults</span>(options);</span><br><span class="line">  compiler.<span class="property">hooks</span>.<span class="property">environment</span>.<span class="title function_">call</span>();</span><br><span class="line">  compiler.<span class="property">hooks</span>.<span class="property">afterEnvironment</span>.<span class="title function_">call</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 注册内部依赖插件</span></span><br><span class="line">  <span class="comment">// ExternalsPlugin</span></span><br><span class="line">  <span class="comment">// ChunkPrefetchPreloadPlugin</span></span><br><span class="line">  <span class="comment">// ArrayPushCallbackChunkFormatPlugin</span></span><br><span class="line">  <span class="comment">// EnableChunkLoadingPlugin</span></span><br><span class="line">  <span class="comment">// JsonpChunkLoadingPlugin</span></span><br><span class="line">  <span class="comment">// ImportScriptsChunkLoadingPlugin</span></span><br><span class="line">  <span class="comment">// EnableWasmLoadingPlugin</span></span><br><span class="line">  <span class="comment">// CleanPlugin</span></span><br><span class="line">  <span class="comment">// JavascriptModulesPlugin</span></span><br><span class="line">  <span class="comment">// JsonModulesPlugin</span></span><br><span class="line">  <span class="comment">// AssetModulesPlugin</span></span><br><span class="line">  <span class="comment">// EntryOptionPlugin</span></span><br><span class="line">  <span class="comment">// EntryPlugin</span></span><br><span class="line">  <span class="comment">// RuntimePlugin</span></span><br><span class="line">  <span class="comment">// InferAsyncModulesPlugin</span></span><br><span class="line">  <span class="comment">// DataUriPlugin</span></span><br><span class="line">  <span class="comment">// FileUriPlugin</span></span><br><span class="line">  <span class="comment">// CompatibilityPlugin</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// HarmonyModulesPlugin</span></span><br><span class="line">  <span class="comment">// 模块解析和绑定：它帮助 Webpack 解析和绑定 ES6 模块的 import 和 export 语句，确保模块之间的依赖关系被正确处理。</span></span><br><span class="line">  <span class="comment">// 树摇（Tree Shaking）：这个插件支持树摇优化，即移除未使用的模块或模块部分，以减小最终打包文件的大小。这是通过静态分析 import 和 export 语句来实现的。</span></span><br><span class="line">  <span class="comment">// ES6 模块的原生支持：由于 ES6 模块是 JavaScript 语言的一部分，HarmonyModulesPlugin 提供了对这些模块的原生支持，无需转换为其他格式。</span></span><br><span class="line">  <span class="comment">// 代码分割和异步加载：插件支持基于 ES6 模块的代码分割和异步加载，这有助于提高大型应用的性能。</span></span><br><span class="line">  <span class="comment">// 与其他 Webpack 特性的集成：HarmonyModulesPlugin 与 Webpack 的其他功能（如模块热替换、代码压缩等）紧密集成。</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// InferAsyncModulesPlugin</span></span><br><span class="line">  <span class="comment">// DataUriPlugin</span></span><br><span class="line">  <span class="comment">// FileUriPlugin</span></span><br><span class="line">  <span class="comment">// CompatibilityPlugin</span></span><br><span class="line">  <span class="comment">// HarmonyModulesPlugin</span></span><br><span class="line">  <span class="comment">// AMDPlugin</span></span><br><span class="line">  <span class="comment">// RequireJsStuffPlugin</span></span><br><span class="line">  <span class="comment">// CommonJsPlugin</span></span><br><span class="line">  <span class="comment">// LoaderPlugin</span></span><br><span class="line">  <span class="comment">// NodeStuffPlugin</span></span><br><span class="line">  <span class="comment">// APIPlugin</span></span><br><span class="line">  <span class="comment">// ExportsInfoApiPlugin</span></span><br><span class="line">  <span class="comment">// WebpackIsIncludedPlugin</span></span><br><span class="line">  <span class="comment">// ConstPlugin</span></span><br><span class="line">  <span class="comment">// UseStrictPlugin</span></span><br><span class="line">  <span class="comment">// RequireIncludePlugin</span></span><br><span class="line">  <span class="comment">// RequireEnsurePlugin</span></span><br><span class="line">  <span class="comment">// RequireContextPlugin</span></span><br><span class="line">  <span class="comment">// ImportPlugin</span></span><br><span class="line">  <span class="comment">// ImportMetaContextPlugin</span></span><br><span class="line">  <span class="comment">// SystemPlugin</span></span><br><span class="line">  <span class="comment">// ImportMetaPlugin</span></span><br><span class="line">  <span class="comment">// URLPlugin</span></span><br><span class="line">  <span class="comment">// DefaultStatsFactoryPlugin</span></span><br><span class="line">  <span class="comment">// DefaultStatsPresetPlugin</span></span><br><span class="line">  <span class="comment">// DefaultStatsPrinterPlugin</span></span><br><span class="line">  <span class="comment">// JavascriptMetaInfoPlugin</span></span><br><span class="line">  <span class="comment">// EnsureChunkConditionsPlugin</span></span><br><span class="line">  <span class="comment">// RemoveEmptyChunksPlugin</span></span><br><span class="line">  <span class="comment">// MergeDuplicateChunksPlugin</span></span><br><span class="line">  <span class="comment">// FlagIncludedChunksPlugin</span></span><br><span class="line">  <span class="comment">// SideEffectsFlagPlugin</span></span><br><span class="line">  <span class="comment">// FlagDependencyExportsPlugin</span></span><br><span class="line">  <span class="comment">// FlagDependencyUsagePlugin</span></span><br><span class="line">  <span class="comment">// InnerGraphPlugin</span></span><br><span class="line">  <span class="comment">// MangleExportsPlugin</span></span><br><span class="line">  <span class="comment">// ModuleConcatenationPlugin</span></span><br><span class="line">  <span class="comment">// SplitChunksPlugin</span></span><br><span class="line">  <span class="comment">// RuntimeChunkPlugin</span></span><br><span class="line">  <span class="comment">// NoEmitOnErrorsPlugin</span></span><br><span class="line">  <span class="comment">// RealContentHashPlugin</span></span><br><span class="line">  <span class="comment">// WasmFinalizeExportsPlugin</span></span><br><span class="line">  <span class="comment">// DeterministicModuleIdsPlugin</span></span><br><span class="line">  <span class="comment">// DeterministicChunkIdsPlugin</span></span><br><span class="line">  <span class="comment">// DefinePlugin</span></span><br><span class="line">  <span class="comment">// SizeLimitsPlugin</span></span><br><span class="line">  <span class="comment">// TemplatedPathPlugin</span></span><br><span class="line">  <span class="comment">// RecordIdsPlugin</span></span><br><span class="line">  <span class="comment">// WarnCaseSensitiveModulesPlugin</span></span><br><span class="line">  <span class="comment">// AddManagedPathsPlugin</span></span><br><span class="line">  <span class="comment">// ResolverCachePlugin</span></span><br><span class="line"></span><br><span class="line">  <span class="title class_">WorkerPlugin</span>;</span><br><span class="line">  <span class="keyword">new</span> <span class="title class_">WebpackOptionsApply</span>().<span class="title function_">process</span>(options, compiler);</span><br><span class="line">  compiler.<span class="property">hooks</span>.<span class="property">initialize</span>.<span class="title function_">call</span>();</span><br><span class="line">  <span class="keyword">return</span> compiler;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="compiler-run"><a href="#compiler-run" class="headerlink" title="compiler.run()"></a>compiler.run()</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="property">hooks</span>.<span class="property">beforeRun</span>.<span class="title function_">callAsync</span>(<span class="variable language_">this</span>, <span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">hooks</span>.<span class="property">run</span>.<span class="title function_">callAsync</span>(<span class="variable language_">this</span>, <span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">readRecords</span>(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="title function_">compile</span>(onCompiled);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/webpack/" rel="tag">webpack</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%B7%A5%E7%A8%8B%E5%8C%96/" rel="tag">工程化</a></li></ul>

    </footer>
  </div>

   
    
</article>

    
    <article
  id="posts-http/⑥浏览器工作原理"
  class="article article-type-posts"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/posts/05d622acd2a4/"
    >浏览器工作原理 ⑥ 页面元素</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/posts/05d622acd2a4/" class="article-date">
  <time datetime="2022-08-08T01:18:10.000Z" itemprop="datePublished">2022-08-08</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/HTTP%E4%B8%8E%E6%B5%8F%E8%A7%88%E5%99%A8/">HTTP与浏览器</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h4 id="时间线面板的参数"><a href="#时间线面板的参数" class="headerlink" title="时间线面板的参数"></a>时间线面板的参数</h4><p><img src="/posts/05d622acd2a4/0001.png"></p>
<ul>
<li><strong>Queuing 排队时间</strong></li>
</ul>
<p>图片,音频等低优先级资源可能需要给 css, js 等高优先级资源让路，所以进入排队状态。<br>同一域名下只允许6个Tcp链接，解决方法可以是使用多个二级域名，或升级http2.</p>
<ul>
<li><strong>Stalled 停滞事件</strong></li>
</ul>
<p>在真正发起链接之前，还会有因为其他原因暂停一段时间。</p>
<ul>
<li><strong>Request sent 发送数据时间</strong></li>
</ul>
<p>因为不需要关心数据是否发送成功，这一时间一般都比较快。</p>
<ul>
<li><strong>Waiting for server</strong></li>
</ul>
<p>一般也叫做TTFB,第一字节响应时间，发起请求后到收到第一个相应字节花费的时间。<br>慢的原因可能是服务器生成页面时间过久，请求头中携带的cookie过多，也可能是网络原因。</p>
<ul>
<li><strong>Content Download</strong></li>
</ul>
<p>从接受第一个字节到收到全部数据所用的时间。</p>
<h4 id="JS-CSS-对DOM解析的影响"><a href="#JS-CSS-对DOM解析的影响" class="headerlink" title="JS,CSS 对DOM解析的影响"></a>JS,CSS 对DOM解析的影响</h4><p>HTML解析器（HTML Parser）实现DOM有三个作用:</p>
<ul>
<li>描述页面结构</li>
<li>提供Api供JS消费</li>
<li>安全防护，防止不安全的内容</li>
</ul>
<p>DOM的解析和文档的加载是同步执行的，网络进程回合渲染进程创建管道链接，HTML文档会以字节流的形式发送到渲染进程中。</p>
<p>解析的过程是通过分词器将字节流分成不同的Token,如果是StartTag会被压入栈中，栈中默认有一个Document根节点，如果是EndTag并且匹配就会弹出栈。</p>
<p>当在解析的过程中遇到了script标签，因为JS脚本可能会修改DOM结构，所以会暂停HTML的解析，而且当前script标签后面的元素是访问不到的。</p>
<p>如果script标签是一个外部资源的引用，就会停止HTML解析并下载JS文件，因为下载文件是一个耗时的操作，所以浏览器本身会做一些优化，其中包括<strong>预解析操作</strong>，浏览器会单独开启一个线程，解析页面中的JS,CSS资源，并将这些资源提前下载。</p>
<p>另外如果JS文件中没有操作DOM的逻辑，可以使用async,defer属性，让JS文件而HTML解析，并行执行。</p>
<p>CSS文件加载和JS的加载也是同步进行的，但是一定要等CSS加载结束之后并生成 CSSOM 之后，才会执行JS脚本。</p>
<h4 id="分层，分块，与合成机制"><a href="#分层，分块，与合成机制" class="headerlink" title="分层，分块，与合成机制"></a>分层，分块，与合成机制</h4><p>显示图像的本质就是不断从显卡的前缓冲区中读取图片并绘制到显示器的过程，创建图片的频率和显示器的刷新率一般相同，新创建的图片会放到后缓冲区，并将前后缓冲区互换。</p>
<p>绘制一帧图像的方式，可能是重排，重绘，合成，其中的一个或是几个。不同的方式需要的性能不同。</p>
<p>实现合成的目的就是避免每一帧都需要整个页面经历重排重绘的过程，从而提高绘制性能。浏览器会将某些属性下的元素，或特定的元素单独分出一层。生成布局树之后，渲染引擎会根据布局树的特点将其转换为层树（Layer Tree）。</p>
<p>另外，绘制图片的过程并不是真的在显卡内存中保存一帧图片，而是生成一个绘制指令列表，层树中的每一层对应着一张待合成的图片，最终合成线程会将这些图层合成一张完整的图片，并发送到后缓冲区中。</p>
<p>也因为是在合成线程执行的原因，当JS主线程卡住的时候，CSS动画还是可以一直执行。</p>
<p>分块是浏览器为了提升绘制性能，在底层做的一些优化，对用户来讲是无感的。分块的目的是优先绘制靠近视口的图块，因为整个页面可能比较大，只绘制用户可见范围即可。不过有时候， 即使只绘制那些优先级最高的图块，也要耗费不少的时间，因为涉及到一个很关键的因素——<strong>纹理上传</strong>，这是因为从计算机内存上传到 GPU 内存的操作会比较慢。Chrome 又采取了一个策略：在首次合成图块的时候使用一个低分辨率的图片。比如可以是正常分辨率的一半，分辨率减少一半，纹理就减少了四分之三。在首次显示页面内容的时候，将这个低分辨率的图片显示出来，然后合成器继续绘制正常比例的网页内容，当正常比例的网页内容绘制完成后，再替换掉当前显示的低分辨率内容。这种方式会让用户在开始时看到的是低分辨率的内容,但会降低等待时间</p>
<p>CSS will-change 属性会让元素单独在一层中，从而优化变换时的性能。</p>
<h4 id="PWA"><a href="#PWA" class="headerlink" title="PWA"></a>PWA</h4><p>Progressive Web App 渐进式应用， 相当于渐进式 + web应用</p>
<p>下面来理解一下渐进式的含义, PWA让Web应用逐渐拥有本地应用的能力，可以逐步支持各种新的技术，不断优化加载速度，动画效果等。不断的缩短与本地应用的距离，这种理念下的技术都算是PWA.</p>
<p>Web应用相对于本地应用缺少：</p>
<ul>
<li>离线，或弱网环境中的使用能力。(serviceWorker)</li>
<li>web应用缺少了消息推送能力 (serviceWorker)</li>
<li>web应用缺少一级入口，希望可以从桌面直接打开而不是在浏览器中。(manifest.json)</li>
</ul>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/HTTP/" rel="tag">HTTP</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/" rel="tag">浏览器</a></li></ul>

    </footer>
  </div>

   
    
</article>

    
    <article
  id="posts-react/v18新特性"
  class="article article-type-posts"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/posts/0dfb128a2887/"
    >React 18 新特性</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/posts/0dfb128a2887/" class="article-date">
  <time datetime="2022-06-01T02:11:46.000Z" itemprop="datePublished">2022-06-01</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/React/">React</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h4 id="兼容性"><a href="#兼容性" class="headerlink" title="兼容性"></a>兼容性</h4><p>V18 已不再支持 IE11,计划时间是 2022 年 6 月 15 日, 因为用到的一些现代浏览器新特性如 <code>micro-tasks</code>,在 IE 中无法充分 polyfill .</p>
<h4 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h4><p>V18 版本在 V17 的基础上又做了一些调整。在过去的 V17 版本中,传统模式和并发模式是共存的， 通过 <code>createRoot</code> API 就可以启用并发模式。React 为向并发模式迁移的最初策略是设计三种模式。</p>
<ul>
<li>Legacy 模式： V17 中默认使用的模式。默认开启严格模式。默认同步更新。Legacy Suspense semantics。</li>
<li>Blocking 模式： Legacy 和 Concurrent 混合模式。默认开启严格模式。默认同步更新。开放一些新特性。</li>
<li>Concurrent 模式：V18 使用的模式。默认开启严格模式。默认并发更新。开发所有的新特性。</li>
</ul>
<p>React 最初的计划是用户可以从 Legacy 切换到 Blocking 模式，并不需要修改任何语法，配合严格模式（StrictMode）修改其中的报错，当所有错误被解决之后，可以直接切换到的 Concurrent 模式。</p>
<p>但在实际的场景 React 思考了以下几个问题:</p>
<ul>
<li>项目中会有成百上千个文件，开启严格模式，会有大量的错误信息，虽然不影响程序运行，但是会干扰开发并且不能快速的一次性解决。</li>
<li>启用并发模式的好处不言而喻，可能会在未来默认启用。提供 <code>startTransition</code> <code>Suspense</code> 等 API 在内部实现并发特性。用户可以增量的选择性的使用这些 API 从而获得并发的特性。</li>
<li>如果按照上述的思路，那么 Concurrent 模式和 Blocking 模式的唯一区别就只有是否提示错误信息。那么如果默认不启用并发模式，就可以不开启严格模式，用于提示错误信息。</li>
</ul>
<p>基于上面的思考，V18 的策略是不会默认启用并发的特性，即使用 <code>createRoot</code> 启用并发模式并不能体验并发的特性，如果想体验并发的特性，需要使用例如 <code>startTransition</code> 等支持并发特性的 API. 所以官方描述为 <strong>没有并发模式，只有并发特性</strong></p>
<h4 id="API"><a href="#API" class="headerlink" title="API"></a>API</h4><ul>
<li>startTransition</li>
</ul>
<p>这个 API 可以防止渲染任务立即执行，允许将应用程序中的某些更新标记为非紧急更新，因此它们会暂停，同时优先考虑更紧急的更新。这可以在一个复杂的更新中相应用户输入。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">aaaaaaaaaaaaaaa</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">100000000</span>; i += <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> a = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> [num, setNum] = useState&lt;<span class="built_in">string</span>&gt;(<span class="string">&quot;&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> [list, setList] = useState&lt;<span class="built_in">any</span>[]&gt;([]);</span><br><span class="line"><span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="title function_">setList</span>(<span class="keyword">new</span> <span class="title class_">Array</span>(<span class="number">20000</span>).<span class="title function_">fill</span>(<span class="literal">null</span>));</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> event = <span class="variable language_">document</span>.<span class="title function_">createEvent</span>(<span class="string">&quot;MouseEvents&quot;</span>);</span><br><span class="line">    event.<span class="title function_">initEvent</span>(<span class="string">&quot;click&quot;</span>, <span class="literal">true</span>, <span class="literal">true</span>);</span><br><span class="line">    <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;button&quot;</span>)!.<span class="title function_">dispatchEvent</span>(event);</span><br><span class="line">  &#125;, <span class="number">500</span>);</span><br><span class="line">&#125;, []);</span><br><span class="line"><span class="keyword">return</span> (</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">button</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">      <span class="attr">id</span>=<span class="string">&quot;button&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">      <span class="attr">type</span>=<span class="string">&quot;button&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">      <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-xml">        setNum(() =&gt; &#123;</span></span><br><span class="line"><span class="language-xml">          aaaaaaaaaaaaaaa();</span></span><br><span class="line"><span class="language-xml">          return &quot;123&quot;;</span></span><br><span class="line"><span class="language-xml">        &#125;);</span></span><br><span class="line"><span class="language-xml">      &#125;&#125;</span></span><br><span class="line"><span class="language-xml">    &gt;</span></span><br><span class="line"><span class="language-xml">      点击</span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;num&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    &#123;list.map((_, i) =&gt; (</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">key</span>=<span class="string">&#123;Math.random()&#125;</span>&gt;</span>&#123;i&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    ))&#125;</span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/&gt;</span></span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>在没有使用并发特性的时候，列表的渲染是一个同步任务，不会相应模拟的用户事件</p>
<p><img src="/posts/0dfb128a2887/0001.png"></p>
<p>当开启了并发特性之后，会被拆分成小任务异步执行</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">startTransition</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="title function_">setList</span>(<span class="keyword">new</span> <span class="title class_">Array</span>(<span class="number">20000</span>).<span class="title function_">fill</span>(<span class="literal">null</span>));</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><img src="/posts/0dfb128a2887/0002.png"></p>
<ul>
<li>useDeferredValue</li>
</ul>
<p>会创建一个数据的副本，如果当前更新是一个紧急更新，useDeferredValue 会返回之前的状态，从而优先响应紧急更新。当紧急更新渲染完成后，才会去执行的当前更新。底层实现与 useDeferredValue 类似。</p>
<p>使用 <code>useDeferredValue</code> 也可以实现相同的效果</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> [list, setList] = useState&lt;<span class="built_in">any</span>[]&gt;([]);</span><br><span class="line"><span class="keyword">const</span> dList = <span class="title function_">useDeferredValue</span>(list);</span><br></pre></td></tr></table></figure>

<ul>
<li>useId</li>
</ul>
<p>生成一个唯一 ID, 在服务端与客户端生成的相同，防止 ID 不匹配</p>
<ul>
<li>useSyncExternalStore</li>
</ul>
<p>useSyncExternalStore  是一个新的 api，经历了一次修改，由  useMutableSource  改变而来，主要用来解决外部数据撕裂问题。</p>
<p>useSyncExternalStore 能够通过强制同步更新数据让 React 组件在 CM 下安全地有效地读取外接数据源。 在 Concurrent Mode 下，React 一次渲染会分片执行（以 fiber 为单位），中间可能穿插优先级更高的更新。假如在高优先级的更新中改变了公共数据（比如 redux 中的数据），那之前低优先的渲染必须要重新开始执行，否则就会出现前后状态不一致的情况。</p>
<p>useSyncExternalStore 一般是三方状态管理库使用，我们在日常业务中不需要关注。因为 React 自身的 useState 已经原生的解决的并发特性下的 tear（撕裂）问题。useSyncExternalStore 主要对于框架开发者，比如 redux，它在控制状态时可能并非直接使用的 React 的 state，而是自己在外部维护了一个 store 对象，用发布订阅模式实现了数据更新，脱离了 React 的管理，也就无法依靠 React 自动解决撕裂问题。因此 React 对外提供了这样一个 API。</p>
<p>目前 React-Redux 8.0 已经基于 useSyncExternalStore 实现。</p>
<ul>
<li>useInsertionEffect</li>
</ul>
<p>这个 <a target="_blank" rel="noopener" href="https://github.com/reactwg/react-18/discussions/110">Hooks</a> 只建议  css-in-js 库来使用。 这个 Hooks 执行时机在 DOM 生成之后，useLayoutEffect 之前，它的工作原理大致和  useLayoutEffect  相同，只是此时无法访问  DOM  节点的引用，一般用于提前注入  <code>&lt;style&gt;</code>  脚本。</p>
<ul>
<li>Suspense</li>
</ul>
<p>官方对 空的 fallback 属性的处理方式做了改变：不再跳过 缺失值 或 值为 null 的 fallback 的 Suspense。如果没有指定 fallback 将会把 fallback 呈现为 null。</p>
<h4 id="批处理"><a href="#批处理" class="headerlink" title="批处理"></a>批处理</h4><p>在 18 之前，只有在 react 事件处理函数中，才会自动执行批处理，其它情况会多次更新</p>
<p>在 18 之后，任何情况都会自动执行批处理，多次更新始终合并为一次</p>
<p>如果想要跳出批处理使用 <code>flushSync</code></p>
<h4 id="关于卸载组件时的更新状态警告"><a href="#关于卸载组件时的更新状态警告" class="headerlink" title="关于卸载组件时的更新状态警告"></a>关于卸载组件时的更新状态警告</h4><p>有的时候会遇到如下的错误</p>
<p><img src="/posts/0dfb128a2887/0003.png"></p>
<p>这个错误表示：无法对未挂载（已卸载）的组件执行状态更新。这是一个无效操作，并且表明我们的代码中存在内存泄漏。</p>
<p>实际上，这个错误并不多见，在以往的版本中，这个警告被广泛误解，并且有些误导。</p>
<p>这个错误的初衷，原本旨在针对一些特殊场景，譬如 你在 useEffect 里面设置了定时器，或者订阅了某个事件，从而在组件内部产生了副作用，而且忘记 return 一个函数清除副作用，则会发生内存泄漏…… 之类的场景</p>
<p>但是在实际开发中，更多的场景是，我们在 useEffect 里面发送了一个异步请求，在异步函数还没有被 resolve 或者被 reject 的时候，我们就卸载了组件。 在这种场景中，警告同样会触发。但是，在这种情况下，组件内部并没有内存泄漏，因为这个异步函数已经被垃圾回收了，此时，警告具有误导性。</p>
<p>综上所述原因，在 React 18 中，官方删除了这个报错。</p>
<h4 id="返回值类型"><a href="#返回值类型" class="headerlink" title="返回值类型"></a>返回值类型</h4><p>在 React 18 中，不再检查因返回 undefined 而导致崩溃。既能返回 null，也能返回 undefined。但需要修改相应的 dts 文件。</p>
<h4 id="Strict-Mode"><a href="#Strict-Mode" class="headerlink" title="Strict Mode"></a>Strict Mode</h4><p>严格模式会打印两次日志，可以在 React DevTools 中关闭。</p>
<p>在 React 17 中，取消了其中一次渲染的控制台日志，以便让日志更容易阅读。</p>
<p>在 React 18 中，官方取消了这个限制。如果你安装了 React DevTools，第二次渲染的日志信息将显示为灰色，以柔和的方式显式在控制台。</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/React/" rel="tag">React</a></li></ul>

    </footer>
  </div>

   
    
</article>

    
    <article
  id="posts-http/⑤浏览器工作原理"
  class="article article-type-posts"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/posts/91913fe965fd/"
    >浏览器工作原理 ⑤ 页面循环系统</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/posts/91913fe965fd/" class="article-date">
  <time datetime="2022-05-29T03:30:52.000Z" itemprop="datePublished">2022-05-29</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/HTTP%E4%B8%8E%E6%B5%8F%E8%A7%88%E5%99%A8/">HTTP与浏览器</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h4 id="处理新任务"><a href="#处理新任务" class="headerlink" title="处理新任务"></a>处理新任务</h4><p>当一个线程在执行任务的时候，如何可以处理新任务，最简单的办法就是通过一个循环，不断检测是否有新的任务产生。</p>
<p>这样可以解决同一个线程中产生的新任务，但是无法解决其他线程中产生的新任务。因为没有办法直接检测其他线程是否有新任务的产生。</p>
<p>通用的模型就是<strong>消息队列</strong>，息队列是一种数据结构，可以存放要执行的任务。它符合队列“先进先出”的特点，也就是说要添加任务的话，添加到队列的尾部；要取出任务的话，从队列头部去取。</p>
<p><strong>渲染进程专门有一个 IO 线程用来接收其他进程传进来的消息</strong>，接收到消息之后，会将这些消息组装成任务发送给渲染主线程</p>
<h4 id="任务类型"><a href="#任务类型" class="headerlink" title="任务类型"></a>任务类型</h4><p>任务类型包括， 输入事件（鼠标滚动、点击、移动）、微任务、文件读写、WebSocket、JavaScript 定时器等等。</p>
<p>除此之外，消息队列中还包含了很多与页面相关的事件，如 JavaScript 执行、解析 DOM、样式计算、布局计算、CSS 动画等。</p>
<p>以上这些事件都是在主线程中执行的，所以在编写 Web 应用时，你还需要衡量这些事件所占用的时长，并想办法解决单个任务占用主线程过久的问题。</p>
<h4 id="高优先级任务"><a href="#高优先级任务" class="headerlink" title="高优先级任务"></a>高优先级任务</h4><p>一个典型的场景是监听 DOM 的改变做一些逻辑处理，如果不加入消息队列选择同步处理，在 DOM 频繁改变的时候，当前任务会被延长，导致后面的任务不能及时处理。</p>
<p>如果加入到消息队尾部，又可能影响效率，因为可能已经有很多任务在排队了。</p>
<p>针对这种情况<strong>微任务</strong>就产生了，通常我们把消息队列中的任务称为宏任务，每个宏任务中都包含了一个微任务队列，在执行宏任务的过程中，如果 DOM 有变化，那么就会将该变化添加到微任务列表中，等宏任务中的主要功能都直接完成之后，这时候，渲染引擎并不着急去执行下一个宏任务，而是执行当前宏任务中的微任务，因为 DOM 变化的事件都保存在这些微任务队列中，这样也就解决了实时性问题。</p>
<h4 id="事件循环"><a href="#事件循环" class="headerlink" title="事件循环"></a>事件循环</h4><p>浏览器处理消息队列用到了事件循环系统，但这个事件循环与 nodejs 事件循环没有关系。</p>
<ul>
<li>V8: V8 引擎自己实现了一个事件循环，但是 nodejs 和 浏览器都没有采用</li>
<li>浏览器： 不同的厂商实现可能不同，chrome 浏览器使用 <a target="_blank" rel="noopener" href="https://libevent.org/">libevent</a> 实现事件循环。</li>
<li>nodejs： 使用 <a target="_blank" rel="noopener" href="http://docs.libuv.org/en/v1.x/">libuv</a> 实现事件循环。</li>
</ul>
<h4 id="setTimeout-如何实现"><a href="#setTimeout-如何实现" class="headerlink" title="setTimeout 如何实现"></a>setTimeout 如何实现</h4><p>从使用方式上能感觉到，setTimeout 需要等待指定时间才能执行，而消息队列中的任务是立即执行的，所以 setTimeout 中的回调函数不能立即加入到消息队列中。</p>
<p>所以浏览器还维护着一个延时任务列表，包括定时器和内部一些延时任务，创建一个定时器时，渲染进程会将该定时器的回调任务添加到延迟队列中。这个回调任务包括，定义的回调函数，发起时间，延时时间。</p>
<p>在处理消息队列的时候，会调用出延时任务的方法 ProcessTimerTask 。这个方法的调用时机是当前事件循环中一个任务处理结束后开始执行。</p>
<p>ProcessDelayTask 函数会根据发起时间和延迟时间计算出到期的任务，然后依次执行这些到期的任务。等到期的任务执行完成之后，再继续下一个循环过程。</p>
<p><strong>在 Chrome 中，定时器被嵌套调用 5 次以上，系统会判断该函数方法被阻塞了，在 5 次调用之后，如果定时器的调用时间间隔小于 4 毫秒，那么浏览器会将每次调用的时间间隔设置为 4 毫秒。</strong></p>
<p><strong>未被激活的页面中定时器最小值大于 1000 毫秒，也就是说，如果标签不是当前的激活标签，那么定时器最小的时间间隔是 1000 毫秒，目的是为了优化后台页面的加载损耗以及降低耗电量。</strong></p>
<p>Chrome、Safari、Firefox 都是以 32 个 bit 来存储延时值的，32bit <strong>最大只能存放的数字是 2147483647 毫秒</strong>，这就意味着，如果 setTimeout 设置的延迟值大于 2147483647 毫秒（大约 24.8 天）时就会溢出，那么相当于延时值被设置为 0 了，这导致定时器会被立即执行。</p>
<h4 id="XMLHttpRequest-实现流程"><a href="#XMLHttpRequest-实现流程" class="headerlink" title="XMLHttpRequest 实现流程"></a>XMLHttpRequest 实现流程</h4><p>渲染进程会将请求发送给网络进程，然后网络进程负责资源的下载，等网络进程接收到数据之后，就会利用 IPC 来通知渲染进程；渲染进程接收到消息之后，会将 xhr 的回调函数封装成任务并添加到消息队列中，等主线程循环系统执行到该任务的时候，就会根据相关的状态来调用对应的回调函数。</p>
<h4 id="宏任务和微任务"><a href="#宏任务和微任务" class="headerlink" title="宏任务和微任务"></a>宏任务和微任务</h4><p>前面已经介绍过微任务的由来。</p>
<p><strong>宏任务：</strong></p>
<ul>
<li>渲染事件（如解析 DOM、计算布局、绘制）；</li>
<li>用户交互事件（如鼠标点击、滚动页面、放大缩小等）；</li>
<li>JavaScript 脚本执行事件；</li>
<li>网络请求完成</li>
<li>文件读写完成事件</li>
</ul>
<p><strong>WHATWG 规范中定义事件循环机制：</strong></p>
<ul>
<li>先从多个消息队列中选出一个最老的任务，这个任务称为 oldestTask；</li>
<li>然后循环系统记录任务开始执行的时间，并把这个 oldestTask 设置为当前正在执行的任务；</li>
<li>当任务执行完成之后，删除当前正在执行的任务，并从对应的消息队列中删除掉这个 oldestTask；</li>
<li>最后统计执行完成的时长等信息。</li>
</ul>
<p>由于宏任务不能精细的控制执行的时机，因为两个红任务之间可能被插入了很多系统级的任务。</p>
<p><strong>微任务：</strong></p>
<p>微任务就是一个需要异步执行的函数，执行时机是在主函数执行结束之后、当前宏任务结束之前。</p>
<ul>
<li>MutationObserver 监控某个 DOM 节点，然后再通过 JavaScript 来修改这个节点，或者为这个节点添加、删除部分子节点，当 DOM 节点发生变化时，就会产生 DOM 变化记录的微任务。</li>
<li>Promise 当调用 Promise.resolve() 或者 Promise.reject() 的时候，也会产生微任务。</li>
</ul>
<p>在当前宏任务中的 JavaScript 快执行完成时，也就在 JavaScript 引擎准备退出全局执行上下文并清空调用栈的时候，JavaScript 引擎会检查全局执行上下文中的微任务队列，然后按照顺序执行队列中的微任务。WHATWG 把执行微任务的时间点称为检查点。</p>
<p>如果在执行微任务的过程中，产生了新的微任务，同样会将该微任务添加到微任务队列中，V8 引擎一直循环执行微任务队列中的任务，直到队列为空才算执行结束。也就是说在执行微任务过程中产生的新的微任务并不会推迟到下个宏任务中执行，而是在当前的宏任务中继续执行。</p>
<ul>
<li>微任务和宏任务是绑定的，每个宏任务在执行时，会创建自己的微任务队列。</li>
<li>微任务的执行时长会影响到当前宏任务的时长。</li>
<li>在一个宏任务中，分别创建一个用于回调的宏任务和微任务，无论什么情况下，微任务都早于宏任务执行。</li>
</ul>
<p>通过异步操作解决了同步操作的性能问题；通过微任务解决了实时性的问题。</p>
<p><strong>W3C 最新解释</strong>:</p>
<ul>
<li><p>每一个任务都有一个任务类型，同一个类型的任务必须在一个队列，不同类型的任务可以分属于不同的队列，在一次事件循环中，浏览器可以根据实际情况从不同的队列中取出任务执行。</p>
</li>
<li><p>浏览器必须准备好一个微队列，微队列中的任务优先所有其他任务执行。</p>
</li>
</ul>
<p>因此现在 chrome 中至少有 3 个队列：</p>
<ul>
<li>延时队列： 用于存放定时器到达后的回调任务，优先级中</li>
<li>交互任务： 用于存放用户交互产生的任务，优先级高</li>
<li>微队列： 用于存放最快需要执行的任务，优先级最高</li>
</ul>
<h4 id="Promise-then-返回-Promise-的行为"><a href="#Promise-then-返回-Promise-的行为" class="headerlink" title="Promise.then 返回 Promise 的行为"></a>Promise.then 返回 Promise 的行为</h4><p>当一个 promise.then 方法返回另一个 Promise 时，thenable 的状态会吸收返回的 promise 的状态，也就是说 thenable 的状态与返回的 promise 状态保持一致</p>
<p>但是这种状态并不是立即吸收的，返回的 promise 会被使用 then 方法，包装成新的 promise 对象，并添加到微队列中</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Promise</span>.<span class="title function_">resolve</span>()</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">//1 添加到微队列</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="comment">//3 打印0</span></span><br><span class="line">    <span class="comment">//4 包装成 (Promise.resolve(4).then(res=&gt;res)).then(res=&gt;res)  =&gt; p4.then(res=&gt;res)添加到微队列</span></span><br><span class="line">    <span class="comment">//7 res=&gt;res 添加到微队列</span></span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="number">4</span>).<span class="title function_">then</span>(<span class="function">(<span class="params">res</span>) =&gt;</span> res);</span><br><span class="line">    <span class="comment">//10 完成状态</span></span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">//11 添加到微队列</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(res);</span><br><span class="line">    <span class="comment">//14 打印4</span></span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">resolve</span>()</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">//2 添加到微队列</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="comment">//5 打印1</span></span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">//6 添加到微队列</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span>);</span><br><span class="line">    <span class="comment">//8 打印2</span></span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">//9 添加到微队列</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">3</span>);</span><br><span class="line">    <span class="comment">//12 打印3</span></span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">//13 添加到微队列</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">5</span>);</span><br><span class="line">    <span class="comment">//15 打印3</span></span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/HTTP/" rel="tag">HTTP</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/" rel="tag">浏览器</a></li></ul>

    </footer>
  </div>

   
    
</article>

    
    <article
  id="posts-http/④浏览器工作原理"
  class="article article-type-posts"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/posts/142898c1a436/"
    >浏览器工作原理 ④ V8相关原理</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/posts/142898c1a436/" class="article-date">
  <time datetime="2022-05-25T01:55:26.000Z" itemprop="datePublished">2022-05-25</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/HTTP%E4%B8%8E%E6%B5%8F%E8%A7%88%E5%99%A8/">HTTP与浏览器</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h4 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h4><p>JavaScript 是一种弱类型的、动态的语言.</p>
<ul>
<li>弱类型，意味着你不需要告诉 JavaScript 引擎这个或那个变量是什么数据类型，JavaScript 引擎在运行代码的时候自己会计算出来。</li>
<li>动态，意味着你可以使用同一个变量保存不同类型的数据。</li>
</ul>
<p>数据科技分为<strong>原始类型</strong>和<strong>引用类型</strong></p>
<p>原始类型的数据保存在环境变量或词法环境中,包含这两个区域的执行上下文又被压入调用栈中,所以可以说原始类型是保存在栈空间中的.</p>
<p><strong>字符串，symbol，bigint 虽然是原始类型，实际还是存放在堆空间的。</strong></p>
<p>如果是一个引用类型,会单独存放到堆空间中,在分配了引用类型数据之后会拿到一个堆中的地址,在把这个地址保存到环境变量中.</p>
<p>JavaScript 引擎需要用栈来维护程序执行期间上下文的状态，如果栈空间大了话，所有的数据都存放在栈空间里面，那么会影响到上下文切换的效率，进而又影响到整个程序的执行效率。JavaScript 引擎需要离开当前的执行上下文，只需要将指针下移到上个执行上下文的地址就可以了.</p>
<p>所以通常情况下，栈空间都不会设置太大，主要用来存放一些原始类型的小数据。而引用类型的数据占用的空间都比较大，所以这一类数据会被存放到堆中，堆空间很大，能存放很多大的数据，不过缺点是分配内存和回收内存都会占用一定的时间。</p>
<p><strong>原始类型的赋值会完整复制变量值，而引用类型的赋值是复制引用地址。</strong></p>
<p>从内存的角度来理解<a href="/posts/6a1cb22d998b/#%E9%97%AD%E5%8C%85">闭包</a>:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> name = <span class="string">&quot;one&quot;</span>;</span><br><span class="line">  <span class="keyword">const</span> obj = &#123;</span><br><span class="line">    <span class="title function_">getName</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> name;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="title function_">setName</span>(<span class="params">_name</span>) &#123;</span><br><span class="line">      name = _name;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> bar = <span class="title function_">foo</span>();</span><br><span class="line">bar.<span class="title function_">setName</span>(<span class="string">&quot;two&quot;</span>);</span><br><span class="line">bar.<span class="title function_">getName</span>();</span><br></pre></td></tr></table></figure>

<p>当 foo 函数执行的时候,首先是编译的过程,当遇到对象的两个方法时还需要对两个方法进行词法分析, 发现引用了 name 变量.</p>
<p>JavaScript 引擎判断这是一个闭包，于是在堆空间创建换一个“closure(foo)”的对象（这是一个内部对象，JavaScript 是无法访问的），用来保存 name 变量。并把堆空间的地址保存在 foo 执行上下文中的环境变量中.</p>
<h4 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h4><p>分为栈内存回收,堆内存回收</p>
<p>栈内存回收需要用到一个<strong>记录当前执行状态的指针（称为 ESP）</strong>,指向的就是当前的执行上下文,JavaScript 引擎会通过向下移动 ESP 来销毁该函数保存在栈中的执行上下文。当下移之后如果有新的函数调用,原来的内存位置就会写入新的执行上下文.</p>
<p>回收堆中的垃圾数据，就需要用到 JavaScript 中的垃圾回收器,垃圾回收的策略都是建立<strong>代际假说</strong>的基础之上的</p>
<p>代际假说有以下两个特点：</p>
<ul>
<li>第一个是大部分对象在内存中存在的时间很短，简单来说，就是很多对象一经分配内存，很快就变得不可访问；</li>
<li>第二个是不死的对象，会活得更久。</li>
</ul>
<p>需要根据对象变量的不同生命周期长短使用不同的策略:</p>
<p>在 V8 中会把堆分为<strong>新生代</strong>和<strong>老生代</strong>两个区域，新生代中存放的是生存时间短的对象，老生代中存放的生存时间久的对象。新生区通常只支持 1 ～ 8M 的容量.副垃圾回收器，主要负责新生代的垃圾回收。主垃圾回收器，主要负责老生代的垃圾回收。</p>
<p>垃圾回收大致都分为一下几个步骤:</p>
<ul>
<li>标记活动对象和非活动对象</li>
<li>清楚非活动对象</li>
<li>内存整理,并不是所有的回收策略都需要这一步</li>
</ul>
<p><strong>副垃圾回收器</strong>主要负责新生区的垃圾回收. 大多数小的对象都会被分配到新生区，这个区域虽然不大，但是垃圾回收还是比较频繁的。用 <strong>Scavenge[ˈskævɪndʒ]</strong> 算法来处理.原理是:</p>
<p>把新生代空间对半划分为两个区域，一半是对象区域，一半是空闲区.</p>
<p>新加入的对象都会存放到对象区域，当对象区域快被写满时，就需要执行一次垃圾清理操作。在垃圾回收过程中，首先要对对象区域中的垃圾做标记；标记完成之后，就进入垃圾清理阶段，副垃圾回收器会把这些存活的对象复制到空闲区域中，同时它还会把这些对象有序地排列起来，所以这个复制过程，也就相当于完成了内存整理操作，复制后空闲区域就没有内存碎片了。</p>
<p>完成复制后，对象区域与空闲区域进行角色翻转，也就是原来的对象区域变成空闲区域，原来的空闲区域变成了对象区域。这样就完成了垃圾对象的回收操作，同时这种角色翻转的操作还能让新生代中的这两块区域无限重复使用下去。</p>
<p>由于新生代中采用的 Scavenge 算法，所以每次执行清理操作时，都需要将存活的对象从对象区域复制到空闲区域。但复制操作需要时间成本，如果新生区空间设置得太大了，那么每次清理的时间就会过久，所以为了执行效率，一般新生区的空间会被设置得比较小。</p>
<p>也正是因为新生区的空间不大，所以很容易被存活的对象装满整个区域。为了解决这个问题，JavaScript 引擎采用了对象晋升策略，也就是经过两次垃圾回收依然还存活的对象，会被移动到老生区中。</p>
<p><strong>主垃圾回收器</strong> 主要负责老生区中的垃圾回收。</p>
<p>除了新生区中晋升的对象，一些大的对象会直接被分配到老生区。因此老生区中的对象有两个特点，一个是对象占用空间大，另一个是对象存活时间长。</p>
<p>，若要在老生区中使用 Scavenge 算法进行垃圾回收，复制这些大的对象将会花费比较多的时间，从而导致回收执行效率不高，同时还会浪费一半的空间。因而，主垃圾回收器是采用标记 - 清除（Mark-Sweep）的算法进行垃圾回收的。</p>
<p>标记阶段就是从一组根元素(调用栈)开始，递归遍历这组根元素，在这个遍历过程中，能到达的元素称为活动对象，没有到达的元素就可以判断为垃圾数据。</p>
<p>因为清除部分内存会产生碎片,而碎片过多会导致大对象无法分配到足够的连续内存，于是又产生了另外一种算法——<strong>标记 - 整理（Mark-Compact）</strong>,这个标记过程仍然与标记 - 清除算法里的是一样的，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。</p>
<p><strong>全停顿</strong>,内存回收过程过长,又因为 JS 为单线程而阻塞 JS 执行,这个问题叫全停顿.</p>
<p>对于新生代的内存回收影响不大,因为内存比较小,可以全停顿等待执行完成.对于老生代会将标记过程分为一个个的子标记过程，同时让垃圾回收标记和 JavaScript 应用逻辑交替进行，直到标记阶段完成，我们把这个算法称为<strong>增量标记（Incremental Marking）算法</strong></p>
<p>使用增量标记算法，可以把一个完整的垃圾回收任务拆分为很多小的任务，这些小的任务执行时间比较短，可以穿插在其他的 JavaScript 任务中间执行，这样当执行上述动画效果时，就不会让用户因为垃圾回收任务而感受到页面的卡顿了。</p>
<h4 id="JS-如何执行"><a href="#JS-如何执行" class="headerlink" title="JS 如何执行"></a>JS 如何执行</h4><p>由解释型语言编写的程序，在每次运行时都需要通过解释器对程序进行动态解释和执行。</p>
<p>编译型语言在程序执行之前，需要经过编译器的编译过程，并且编译之后会直接保留机器能读懂的二进制文件，这样每次运行程序时，都可以直接运行该二进制文件，而不需要再次重新编译了</p>
<p><img src="/posts/142898c1a436/0001.webp"></p>
<p>字节码就是介于 AST 和机器码之间的一种代码。但是与特定类型的机器码无关，字节码需要通过解释器将其转换为机器码后才能执行。</p>
<p>如果有一段第一次执行的字节码，解释器 Ignition 会逐条解释执行。解释器 Ignition 除了负责生成字节码之外，它还有另外一个作用，就是解释执行字节码。在 Ignition 执行字节码的过程中，如果发现有热点代码（HotSpot），比如一段代码被重复执行多次，这种就称为热点代码，那么后台的编译器 TurboFan 就会把该段热点的字节码编译为高效的机器码，然后当再次执行这段被优化的代码时，只需要执行编译后的机器码就可以了，这样就大大提升了代码的执行效率。</p>
<p>字节码配合解释器和编译器是最近一段时间很火的技术，比如 Java 和 Python 的虚拟机也都是基于这种技术实现的，我们把这种技术称为即时编译（JIT）。</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/HTTP/" rel="tag">HTTP</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/" rel="tag">浏览器</a></li></ul>

    </footer>
  </div>

   
    
</article>

    
    <article
  id="posts-javascript/执行机制"
  class="article article-type-posts"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/posts/b672c2864ca4/"
    >Javascript 执行机制</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/posts/b672c2864ca4/" class="article-date">
  <time datetime="2022-05-24T01:17:59.000Z" itemprop="datePublished">2022-05-24</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/JavaScript/">JavaScript</a> / <a class="article-category-link" href="/categories/JavaScript/%E5%9F%BA%E7%A1%80/">基础</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h4 id="变量提升与执行上下文"><a href="#变量提升与执行上下文" class="headerlink" title="变量提升与执行上下文"></a>变量提升与执行上下文</h4><p>JS 代码运行会分为<strong>编译</strong>和<strong>执行</strong>两个阶段</p>
<p>所谓的变量提升，是指在 JavaScript 代码编译过程中，JavaScript 引擎把变量的声明部分和函数的声明部分提升到代码开头的“行为”。变量被提升后，会给变量设置默认值并存到内存中，这个默认值就是我们熟悉的 undefined。</p>
<p>最终在编译阶段会生成两部分内容：<strong>执行上下文（Execution context</strong>）和 <strong>可执行代码</strong>。</p>
<p>执行上下文是 JavaScript 执行一段代码时的运行环境，比如调用一个函数，就会进入这个函数的执行上下文，确定该函数在执行期间用到的诸如 this、变量、对象以及函数等。</p>
<p><img src="/posts/b672c2864ca4/0003.webp"></p>
<ul>
<li>当 JavaScript 执行全局代码的时候，会编译全局代码并创建全局执行上下文，而且在整个页面的生存周期内，全局执行上下文只有一份。</li>
<li>当调用一个函数的时候，函数体内的代码会被编译，并创建函数执行上下文，一般情况下，函数执行结束之后，创建的函数执行上下文会被销毁。</li>
<li>当使用 eval 函数的时候，eval 的代码也会被编译，并创建执行上下文。</li>
</ul>
<h4 id="调用栈"><a href="#调用栈" class="headerlink" title="调用栈"></a>调用栈</h4><p>先进先出,执行上下文通过调用栈来管理</p>
<p>全局执行是上下文最先被压入栈中, 接下来如果有函数执行,当为函数创建好执行上下文后,也会被压入栈中,当函数返回时,执行上下文会从栈顶弹出.</p>
<p>调用栈是 JavaScript 引擎追踪函数执行的一个机制，当一次有多个函数被调用时，通过调用栈就能够追踪到哪个函数正在被执行以及各函数之间的调用关系。</p>
<p>使用 <code>console.trace()</code> 可以查看当前的调用栈信息.</p>
<h4 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h4><p>作用域是指在程序中定义变量的区域，该位置决定了变量的生命周期。通俗地理解，作用域就是变量与函数的可访问范围，即作用域控制着变量和函数的可见性和生命周期。</p>
<p>ES6 总共有三种作用于, <strong>全局作用域</strong>,<strong>函数作用域</strong>,<strong>块级作用域</strong>,如果没有块级作用域会存在两个问题</p>
<ul>
<li>变量容易在不被察觉的情况下被覆盖掉</li>
<li>本应销毁的变量没有被销毁</li>
</ul>
<p>JS 通过 <code>const</code>, <code>let</code> 实现块级作用域,在创建执行上下文的时候, 这两个关键字会单独存放在<strong>词法环境</strong>中,而 <code>var</code> 声明的变量于函数会存放在变量环境中.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">let</span> b = <span class="number">2</span>;</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">let</span> b = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">var</span> c = <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">let</span> d = <span class="number">5</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">foo</span>();</span><br></pre></td></tr></table></figure>

<p>在词法环境内部，维护了一个小型栈结构，栈底是函数最外层的变量，进入一个作用域块后，就会把该作用域块内部的变量压到栈顶；当作用域执行完成之后，该作用域的信息就会从栈顶弹出，这就是词法环境的结构。这里所讲的变量是指通过 let 或者 const 声明的变量。</p>
<p><img src="/posts/b672c2864ca4/0001.webp"></p>
<p>查找方式是：沿着词法环境的栈顶向下查询，如果在词法环境中的某个块中查找到了，就直接返回给 JavaScript 引擎，如果没有查找到，那么继续在变量环境中查找。</p>
<p><img src="/posts/b672c2864ca4/0002.webp"></p>
<h4 id="作用域链于词法作用域"><a href="#作用域链于词法作用域" class="headerlink" title="作用域链于词法作用域"></a>作用域链于词法作用域</h4><p><strong>作用域链是由词法作用域决定的.</strong></p>
<p>下面的代码当 <code>bar</code> 在 <code>foo</code> 内部调用的时候, 会先查找自己的词法环境中有没有 <code>name</code>, 然后查找自己的环境变量.</p>
<p>但是当发现都没有的时候并不会在 <code>foo</code> 的词法环境和变量环境中查找,而是直接查找全局执行上下文中的词法环境和变量环境</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">bar</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(name);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> name = <span class="string">&quot;one&quot;</span>;</span><br><span class="line">  <span class="title function_">bar</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> name = <span class="string">&quot;tow&quot;</span>;</span><br><span class="line"><span class="title function_">foo</span>();</span><br></pre></td></tr></table></figure>

<p>控制变量查找顺序的就是作用域链,其实在每个执行上下文的变量环境中，都包含了一个外部引用，用来指向外 部的执行上下文，这个外部引用称为 <code>outer</code>. 但是<strong>决定作用域链的不是执行上下文,而是词法作用域</strong></p>
<p><strong>词法作用域就是指作用域是由代码中函数声明的位置来决定的，所以词法作用域是静态的作用域，通过它就能够预测代码在执行过程中如何查找标识符。</strong></p>
<p><code>foo</code> 和 <code>bar</code> 的上级作用域都是全局作用域，所以如果 foo 或者 bar 函数使用了一个它们没有定义的变量，那么它们会到全局作用域去查找。也就是说，词法作用域是代码编译阶段就决定好的，和函数是怎么调用的没有关系。</p>
<h4 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h4><p><strong>根据词法作用域的规则，内部函数 getName 和 setName 总是可以访问它们的外部函数 foo 中的变量</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> name = <span class="string">&quot;one&quot;</span>;</span><br><span class="line">  <span class="keyword">const</span> obj = &#123;</span><br><span class="line">    <span class="title function_">getName</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> name;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="title function_">setName</span>(<span class="params">_name</span>) &#123;</span><br><span class="line">      name = _name;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> bar = <span class="title function_">foo</span>();</span><br><span class="line">bar.<span class="title function_">setName</span>(<span class="string">&quot;two&quot;</span>);</span><br><span class="line">bar.<span class="title function_">getName</span>();</span><br></pre></td></tr></table></figure>

<p>当 obj 对象返回给全局变量 bar 时，虽然 foo 函数已经执行结束，但是 getName 和 setName 函数依然可以使用 foo 函数中的变量 name.</p>
<p>虽然 foo 函数执行结束后执行上下文已经从调用栈中弹出,但是由于 obj 对象的方法使用了内部 name 变量,所以 name 变量还是保存在内存中,而保存 name 变量称作闭包. 无论在那里调用 obj 对象的方法,都可以访问到 name 变量.</p>
<p><strong>在 JavaScript 中，根据词法作用域的规则，内部函数总是可以访问其外部函数中声明的变量，当通过调用一个外部函数返回一个内部函数后，即使该外部函数已经执行结束了，但是内部函数引用外部函数的变量依然保存在内存中，我们就把这些变量的集合称为闭包。</strong></p>
<p>而调用 obj 方法的时候,作用域链的顺序就是:当前执行上下文–&gt;foo 函数闭包–&gt; 全局执行上下文</p>
<h4 id="闭包回收"><a href="#闭包回收" class="headerlink" title="闭包回收"></a>闭包回收</h4><p>如果引用闭包的函数是个局部变量，等函数销毁后，在下次 JavaScript 引擎执行垃圾回收时，判断闭包这块内容如果已经不再被使用了，那么 JavaScript 引擎的垃圾回收器就会回收这块内存。</p>
<p><strong>如果该闭包会一直使用，那么它可以作为全局变量而存在；但如果使用频率不高，而且占用内存又比较大的话，那就尽量让它成为一个局部变量。</strong></p>
<h4 id="this"><a href="#this" class="headerlink" title="this"></a>this</h4><p>实现 this 的一个初衷就是 <strong>在对象内部的方法中使用对象内部的属性</strong></p>
<p>因为作用域链由词法作用域决定,所以调用 getName 并不会获取对象属性而是在全局的执行上下文中查找</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;one&quot;</span>,</span><br><span class="line">  <span class="title function_">getName</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(name);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="全局执行上下文中的-this"><a href="#全局执行上下文中的-this" class="headerlink" title="全局执行上下文中的 this"></a>全局执行上下文中的 this</h5><p>this 和作用域链的唯一交点，作用域链的最底端包含了 window 对象，全局执行上下文中的 this 也是指向 window 对象。</p>
<p>这种设计很容易误操作,所以严格模式下默认执行一个函数 this 为 undefined</p>
<h5 id="函数执行上下文中的-this"><a href="#函数执行上下文中的-this" class="headerlink" title="函数执行上下文中的 this"></a>函数执行上下文中的 this</h5><p>直接调用一个函数，其执行上下文中的 this 也是指向 window 对象的. 但是可以通过 <code>call</code> <code>apply</code> <code>bind</code> 修改 this 的指向</p>
<h5 id="通过对象调用方法-this"><a href="#通过对象调用方法-this" class="headerlink" title="通过对象调用方法 this"></a>通过对象调用方法 this</h5><p>this 是指向对象本身的。 也可以理解为在调用的时候转化为了这样的形式 <code>myObj.showThis.call(myObj)</code></p>
<h4 id="构造函数中的-this"><a href="#构造函数中的-this" class="headerlink" title="构造函数中的 this"></a>构造函数中的 this</h4><p>this 指向创建的实例. new 操作符实际上做了一下几件事.</p>
<ul>
<li>创建一个空的简单 JavaScript 对象（即{}）；</li>
<li>为步骤 1 新创建的对象添加属性__proto__，将该属性链接至构造函数的原型对象 ；</li>
<li>将步骤 1 新创建的对象作为 this 的上下文 ；</li>
<li>如果该函数没有返回对象，则返回 this。</li>
</ul>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/ES6%E5%9F%BA%E7%A1%80/" rel="tag">ES6基础</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JavaScript/" rel="tag">JavaScript</a></li></ul>

    </footer>
  </div>

   
    
</article>

    
    <article
  id="posts-http/③浏览器工作原理"
  class="article article-type-posts"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/posts/52cc0ef48986/"
    >浏览器工作原理 ③ 渲染流程</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/posts/52cc0ef48986/" class="article-date">
  <time datetime="2022-05-22T09:31:30.000Z" itemprop="datePublished">2022-05-22</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/HTTP%E4%B8%8E%E6%B5%8F%E8%A7%88%E5%99%A8/">HTTP与浏览器</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h4 id="渲染流程"><a href="#渲染流程" class="headerlink" title="渲染流程"></a>渲染流程</h4><ul>
<li><p>解析 HTML 生成 DOM 树</p>
</li>
<li><p>计算样式</p>
<p>将 CSS 文本转换为浏览器可以理解的结构——styleSheets。</p>
<p>CSS 文本中有很多属性值，如 2em、blue、bold，这些类型数值不容易被渲染引擎理解，所以需要将所有值转换为渲染引擎容易理解的、标准化的计算值，这个过程就是属性值标准化。</p>
<p>计算出 DOM 树中每个节点的具体样式,最终的样式保存在 ComputedStyle 结构内,在浏览器的开发这工具中可以查看.</p>
</li>
<li><p>布局阶段</p>
<p>接下来就需要计算出 DOM 树中可见元素的几何位置，我们把这个计算过程叫做布局。</p>
<p>DOM 树还含有很多不可见的元素,所以在显示之前，我们还要额外地构建一棵只包含可见元素布局树。DOM 树中所有不可见的节点都没有包含到布局树中。</p>
<ul>
<li>遍历 DOM 树中的所有可见节点，并把这些节点加到布局树中；</li>
<li>不可见的节点会被布局树忽略掉，</li>
<li>在执行布局操作的时候，会把布局运算的结果重新写回布局树中，所以布局树既是输入内容也是输出内容，这是布局阶段一个不合理的地方，因为在布局阶段并没有清晰地将输入内容和输出内容区分开来。针对这个问题，Chrome 团队正在重构布局代码，下一代布局系统叫 LayoutNG，试图更清晰地分离输入和输出，从而让新设计的布局算法更加简单。</li>
</ul>
</li>
</ul>
<h4 id="分层"><a href="#分层" class="headerlink" title="分层"></a>分层</h4><p>因为页面中有很多复杂的效果，如一些复杂的 3D 变换、页面滚动，或者使用 z-indexing 做 z 轴排序等，为了更加方便地实现这些效果，渲染引擎还需要为特定的节点生成专用的图层，并生成一棵对应的图层树（LayerTree）。</p>
<p>打开 Chrome 的“开发者工具”，选择“Layers”标签，就可以可视化页面的分层情况,浏览器的页面实际上被分成了很多图层，这些图层叠加后合成了最终的页面。</p>
<p>通常情况下，<strong>并不是布局树的每个节点都包含一个图层，如果一个节点没有对应的层，那么这个节点就从属于父节点的图层。</strong></p>
<ul>
<li><p>拥有 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/web/css/css_positioning/understanding_z_index/the_stacking_context">层叠上下文</a> 属性的元素会被提升为单独的一层。<br>明确定位属性的元素、定义透明属性的元素、使用 CSS 滤镜的元素等，都拥有层叠上下文属性。</p>
</li>
<li><p>需要剪裁（clip）的地方也会被创建为图层。<br>div 的大小限定为 200*200 像素，而 div 里面的文字内容比较多，文字所显示的区域肯定会超出 200*200 的面积，这时候就产生了剪裁，渲染引擎会把裁剪文字内容的一部分用于显示在 div 区域</p>
<p>出现这种裁剪情况的时候，渲染引擎会为文字部分单独创建一个层，如果出现滚动条，滚动条也会被提升为单独的层。</p>
</li>
</ul>
<h4 id="绘制图层"><a href="#绘制图层" class="headerlink" title="绘制图层"></a>绘制图层</h4><p>图层的绘制拆分成很多小的绘制指令，然后再把这些指令按照顺序组成一个待绘制列表,开发者工具 的 Layers 标签，可以查看绘制过程</p>
<p><img src="/posts/52cc0ef48986/0001.webp"></p>
<h4 id="栅格化操作"><a href="#栅格化操作" class="headerlink" title="栅格化操作"></a>栅格化操作</h4><p>实际上绘制操作是由渲染引擎中的合成线程来完成的。</p>
<p><img src="/posts/52cc0ef48986/0002.webp"></p>
<p>当图层的绘制列表准备好之后，主线程会把该绘制列表提交（commit）给合成线程.</p>
<p>合成线程会将图层划分为图块（tile），这些图块的大小通常是 256x256 或者 512x512.</p>
<p>然后<strong>合成线程会按照视口附近的图块来优先生成位图，实际生成位图的操作是由栅格化来执行的。所谓栅格化，是指将图块转换为位图。而图块是栅格化执行的最小单位</strong>.渲染进程维护了一个栅格化的线程池，所有的图块栅格化都是在线程池内执行的，</p>
<p>通常，栅格化过程都会使用 GPU 来加速生成，使用 GPU 生成位图的过程叫快速栅格化，或者 GPU 栅格化，生成的位图被保存在 GPU 内存中。</p>
<p><img src="/posts/52cc0ef48986/0003.webp"></p>
<h4 id="合成和显示"><a href="#合成和显示" class="headerlink" title="合成和显示"></a>合成和显示</h4><p>当所有图块都被光栅化，合成线程就会生成一个绘制图块的命令——“DrawQuad”，然后将该命令提交给浏览器进程。</p>
<p>浏览器进程里面有一个叫 viz 的组件，用来接收合成线程发过来的 DrawQuad 命令，然后根据 DrawQuad 命令，将其页面内容绘制到内存中，最后再将内存显示在屏幕上。</p>
<h4 id="流程总结"><a href="#流程总结" class="headerlink" title="流程总结"></a>流程总结</h4><ul>
<li>渲染进程将 HTML 内容转换为能够读懂的 DOM 树结构。</li>
<li>渲染引擎将 CSS 样式表转化为浏览器可以理解的 styleSheets，计算出 DOM 节点的样式。</li>
<li>创建布局树，并计算元素的布局信息。</li>
<li>对布局树进行分层，并生成分层树。为每个图层生成绘制列表，并将其提交到合成线程。</li>
<li>合成线程将图层分成图块，并在光栅化线程池中将图块转换成位图。</li>
<li>合成线程发送绘制图块命令 DrawQuad 给浏览器进程。</li>
<li>浏览器进程根据 DrawQuad 消息生成页面，并显示到显示器上。</li>
</ul>
<h4 id="重绘与重排"><a href="#重绘与重排" class="headerlink" title="重绘与重排"></a>重绘与重排</h4><p>如果你通过 JavaScript 或者 CSS 修改元素的几何位置属性，例如改变元素的宽度、高度等，那么浏览器会触发重新布局，解析之后的一系列子阶段，这个过程就叫重排。无疑，重排需要更新完整的渲染流水线，所以开销也是最大的。</p>
<p><img src="/posts/52cc0ef48986/0004.webp"></p>
<p>如果修改了元素的背景颜色，那么布局阶段将不会被执行，因为并没有引起几何位置的变换，所以就直接进入了绘制阶段，然后执行之后的一系列子阶段，这个过程就叫重绘。相较于重排操作，重绘省去了布局和分层阶段，所以执行效率会比重排操作要高一些。</p>
<p><img src="/posts/52cc0ef48986/0005.webp"></p>
<p>如果更改一个既不要布局也不要绘制的属性,把这个过程叫做合成</p>
<p>使用了 CSS 的 transform 来实现动画效果，这可以避开重排和重绘阶段，直接在非主线程上执行合成动画操作。这样的效率是最高的，因为是在非主线程上合成，并没有占用主线程的资源，另外也避开了布局和绘制两个子阶段，所以相对于重绘和重排，合成能大大提升绘制效率。</p>
<p><img src="/posts/52cc0ef48986/0006.webp"></p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/HTTP/" rel="tag">HTTP</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/" rel="tag">浏览器</a></li></ul>

    </footer>
  </div>

   
    
</article>

    
    <article
  id="posts-http/②浏览器工作原理"
  class="article article-type-posts"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/posts/872ab92252f5/"
    >浏览器工作原理 ② HTTP</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/posts/872ab92252f5/" class="article-date">
  <time datetime="2022-05-22T07:27:39.000Z" itemprop="datePublished">2022-05-22</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/HTTP%E4%B8%8E%E6%B5%8F%E8%A7%88%E5%99%A8/">HTTP与浏览器</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h4 id="HTTP-与-TCP-关系"><a href="#HTTP-与-TCP-关系" class="headerlink" title="HTTP 与 TCP 关系"></a>HTTP 与 TCP 关系</h4><p>浏览器使用 HTTP 协议作为应用层协议，用来封装请求的文本信息；并使用 TCP&#x2F;IP 作传输层协议将它发到网络上，所以在 HTTP 工作开始之前，浏览器需要通过 TCP 与服务器建立连接。也就是说 HTTP 的内容是通过 TCP 的传输数据阶段来实现的.</p>
<p><img src="/posts/872ab92252f5/0001.webp"> </p>
<h4 id="HTTP-请求流程"><a href="#HTTP-请求流程" class="headerlink" title="HTTP 请求流程"></a>HTTP 请求流程</h4><p>HTTP 协议，正是建立在 TCP 连接基础之上的。HTTP 是一种允许浏览器向服务器获取资源的协议，是 Web 的基础，通常由浏览器发起请求，用来获取不同类型的文件，例如 HTML 文件、CSS 文件、JavaScript 文件、图片、视频等。</p>
<h5 id="构建请求"><a href="#构建请求" class="headerlink" title="构建请求"></a>构建请求</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET /index.html HTTP1.1</span><br></pre></td></tr></table></figure>

<h5 id="查找缓存"><a href="#查找缓存" class="headerlink" title="查找缓存"></a>查找缓存</h5><p><img src="/posts/872ab92252f5/0004.png"></p>
<h6 id="强制缓存"><a href="#强制缓存" class="headerlink" title="强制缓存"></a>强制缓存</h6><p>HTTP&#x2F;1.1 定义的 Cache-Control 头用来区分对缓存机制的支持情况， 请求头和响应头都支持这个属性。通过它提供的不同的值来定义缓存策略。</p>
<ul>
<li><p>没有缓存</p>
<p>缓存中不得存储任何关于客户端请求和服务端响应的内容。每次由客户端发起的请求都会下载完整的响应内容。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cache-Control: no-store</span><br></pre></td></tr></table></figure>
</li>
<li><p>有缓存但要重新验证<br>此方式下，每次有请求发出时，缓存会将此请求发到服务器（该请求应该会带有与本地缓存相关的验证字段），服务器端会验证请求中所描述的缓存是否过期，若未过期（注：实际就是返回 304），则缓存才使用本地缓存副本。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cache-Control: no-cache</span><br></pre></td></tr></table></figure>
</li>
<li><p>过期<br>过期机制中，最重要的指令是 “max-age&#x3D;<seconds>“，表示资源能够被缓存（保持新鲜）的最大时间。max-age 是距离请求发起的时间的秒数。针对应用中那些不会改变的文件，通常可以手动设置一定的时长以保证缓存有效，例如图片、css、js 等静态资源。</p>
<p>Expires 响应头包含日期&#x2F;时间， 即在此时候之后，响应过期。如果在 Cache-Control 响应头设置了 “max-age” 或者 “s-max-age” 指令，那么 Expires 头会被忽略。</p>
</li>
</ul>
<h6 id="协商缓存"><a href="#协商缓存" class="headerlink" title="协商缓存"></a>协商缓存</h6><p>强制缓存失效后，浏览器携带缓存标识向服务器发起请求，由服务器根据缓存标识决定是否使用缓存</p>
<ul>
<li><p>Last-Modified &#x2F; If-Modified-Since</p>
<p>Last-Modified 是由服务器发送给客户端的 HTTP 响应头标签，时间值是当前资源文件的修改时间</p>
<p>If-Modified-Since 是由客户端发送给服务器的 HTTP 请求头标签，客户端再次发起该请求时，会携带上次请求返回的 Last-Modified 的时间值，对比 If-Modified-Since 的时间和该资源在服务器端最后被修改的时间，决定是否更新资源</p>
</li>
<li><p>Etag &#x2F; If-None-Match</p>
<p>Etag 是由服务器发送给客户端的 HTTP 响应头标签，是服务器端生成的资源文件的一个唯一标识</p>
<p>If-None-Match 是由客户端发送给服务器的 HTTP 请求头标签，客户端再次发起该请求时，会携带上次请求返回的 Etag 值，对比服务器端的 Etag 值和 If-None-Match 的值，决定是否更新资源</p>
</li>
</ul>
<p>优先级：Etag &#x2F; If-None-Match &gt; Last-Modified &#x2F; If-Modified-Since</p>
<h5 id="准备-IP-地址和端口"><a href="#准备-IP-地址和端口" class="headerlink" title="准备 IP 地址和端口"></a>准备 IP 地址和端口</h5><p>因为 IP 并不容易记住,通常使用域名来方法,这就需要获取 IP 和域名的对应关系.这套域名映射为 IP 的系统就叫做“域名系统”，简称 DNS（Domain Name System）。</p>
<p>现在第一步浏览器会请求 DNS 返回域名对应的 IP。当然浏览器还提供了 DNS 数据缓存服务，如果某个域名已经解析过了，那么浏览器会缓存解析的结果，以供下次查询时直接使用，这样也会减少一次网络请求。</p>
<p>拿到 IP 之后，接下来就需要获取端口号了。通常情况下，如果 URL 没有特别指明端口号，那么 HTTP 协议默认是 80 端口。</p>
<h6 id="DNS预解析"><a href="#DNS预解析" class="headerlink" title="DNS预解析"></a>DNS预解析</h6><p>dns-prefetch(DNS预获取)是前端网络性能优化的一种措施。它根据浏览器定义的规则，提前解析之后可能会用到的域名，使解析结果缓存到系统缓存中，缩短DNS解析时间，进而提高网站的访问速度。</p>
<p>每当在首次DNS解析后会对其IP进行缓存。至于缓存时长，每种浏览器都不一样，比如Chrome的过期时间是1分钟，在这个期限内不会重新请求DNS。</p>
<p>每当Chrome浏览器启动的时候，就会自动的快速解析浏览器最近一次启动时记录的前10个域名。所以经常访问的网址就不存在DNS解析的延迟，进而打开速度更快。</p>
<ul>
<li><p>dns-prefetch 仅对跨域域上的 DNS查找有效，因此请避免使用它来指向相同域。这是因为，到浏览器看到提示时，您站点域背后的IP已经被解析。</p>
</li>
<li><p>http页面下所有的a标签的href都会自动去启用DNS Prefetch，也就是说网页的a标签href带的域名，是不需要在head里面加上link手动设置的。<br>可以通过在服务器端发送 X-DNS-Prefetch-Control 报头，或是在文档中使用值为 http-equiv 的 <code>&lt;meta&gt;</code> 标签：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;x-dns-prefetch-control&quot;</span> <span class="attr">content</span>=<span class="string">&quot;on&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>强制查询特定主机名,使用 rel 属性值为 link type 中的 dns-prefetch 的 标签来对特定域名进行预读取：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;dns-prefetch&quot;</span> <span class="attr">href</span>=<span class="string">&quot;http://www.baidu.com/&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="等待-TCP-队列并建立链接"><a href="#等待-TCP-队列并建立链接" class="headerlink" title="等待 TCP 队列并建立链接"></a>等待 TCP 队列并建立链接</h5><p>Chrome 有个机制，同一个域名同时最多只能建立 6 个 TCP 连接，如果在同一个域名下同时有 10 个请求发生，那么其中 4 个请求会进入排队等待状态，直至进行中的请求完成。当然，如果当前请求数量少于 6，会直接进入下一步，建立 TCP 连接。http2 是可以并行请求资源的，所以如果使用 http2，浏览器只会为每个域名维护一个 tcp 连接.</p>
<p>接着通过三次握手建立链接</p>
<h5 id="发送-HTTP-请求"><a href="#发送-HTTP-请求" class="headerlink" title="发送 HTTP 请求"></a>发送 HTTP 请求</h5><p>HTTP 中的数据正是在这个通信过程中传输的。</p>
<p><img src="/posts/872ab92252f5/0002.webp"></p>
<h5 id="返回请求"><a href="#返回请求" class="headerlink" title="返回请求"></a>返回请求</h5><p><img src="/posts/872ab92252f5/0003.webp"></p>
<p>服务器也会随同响应向浏览器发送响应头。响应头包含了服务器自身的一些信息，比如服务器生成返回数据的时间、返回的数据类型（JSON、HTML、流媒体等类型），以及服务器要在客户端保存的 Cookie 等信息。发送完响应头后，服务器就可以继续发送响应体的数据，通常，响应体就包含了 HTML 的实际内容。</p>
<h5 id="Keep-Alive"><a href="#Keep-Alive" class="headerlink" title="Keep-Alive"></a>Keep-Alive</h5><p>通常情况下，一旦服务器向客户端返回了请求数据，它就要关闭 TCP 连接。不过如果浏览器或者服务器在其头信息中加入了：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Connection:Keep-Alive</span><br></pre></td></tr></table></figure>

<p>那么 TCP 连接在发送后将仍然保持打开状态，这样浏览器就可以继续通过同一个 TCP 连接发送请求。保持 TCP 连接可以省去下次请求时需要建立连接的时间，提升资源加载速度。比如，一个 Web 页面中内嵌的图片就都来自同一个 Web 站点，如果初始化了一个持久连接，你就可以复用该连接，以请求其他资源，而不需要重新再建立新的 TCP 连接。</p>
<h5 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h5><p>响应行返回的状态码是 301，状态 301 就是告诉浏览器，我需要重定向到另外一个网址，而需要重定向的网址正是包含在响应头的 Location 字段中，接下来，浏览器获取 Location 字段中的地址，并使用该地址重新导航</p>
<h5 id="请求的各个阶段"><a href="#请求的各个阶段" class="headerlink" title="请求的各个阶段"></a>请求的各个阶段</h5><p><img src="/posts/872ab92252f5/0004.webp"></p>
<h4 id="从输入-URL-到页面展示"><a href="#从输入-URL-到页面展示" class="headerlink" title="从输入 URL 到页面展示"></a>从输入 URL 到页面展示</h4><p>用户发出 URL 请求到页面开始解析的这个过程，就叫做导航。</p>
<h5 id="用户输入"><a href="#用户输入" class="headerlink" title="用户输入"></a>用户输入</h5><p>当用户在地址栏中输入一个查询关键字时，地址栏会判断输入的关键字是搜索内容，还是请求的 URL。</p>
<p>如果是搜索内容，地址栏会使用浏览器默认的搜索引擎，来合成新的带搜索关键字的 URL。如果判断输入内容符合 URL 规则，比如输入的是 time.geekbang.org，那么地址栏会根据规则，把这段内容加上协议，合成为完整的 URL.</p>
<p>当用户输入关键字并键入回车之后，这意味着当前页面即将要被替换成新的页面，不过在这个流程继续之前，浏览器还给了当前页面一次执行 beforeunload 事件的机会，beforeunload 事件允许页面在退出之前执行一些数据清理操作，还可以询问用户是否要离开当前页面，比如当前页面可能有未提交完成的表单等情况，因此用户可以通过 beforeunload 事件来取消导航，让浏览器不再执行任何后续工作。</p>
<h5 id="URL-请求过程"><a href="#URL-请求过程" class="headerlink" title="URL 请求过程"></a>URL 请求过程</h5><p>浏览器进程会通过进程间通信（IPC）把 URL 请求发送至网络进程，网络进程接收到 URL 请求后，会在这里发起真正的 URL 请求流程。</p>
<p>首先，网络进程会查找本地缓存是否缓存了该资源。如果有缓存资源，那么直接返回资源给浏览器进程；如果在缓存中没有查找到资源，那么直接进入网络请求流程。这请求前的第一步是要进行 DNS 解析，以获取请求域名的服务器 IP 地址。如果请求协议是 HTTPS，那么还需要建立 TLS 连接。</p>
<p>接下来就是利用 IP 地址和服务器建立 TCP 连接。连接建立之后，浏览器端会构建请求行、请求头等信息，并把和该域名相关的 Cookie 等数据附加到请求头中，然后向服务器发送构建的请求信息。</p>
<p>服务器接收到请求信息后，会根据请求信息生成响应数据（包括响应行、响应头和响应体等信息），并发给网络进程。等网络进程接收了响应行和响应头之后，就开始解析响应头的内容了。</p>
<p>在导航过程中，如果服务器响应行的状态码包含了 301、302 一类的跳转信息，浏览器会跳转到新的地址继续导航；如果响应行是 200，那么表示浏览器可以继续处理该请求。</p>
<p><strong>Content-Type 是 HTTP 头中一个非常重要的字段， 它告诉浏览器服务器返回的响应体数据是什么类型，然后浏览器会根据 Content-Type 的值来决定如何显示响应体的内容。</strong></p>
<p>例如 Content-Type 的值是 application&#x2F;octet-stream，显示数据是字节流类型的，通常情况下，浏览器会按照下载类型来处理该请求。</p>
<p>如果 Content-Type 字段的值被浏览器判断为下载类型，那么该请求会被提交给浏览器的下载管理器，同时该 URL 请求的导航流程就此结束。但如果是 HTML，那么浏览器则会继续进行导航流程。由于 Chrome 的页面渲染是运行在渲染进程中的，所以接下来就需要准备渲染进程了。</p>
<h5 id="准备渲染进程"><a href="#准备渲染进程" class="headerlink" title="准备渲染进程"></a>准备渲染进程</h5><p>默认情况下，Chrome 会为每个页面分配一个渲染进程，也就是说，每打开一个新页面就会配套创建一个新的渲染进程。但是，也有一些例外，在某些情况下，浏览器会让多个页面直接运行在同一个渲染进程中。</p>
<p>但如果从一个页面打开了另一个新页面，而新页面和当前页面属于同一站点的话，那么新页面会复用父页面的渲染进程。官方把这个默认策略叫 process-per-site-instance.</p>
<h5 id="提交文档"><a href="#提交文档" class="headerlink" title="提交文档"></a>提交文档</h5><p>所谓提交文档，就是指浏览器进程将网络进程接收到的 HTML 数据提交给渲染进程，具体流程是这样的：</p>
<ul>
<li>首先当浏览器进程接收到网络进程的响应头数据之后，便向渲染进程发起“提交文档”的消息；</li>
<li>渲染进程接收到“提交文档”的消息后，会和网络进程建立传输数据的“管道”；</li>
<li>等文档数据传输完成之后，渲染进程会返回“确认提交”的消息给浏览器进程；</li>
<li>浏览器进程在收到“确认提交”的消息后，会更新浏览器界面状态，包括了安全状态、地址栏的 URL、前进后退的历史状态，并更新 Web 页面。</li>
</ul>
<h5 id="渲染阶段"><a href="#渲染阶段" class="headerlink" title="渲染阶段"></a>渲染阶段</h5><p>文档被提交，渲染进程便开始页面解析和子资源加载了.</p>
<p>一旦页面生成完成，渲染进程会发送一个消息给浏览器进程，浏览器接收到消息后，会停止标签图标上的加载动画。</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/HTTP/" rel="tag">HTTP</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/" rel="tag">浏览器</a></li></ul>

    </footer>
  </div>

   
    
</article>

    
    <article
  id="posts-http/①浏览器工作原理"
  class="article article-type-posts"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/posts/57a0a2abab4c/"
    >浏览器工作原理 ① 浏览器架构</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/posts/57a0a2abab4c/" class="article-date">
  <time datetime="2022-05-22T05:38:27.000Z" itemprop="datePublished">2022-05-22</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/HTTP%E4%B8%8E%E6%B5%8F%E8%A7%88%E5%99%A8/">HTTP与浏览器</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h4 id="Web-应用趋势"><a href="#Web-应用趋势" class="headerlink" title="Web 应用趋势"></a>Web 应用趋势</h4><ul>
<li><p><strong>应用程序 Web 化</strong>,视频 , 音频 ,游戏的占比越来越高</p>
</li>
<li><p><strong>是 Web 应用移动化</strong>, Google 推出了 PWA 方案来整合 Web 和本地程序各自的优势</p>
</li>
<li><p><strong>Web 操作系统化</strong> ,可能以后浏览器会提供更多的模块给上层应用使用,如新支持的 WebAssembly；</p>
</li>
</ul>
<h4 id="进程与线程"><a href="#进程与线程" class="headerlink" title="进程与线程"></a>进程与线程</h4><p><strong>进程</strong>是一个程序的运行实例,启动一个程序的时候，操作系统会为该程序创建一块内存，用来存放代码、运行中的数据和一个执行任务的主线程，我们把这样的一个运行环境叫进程。 <strong>线程是依附于进程的，而进程中使用多线程并行处理能提升运算效率。</strong></p>
<p><img src="/posts/57a0a2abab4c/0001.webp"></p>
<p>进程和线程之间的关系有以下特点:</p>
<ul>
<li><p>进程中的任意一线程执行出错，都会导致整个进程的崩溃。</p>
</li>
<li><p>线程之间可以对进程的公共数据进行读写操作。</p>
</li>
<li><p>当一个进程关闭之后，操作系统会回收进程所占用的内存。</p>
<p>虽然有些程序因为代码原因,或安装了额外的插件,可能导致内存泄漏.但只要关闭进程,内存就会被回收.</p>
</li>
<li><p>进程之间的内容相互隔离。</p>
<p>进程隔离是为保护操作系统中进程互不干扰的技术，每一个进程只能访问自己占有的数据.所以一个进程如果崩溃了，或者挂起了，是不会影响到其他进程的。如果进程之间需要进行数据的通信，这时候，就需要使用用于进程间通信（IPC）的机制了。</p>
</li>
</ul>
<p>目前浏览器主要包含以下几个进程:</p>
<ul>
<li><p><strong>1 个浏览器进程</strong>。主要负责界面显示、用户交互、子进程管理，同时提供存储等功能</p>
</li>
<li><p><strong>多个渲染进程</strong>。核心任务是将 HTML、CSS 和 JavaScript 转换为用户可以与之交互的网页，排版引擎 Blink 和 JavaScript 引擎 V8 都是运行在该进程中，默认情况下，Chrome 会为每个 Tab 标签创建一个渲染进程。出于安全考虑，渲染进程都是运行在沙箱模式下。</p>
</li>
<li><p><strong>1 个 GPU 进程</strong>。其实，Chrome 刚开始发布的时候是没有 GPU 进程的。而 GPU 的使用初衷是为了实现 3D CSS 的效果，只是随后网页、Chrome 的 UI 界面都选择采用 GPU 来绘制，这使得 GPU 成为浏览器普遍的需求。最后，Chrome 在其多进程架构上也引入了 GPU 进程。</p>
</li>
<li><p><strong>1 个网络进程</strong>。主要负责页面的网络资源加载，之前是作为一个模块运行在浏览器进程里面的，后面独立出来，成为一个单独的进程。</p>
</li>
<li><p><strong>多个插件进程</strong>。主要是负责插件的运行，因插件易崩溃，所以需要通过插件进程来隔离，以保证插件进程崩溃不会对浏览器和页面造成影响。</p>
</li>
</ul>
<h4 id="页面性能指标"><a href="#页面性能指标" class="headerlink" title="页面性能指标"></a>页面性能指标</h4><ul>
<li><p>FP(First Paint):从开始加载到浏览器首次绘制像素到屏幕上的时间,也就是页面在屏幕上首次发生视觉变化的时间。</p>
</li>
<li><p>FCP（First Contentful Paint）:浏览器首次绘制来自 DOM 的内容的时间。这是用户第一次开始看到页面内容，但仅仅有内容，并不意味着它是有用的内容（例如 Header、导航栏等），也不意味着有用户要消费的内容。</p>
</li>
<li><p>FMP（First Meaningful Paint）:页面的主要内容绘制到屏幕上的时间。主要内容的定义因页面而异，例如对于博客文章，它的主要内容是标题和摘要，对于搜索页面，它的主要内容是搜索结果，对于电商的页面，图片则是主要内容。</p>
</li>
<li><p>FSP（First Screen Paint）:页面从开始加载到首屏内容全部绘制完成的时间，用户可以看到首屏的全部内容。</p>
</li>
<li><p>TTI（Time to Interactive）:表示网页第一次完全达到可交互状态的时间点，浏览器已经可以持续性的响应用户的输入。</p>
</li>
</ul>
<h4 id="如何保证页面文件能被完整地送达浏览器？"><a href="#如何保证页面文件能被完整地送达浏览器？" class="headerlink" title="如何保证页面文件能被完整地送达浏览器？"></a>如何保证页面文件能被完整地送达浏览器？</h4><p>在网络中，一个文件通常会被拆分为很多数据包来进行传输，而数据包在传输过程中又有很大概率丢失或者出错。</p>
<p>联网，实际上是一套理念和协议组成的体系架构。其中，协议是一套众所周知的规则和标准，如果各方都同意使用，那么它们之间的通信将变得毫无障碍。</p>
<h5 id="IP：把数据包送达目的主机"><a href="#IP：把数据包送达目的主机" class="headerlink" title="IP：把数据包送达目的主机"></a>IP：把数据包送达目的主机</h5><p>数据包要在互联网上进行传输，就要符合网际协议（Internet Protocol，简称 IP）标准, 访问网站就是向另一台有明确地址的计算机请求信息.</p>
<p>想通信一定要知道双方 IP 地址,用于请求和回复,另外还有 IP 版本,生存时间等,这些信息都会放在 IP 头中,并附加在数据包上. 组成的新数据包就能交给底层传输了.</p>
<p>当另外的主机接收到数据包,会将数据包拆开,并把数据交给主机上层.</p>
<h5 id="UDP：把数据包送达应用程序"><a href="#UDP：把数据包送达应用程序" class="headerlink" title="UDP：把数据包送达应用程序"></a>UDP：把数据包送达应用程序</h5><p>到达主机后还需要把数据送给应用,，需要基于 IP 之上开发能和应用打交道的协议，最常见的是“用户数据包协议（User Datagram Protocol）”，简称 UDP。</p>
<p>UDP 中一个最重要的信息是端口号，端口号其实就是一个数字，每个想访问网络的程序都需要绑定一个端口号。通过端口号 UDP 就能把指定的数据包发送给指定的程序了，所以 IP 通过 IP 地址信息把数据包发送给指定的电脑，而 UDP 通过端口号把数据包分发给正确的程序。和 IP 头一样，端口号会被装进 UDP 头里面，UDP 头再和原始数据包合并组成新的 UDP 数据包。UDP 头中除了目的端口，还有源端口号等信息。</p>
<p>在使用 UDP 发送数据时，有各种因素会导致数据包出错，虽然 UDP 可以校验数据是否正确，但是对于错误的数据包，UDP 并不提供重发机制，只是丢弃当前的包，而且 UDP 在发送之后也无法知道是否能达到目的地。虽说 UDP 不能保证数据可靠性，但是传输速度却非常快，所以 UDP 会应用在一些关注速度、但不那么严格要求数据完整性的领域，如在线视频、互动游戏等。</p>
<h5 id="TCP：把数据完整地送达应用程序"><a href="#TCP：把数据完整地送达应用程序" class="headerlink" title="TCP：把数据完整地送达应用程序"></a>TCP：把数据完整地送达应用程序</h5><p>使用 UDP 来传输会存在两个问题：</p>
<ul>
<li><p>数据包在传输过程中容易丢失；</p>
</li>
<li><p>大文件会被拆分成很多小的数据包来传输，这些小的数据包会经过不同的路由，并在不同的时间到达接收端，而 UDP 协议并不知道如何组装这些数据包，从而把这些数据包还原成完整的文件。</p>
</li>
</ul>
<p>基于这两个问题，我们引入 TCP 了。TCP（Transmission Control Protocol，传输控制协议）是一种面向连接的、可靠的、基于字节流的传输层通信协议。相对于 UDP，TCP 有下面两个特点:</p>
<ul>
<li><p>对于数据包丢失的情况，TCP 提供重传机制；</p>
</li>
<li><p>TCP 引入了数据包排序机制，用来保证把乱序的数据包组合成一个完整的文件。</p>
</li>
</ul>
<p>既然要实现重传和数据包排序,必然需要一套链接机制,这也就是三次握手,和四次挥手</p>
<ul>
<li><p>首先，建立连接阶段。这个阶段是通过“三次握手”来建立客户端和服务器之间的连接。TCP 提供面向连接的通信传输。面向连接是指在数据通信开始之前先做好两端之间的准备工作,通过三次握手建立链接.</p>
</li>
<li><p>其次，传输数据阶段。在该阶段，接收端需要对每个数据包进行确认操作，也就是接收端在接收到数据包之后，需要发送确认数据包给发送端。所以当发送端发送了一个数据包之后，在规定时间内没有接收到接收端反馈的确认消息，则判断为数据包丢失，并触发发送端的重发机制。同样，一个大的文件在传输过程中会被拆分成很多小的数据包，这些数据包到达接收端后，接收端会按照 TCP 头中的序号为其排序，从而保证组成完整的数据。</p>
</li>
<li><p>最后，断开连接阶段。数据传输完毕之后，就要终止连接了，涉及到最后一个阶段“四次挥手”来保证双方都能断开连接。</p>
</li>
</ul>
<h4 id="FAQ"><a href="#FAQ" class="headerlink" title="FAQ"></a>FAQ</h4><ul>
<li><p>浏览器可以同时打开多个页签，他们端口一样吗？如果一样，数据怎么知道去哪个页签？</p>
<p>端口一样的，网络进程知道每个 tcp 链接所对应的标签是那个，所以接收到数据后，会把数据分发给对应的渲染进程。</p>
</li>
<li><p>TCP 传送数据时 浏览器端就做渲染处理了么？如果前面数据包丢了 后面数据包先来是要等么？类似的那种实时渲染怎么处理？针对数据包的顺序性？</p>
<p>接收到 http 响应头中的 content-type 类型时就开始准备渲染进程了，响应体数据一旦接受到便开始做 DOM 解析了！基于 http 不用担心数据包丢失的问题，因为丢包和重传都是在 tcp 层解决的。http 能保证数据按照顺序接收的（也就是说，从 tcp 到 http 的数据就已经是完整的了，即便是实时渲染，如果发生丢包也得在重传后才能开始渲染）</p>
</li>
<li><p>http 和 websocket 都是属于应用层的协议吗？</p>
<p>都是应用层协议，而且 websocket 名字取的比较有迷惑性，其实和 socket 完全不一样，可以把 websocket 看出是 http 的改造版本，增加了服务器向客户端主动发送消息的能力。</p>
</li>
</ul>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/HTTP/" rel="tag">HTTP</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/" rel="tag">浏览器</a></li></ul>

    </footer>
  </div>

   
    
</article>

    
  </article>
  

  
  <nav class="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/2/">上一页</a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><a class="page-number" href="/page/5/">5</a><span class="space">&hellip;</span><a class="page-number" href="/page/28/">28</a><a class="extend next" rel="next" href="/page/4/">下一页</a>
  </nav>
  
</section>
</div>

      <footer class="footer">
  <div class="outer">
    <ul>
      <li>
        Copyrights &copy;
        2015-2024
        <i class="ri-heart-fill heart_icon"></i> SunZhiqi
      </li>
    </ul>
    <ul>
      <li>
        
      </li>
    </ul>
    <ul>
      <li>
        
      </li>
    </ul>
    <ul>
      
    </ul>
    <ul>
      
    </ul>
    <ul>
      <li>
        <!-- cnzz统计 -->
        
      </li>
    </ul>
  </div>
</footer>    
    </main>
    <div class="float_btns">
      <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>

    </div>
    <aside class="sidebar on">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/ayer-side.png" alt="四月八日"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">归档</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories">分类</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags">标签</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags/Essay">随笔</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="搜索">
        <i class="ri-search-line"></i>
      </a>
      
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>此时无声胜有声！</p>
  <div class="reward-box">
    
    <div class="reward-item">
      <img class="reward-img" src="/images/alipay.jpg">
      <span class="reward-type">支付宝</span>
    </div>
    
    
    <div class="reward-item">
      <img class="reward-img" src="/images/wechat.jpg">
      <span class="reward-type">微信</span>
    </div>
    
  </div>
</div>
    
<script src="/js/jquery-3.6.0.min.js"></script>
 
<script src="/js/lazyload.min.js"></script>

<!-- Tocbot -->

<script src="/js/jquery.modal.min.js"></script>
<link rel="stylesheet" href="/css/jquery.modal.min.css" />
<script src="/js/jquery.justifiedGallery.min.js"></script>

<script src="/dist/main.js"></script>

<!-- ImageViewer -->
 <!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">
  <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
  <div class="pswp__bg"></div>

  <!-- Slides wrapper with overflow:hidden. -->
  <div class="pswp__scroll-wrap">
    <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
    <div class="pswp__container">
      <div class="pswp__item"></div>
      <div class="pswp__item"></div>
      <div class="pswp__item"></div>
    </div>

    <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
    <div class="pswp__ui pswp__ui--hidden">
      <div class="pswp__top-bar">
        <!--  Controls are self-explanatory. Order can be changed. -->

        <div class="pswp__counter"></div>

        <button
          class="pswp__button pswp__button--close"
          title="Close (Esc)"
        ></button>

        <button
          class="pswp__button pswp__button--share"
          style="display: none"
          title="Share"
        ></button>

        <button
          class="pswp__button pswp__button--fs"
          title="Toggle fullscreen"
        ></button>

        <button
          class="pswp__button pswp__button--zoom"
          title="Zoom in/out"
        ></button>

        <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
        <!-- element will get class pswp__preloader--active when preloader is running -->
        <div class="pswp__preloader">
          <div class="pswp__preloader__icn">
            <div class="pswp__preloader__cut">
              <div class="pswp__preloader__donut"></div>
            </div>
          </div>
        </div>
      </div>

      <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
        <div class="pswp__share-tooltip"></div>
      </div>

      <button
        class="pswp__button pswp__button--arrow--left"
        title="Previous (arrow left)"
      ></button>

      <button
        class="pswp__button pswp__button--arrow--right"
        title="Next (arrow right)"
      ></button>

      <div class="pswp__caption">
        <div class="pswp__caption__center"></div>
      </div>
    </div>
  </div>
</div>

<link rel="stylesheet" href="/css/photoswipe.min.css" />
<link rel="stylesheet" href="/css/default-skin.min.css" />
<script src="/js/photoswipe.min.js"></script>
<script src="/js/photoswipe-ui-default.min.js"></script>

<script>
  function viewer_init() {
    let pswpElement = document.querySelectorAll(".pswp")[0];
    let $imgArr = document.querySelectorAll(
      ".article-entry img:not(.reward-img)"
    );

    $imgArr.forEach(($em, i) => {
      $em.onclick = () => {
        // slider展开状态
        // todo: 这样不好，后面改成状态
        if (document.querySelector(".left-col.show")) return;
        let items = [];
        $imgArr.forEach(($em2, i2) => {
          let img = $em2.getAttribute("data-idx", i2);
          let src =
            $em2.getAttribute("data-target") || $em2.getAttribute("src");
          let title = $em2.getAttribute("alt");
          // 获得原图尺寸
          const image = new Image();
          image.src = src;
          items.push({
            src: src,
            w: image.width || $em2.width,
            h: image.height || $em2.height,
            title: title,
          });
        });
        var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
          index: parseInt(i),
        });
        gallery.init();
      };
    });
  }
  viewer_init();
</script>
 
<!-- MathJax -->
 <script type="text/x-mathjax-config">
  MathJax.Hub.Config({
      tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
  });

  MathJax.Hub.Queue(function() {
      var all = MathJax.Hub.getAllJax(), i;
      for(i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
      }
  });
</script>

<script src="/js/MathJax.js"></script>
<script src="/js/TeX-AMS-MML_HTMLorMML-full.js"></script>

<script>
  var ayerConfig = {
    mathjax: true,
  };
</script>

<!-- Katex -->

<!-- busuanzi  -->

<!-- ClickLove -->

<!-- ClickBoom1 -->

<!-- ClickBoom2 -->

<!-- CodeCopy -->
 
<link rel="stylesheet" href="/css/clipboard.css">
 <script src="/js/clipboard.min.js"></script>
<script>
  function wait(callback, seconds) {
    var timelag = null;
    timelag = window.setTimeout(callback, seconds);
  }
  !(function (e, t, a) {
    var initCopyCode = function () {
      var copyHtml = "";
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="ri-file-copy-2-line"></i><span>COPY</span>';
      copyHtml += "</button>";
      $(".highlight .code pre").before(copyHtml);
      $(".article pre code").before(copyHtml);
      var clipboard = new ClipboardJS(".btn-copy", {
        target: function (trigger) {
          return trigger.nextElementSibling;
        },
      });
      clipboard.on("success", function (e) {
        let $btn = $(e.trigger);
        $btn.addClass("copied");
        let $icon = $($btn.find("i"));
        $icon.removeClass("ri-file-copy-2-line");
        $icon.addClass("ri-checkbox-circle-line");
        let $span = $($btn.find("span"));
        $span[0].innerText = "COPIED";

        wait(function () {
          // 等待两秒钟后恢复
          $icon.removeClass("ri-checkbox-circle-line");
          $icon.addClass("ri-file-copy-2-line");
          $span[0].innerText = "COPY";
        }, 2000);
      });
      clipboard.on("error", function (e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass("copy-failed");
        let $icon = $($btn.find("i"));
        $icon.removeClass("ri-file-copy-2-line");
        $icon.addClass("ri-time-line");
        let $span = $($btn.find("span"));
        $span[0].innerText = "COPY FAILED";

        wait(function () {
          // 等待两秒钟后恢复
          $icon.removeClass("ri-time-line");
          $icon.addClass("ri-file-copy-2-line");
          $span[0].innerText = "COPY";
        }, 2000);
      });
    };
    initCopyCode();
  })(window, document);
</script>
 
<!-- CanvasBackground -->

<script>
  if (window.mermaid) {
    mermaid.initialize({ theme: "default" });
  }
</script>


    
    

  </div>
</body>

</html>