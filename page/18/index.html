<!DOCTYPE html>


<html lang="zh-CN">
  

    <head>
      <meta charset="utf-8" />
       
      <meta name="keywords" content="前端 web react" />
       
      <meta name="description" content="前端技术与生活。" />
      
      <meta
        name="viewport"
        content="width=device-width, initial-scale=1, maximum-scale=1"
      />
      <title> 四月八日</title>
  <meta name="generator" content="hexo-theme-ayer">
      
      <link rel="shortcut icon" href="/favicon.ico" />
       
<link rel="stylesheet" href="/dist/main.css">
 
<link rel="stylesheet" href="/css/fonts/remixicon.css">
 
<link rel="stylesheet" href="/css/custom.css">
 
      <script src="/js/pace.min.js"></script>
       
 

      <link rel="stylesheet" href="/css/bulma.min.css" />
      <script src="/js/sweetalert2.min.js"></script>

      <!-- mermaid -->
      
      <script src="https://cdn.staticfile.org/mermaid/8.14.0/mermaid.min.js"></script>
      
      <style>
        .swal2-styled.swal2-confirm {
          font-size: 1.6rem;
        }
      </style>
    <!-- hexo injector head_end start -->
<link rel="stylesheet" href="/css/katex.min.css">

<link rel="stylesheet" href="/css/style.css">
<!-- hexo injector head_end end --></head>
  </html>
</html>


<body>
  <div id="app">
    
      
    <main class="content on">
      
<section class="cover">
    
  <div class="cover-frame">
    <div class="bg-box">
      <img src="/images/cover1.jpg" alt="image frame" />
    </div>
    <div class="cover-inner text-center text-white">
      <h1><a href="/">四月八日</a></h1>
      <div id="subtitle-box">
        
        <span id="subtitle"></span>
        
      </div>
      <div>
        
      </div>
    </div>
  </div>
  <div class="cover-learn-more">
    <a href="javascript:void(0)" class="anchor"><i class="ri-arrow-down-line"></i></a>
  </div>
</section>



<script src="https://cdn.staticfile.org/typed.js/2.0.12/typed.min.js"></script>


<!-- Subtitle -->

  <script>
    try {
      var typed = new Typed("#subtitle", {
        strings: ['愿你足够强大，也要足够温柔', '最轻的并不是一根羽毛，而是一双飞鸟的翅膀', ''],
        startDelay: 0,
        typeSpeed: 200,
        loop: true,
        backSpeed: 100,
        showCursor: true
      });
    } catch (err) {
      console.log(err)
    }
  </script>
  
<div id="main">
  <section class="outer">
  
  
  <article class="articles">
    
    
    
    
    <article
  id="post-algorithm/leetcode/填充每个节点的下一个右侧节点指针"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/posts/0d16fafcd38e/"
    >LeetCode 填充每个节点的下一个右侧节点指针</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/posts/0d16fafcd38e/" class="article-date">
  <time datetime="2021-01-20T07:35:11.000Z" itemprop="datePublished">2021-01-20</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E7%AE%97%E6%B3%95/">算法</a> / <a class="article-category-link" href="/categories/%E7%AE%97%E6%B3%95/%E5%85%B3%E8%81%94%E9%A2%98%E7%9B%AE/">关联题目</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/populating-next-right-pointers-in-each-node/description/">填充每个节点的下一个右侧节点指针</a></p>
<h4 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h4><p>相同层级的操作可以想到的是层序遍,但是题目中有一个问题没有说清楚,下一个右侧节点表示紧邻的右侧节点,空节点也算是一个节点,换句话说空节点不能跳过</p>
<p>在思考一下其中的细节,需要清楚一层有多少个节点，这样才能准确遍历到一层的末尾, 链接的时候空的节点不能跳过，因为这也是合法的节点。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">connect</span> = (<span class="params">root</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (root === <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> queue = [root];</span><br><span class="line">  <span class="keyword">while</span> (queue.<span class="property">length</span>) &#123;</span><br><span class="line">    <span class="comment">// 记录每一层的长度</span></span><br><span class="line">    <span class="keyword">let</span> len = queue.<span class="property">length</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (len--) &#123;</span><br><span class="line">      <span class="keyword">const</span> node = queue.<span class="title function_">shift</span>();</span><br><span class="line">      <span class="keyword">if</span> (len &amp;&amp; node) node.<span class="property">next</span> = queue[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 不需要判断空节点</span></span><br><span class="line">      <span class="keyword">if</span> (node) queue.<span class="title function_">push</span>(node.<span class="property">left</span>, node.<span class="property">right</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> root;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这个问题也可以用,递归来解决,因为它可以抽象成更小的子问题，也就是链接两个节点，需要知道的是哪些节点是需要链接的。</p>
<p>如果盲目的套用递归框架就会困惑，在另外一个子树的节点，怎么能获取到呢。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">connect</span> = (<span class="params">root</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (root === <span class="literal">null</span>) <span class="keyword">return</span> root;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (root.<span class="property">left</span>) root.<span class="property">next</span> = root.<span class="property">right</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 无法获取另外子树的节点</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> root;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>所以需要指明，那两个节点需要链接，这也是一个先序遍历的模型，但是子问题需要传递更多的信息。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">dig</span> = (<span class="params">left, right</span>) =&gt; &#123;</span><br><span class="line">  <span class="comment">// 链接两个节点</span></span><br><span class="line">  <span class="keyword">if</span> (left) left.<span class="property">next</span> = right;</span><br><span class="line">  <span class="keyword">if</span> (left) <span class="title function_">dig</span>(left.<span class="property">left</span>, left.<span class="property">right</span>);</span><br><span class="line">  <span class="keyword">if</span> (right) <span class="title function_">dig</span>(right.<span class="property">left</span>, right.<span class="property">right</span>);</span><br><span class="line">  <span class="comment">// 不同子树中需要连接的节点</span></span><br><span class="line">  <span class="keyword">if</span> (left &amp;&amp; right) <span class="title function_">dig</span>(left.<span class="property">right</span>, right.<span class="property">left</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">connect</span> = (<span class="params">root</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (root === <span class="literal">null</span>) <span class="keyword">return</span> root;</span><br><span class="line">  <span class="title function_">dig</span>(root.<span class="property">left</span>, root.<span class="property">right</span>);</span><br><span class="line">  <span class="keyword">return</span> root;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%85%B3%E8%81%94%E9%A2%98%E7%9B%AE/" rel="tag">关联题目</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%AE%97%E6%B3%95/" rel="tag">算法</a></li></ul>

    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-algorithm/leetcode/二叉树展开为链表"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/posts/13ae1e52470a/"
    >LeetCode 二叉树展开为链表</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/posts/13ae1e52470a/" class="article-date">
  <time datetime="2021-01-20T02:20:22.000Z" itemprop="datePublished">2021-01-20</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E7%AE%97%E6%B3%95/">算法</a> / <a class="article-category-link" href="/categories/%E7%AE%97%E6%B3%95/%E5%85%B3%E8%81%94%E9%A2%98%E7%9B%AE/">关联题目</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/flatten-binary-tree-to-linked-list/description/">二叉树展开为链表</a></p>
<h4 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h4><p>可以很自然想到的是需要一个递归，因为他需要先序遍历<br>我们会直接进入到每个左边子树的左节点。<br>但是这经过的右子树是暂时用不到的，所以需要想办法把他们存起来，在稍后使用</p>
<!-- It's natural to think that a recursive approach is needed, as it requires a pre-order traversal.
We will directly move into the left node of each left subtree.
However, the right subtrees encountered along the way are temporarily unused,
so we need a way to store them for later use. -->

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">flatten</span> = (<span class="params">root</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (root === <span class="literal">null</span>) <span class="keyword">return</span> root;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> stack = [];</span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">dig</span> = (<span class="params">root</span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (root === <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">const</span> right = root.<span class="property">right</span>;</span><br><span class="line">    root.<span class="property">right</span> = <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">// 暂存右节点</span></span><br><span class="line">    <span class="keyword">if</span> (right !== <span class="literal">null</span>) stack.<span class="title function_">push</span>(right);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将左节点放到有节点上</span></span><br><span class="line">    <span class="comment">// 并先序遍历继续递归向下</span></span><br><span class="line">    <span class="keyword">if</span> (root.<span class="property">left</span> !== <span class="literal">null</span>) &#123;</span><br><span class="line">      root.<span class="property">right</span> = root.<span class="property">left</span>;</span><br><span class="line">      root.<span class="property">left</span> = <span class="literal">null</span>;</span><br><span class="line">      <span class="title function_">dig</span>(root.<span class="property">right</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 如果已经没有下面的节点</span></span><br><span class="line">      <span class="comment">// 从队列中取出最后的右子树遍历</span></span><br><span class="line">      <span class="keyword">const</span> next = stack.<span class="title function_">pop</span>();</span><br><span class="line">      <span class="keyword">if</span> (next == <span class="literal">undefined</span>) <span class="keyword">return</span>;</span><br><span class="line">      root.<span class="property">right</span> = next;</span><br><span class="line">      <span class="title function_">dig</span>(next);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="title function_">dig</span>(root);</span><br><span class="line">  <span class="keyword">return</span> root;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>还可以思考用 O(1) 的空间复杂度，解决这个问题。既然不能用额外的储存空间，那么可以考虑将用到的信息放在树的节点上操作。</p>
<p>题目要求是以先序遍历的顺序，并且通用右指针相连，对于右指针相连这个问题我们可以弱化它，因为这可以通过节点交换很容易的完成。</p>
<p>而以先序遍历顺序返回，并不意味着一定要先访问根节点，只要处理之后的链表的顺序是先序遍历就可以了，所以对于一个只有三个节点的子树来说，将右节点接在左节点的后面就是先序遍历。</p>
<p>那要如何保证在访问根节点的时候，左右子树都是一个处理好的链表，我们会想到后序遍历，因为在访问某个节点的时候，他的左右子树都已经在后序遍历的代码位置处理成了链表，可以直接拼接。</p>
<p>所以可以写出下面的框架</p>
<!-- We can also consider solving this problem with O(1) space complexity/kəmˈpleksəti/. Since(通常用于提供上下文或理由而不强调原因。) we cannot use extra/ˈekstrə/ storage space, we might think about leveraging(充分利用) the tree nodes themselves to store and operate on the required information.

The problem requires linking nodes in pre-order traversal order using the right pointer. However, we can simplify this requirement for right-pointer linking, as it can be easily achieved through node rearrangement later.

Returning the nodes in pre-order traversal order doesn't necessarily mean visiting the root node first. As long as the final linked list follows the pre-order traversal sequence, it's valid. For example, in a subtree with only three nodes, connecting the right child to the end of the left child's list achieves the pre-order traversal order.

So, how can we ensure that, when visiting a root node, its left and right subtrees are already processed into linked lists? Post-order traversal comes to mind, as it ensures that when processing a node, its left and right subtrees have already been transformed into linked lists, making it easy to concatenate them.

Based on this, we can construct the following framework: -->

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">dig</span> = (<span class="params">root</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (root === <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">  <span class="title function_">dig</span>(root.<span class="property">left</span>);</span><br><span class="line">  <span class="title function_">dig</span>(root.<span class="property">right</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 处理左右节点</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">flatten</span> = (<span class="params">root</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (root === <span class="literal">null</span>) <span class="keyword">return</span> root;</span><br><span class="line">  <span class="title function_">dig</span>(root);</span><br><span class="line">  <span class="keyword">return</span> root;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>思考一些具体的细节，当一个节点的左节点不存在的时候，可以直接跳过，因为它只有一个右节点的话不需要处理，或者右节点已经处理成一个链表。</p>
<p>而当一个左节点存在的时候，需要能获取到左节点这个链表中的最后一个，才能和右节点相连，最后还需要交换左右节点。</p>
<!-- When a node does not have a left child, we can simply skip it because if it only has a right child, there is no need for processing, or the right child has already been processed into a linked list.

However, when a left child exists, we need to find the last node in the linked list formed by the left child to connect it with the right child. Finally, we need to swap the left and right children. -->

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">dig</span> = (<span class="params">root</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (root === <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">  <span class="title function_">dig</span>(root.<span class="property">left</span>);</span><br><span class="line">  <span class="title function_">dig</span>(root.<span class="property">right</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> last = root.<span class="property">left</span>;</span><br><span class="line">  <span class="comment">// 左节点不存在，直接返回</span></span><br><span class="line">  <span class="keyword">if</span> (last === <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取最后一个节点</span></span><br><span class="line">  <span class="keyword">while</span> (last.<span class="property">right</span>) &#123;</span><br><span class="line">    last = last.<span class="property">right</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 交换左右子树</span></span><br><span class="line">  last.<span class="property">right</span> = root.<span class="property">right</span>;</span><br><span class="line">  root.<span class="property">right</span> = root.<span class="property">left</span>;</span><br><span class="line">  root.<span class="property">left</span> = <span class="literal">null</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">flatten</span> = (<span class="params">root</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (root === <span class="literal">null</span>) <span class="keyword">return</span> root;</span><br><span class="line">  <span class="title function_">dig</span>(root);</span><br><span class="line">  <span class="keyword">return</span> root;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%85%B3%E8%81%94%E9%A2%98%E7%9B%AE/" rel="tag">关联题目</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%AE%97%E6%B3%95/" rel="tag">算法</a></li></ul>

    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-algorithm/leetcode/二叉树直径"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/posts/6a338e4e2cab/"
    >LeetCode 二叉树直径</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/posts/6a338e4e2cab/" class="article-date">
  <time datetime="2021-01-19T15:31:22.000Z" itemprop="datePublished">2021-01-19</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E7%AE%97%E6%B3%95/">算法</a> / <a class="article-category-link" href="/categories/%E7%AE%97%E6%B3%95/%E5%85%B3%E8%81%94%E9%A2%98%E7%9B%AE/">关联题目</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/diameter-of-binary-tree/">二叉树直径</a></p>
<h4 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h4><p>可以观察到两个现象</p>
<ul>
<li>直径可能并不会经过根节点</li>
<li>所谓的直径就是某个节点的左子树深度加右子树深度最长的一条</li>
</ul>
<p>那既然是获取最长的子树，是不能能套用一个之前的求 <a href="/posts/8e3fe34f62a9/">二叉树最大深度</a> 的方法, 思考以下可以使用下面这个框架么</p>
<p>这可能行不通，因为提出了 maxDeep 方法导致调用时，只能作用在根节点的左右子树。替他节点无法调用这个模式递归。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">maxDeep</span> = (<span class="params">root</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (root === <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Math</span>.<span class="title function_">max</span>(<span class="title function_">maxDeep</span>(root.<span class="property">left</span>), <span class="title function_">maxDeep</span>(root.<span class="property">right</span>)) + <span class="number">1</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> diameterOfBinaryTree = <span class="keyword">function</span> (<span class="params">root</span>) &#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>既然这样就放到内部去做, 但是这种框架面临的问题是，返回值只有一个，希望可以知道左右子树的最大深度，又要保留着已经遍历过的子树的最大直径。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> diameterOfBinaryTree = <span class="keyword">function</span> (<span class="params">root</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (root === <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> l = <span class="title function_">diameterOfBinaryTree</span>(root.<span class="property">left</span>);</span><br><span class="line">  <span class="keyword">let</span> r = <span class="title function_">diameterOfBinaryTree</span>(root.<span class="property">right</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// return Math.max(l + r, l, r) + 1;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>那就再引入一个额外的变量去保存，最大直径，让递归可以专注与子树的最大深度</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> diameterOfBinaryTree = <span class="keyword">function</span> (<span class="params">root</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (root === <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> max = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">dig</span> = (<span class="params">root</span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (root === <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> left = <span class="title function_">dig</span>(root.<span class="property">left</span>);</span><br><span class="line">    <span class="keyword">let</span> right = <span class="title function_">dig</span>(root.<span class="property">right</span>);</span><br><span class="line">    max = <span class="title class_">Math</span>.<span class="title function_">max</span>(max, left + right);</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Math</span>.<span class="title function_">max</span>(left, right) + <span class="number">1</span>;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">dig</span>(root);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> max;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>再来看一下，其实用前序遍历也可以实现，但是需要每经历一个节点，就要获取以下当前节点的左右子树的最大深度。</p>
<p>这是因为前序遍历只能获取当前节点的信息，而后序遍历则可以携带上一个节点返回的信息。</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%85%B3%E8%81%94%E9%A2%98%E7%9B%AE/" rel="tag">关联题目</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%AE%97%E6%B3%95/" rel="tag">算法</a></li></ul>

    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-javascript/Ramda_Type方法"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/posts/4f5e1b8629c3/"
    >Ramda Type 方法源码解析</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/posts/4f5e1b8629c3/" class="article-date">
  <time datetime="2021-01-19T08:01:47.000Z" itemprop="datePublished">2021-01-19</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/JavaScript/">JavaScript</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h4 id="type"><a href="#type" class="headerlink" title="type"></a>type</h4><p>toString 方法是Object内部实现的原型方法，实现方式中规定了某种类型的返回值</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> type = <span class="title function_">_curry1</span>(<span class="keyword">function</span> <span class="title function_">type</span>(<span class="params">val</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> val === <span class="literal">null</span></span><br><span class="line">    ? <span class="string">&#x27;Null&#x27;</span></span><br><span class="line">    : val === <span class="literal">undefined</span></span><br><span class="line">      ? <span class="string">&#x27;Undefined&#x27;</span></span><br><span class="line">      : <span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(val).<span class="title function_">slice</span>(<span class="number">8</span>, -<span class="number">1</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> type;</span><br><span class="line"></span><br></pre></td></tr></table></figure> 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Ramda/" rel="tag">Ramda</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/" rel="tag">函数式编程</a></li></ul>

    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-javascript/Ramda_List方法"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/posts/f7e795e13d0b/"
    >Ramda List 方法源码分析</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/posts/f7e795e13d0b/" class="article-date">
  <time datetime="2021-01-19T04:57:53.000Z" itemprop="datePublished">2021-01-19</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/JavaScript/">JavaScript</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h4 id="adjust"><a href="#adjust" class="headerlink" title="adjust"></a><a target="_blank" rel="noopener" href="https://ramda.cn/docs/#adjust">adjust</a></h4><p>判断索引的合法性</p>
<p>定义开始节点，其实就是抽象了计算真实索引的计算</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> adjust = <span class="title function_">_curry3</span>(<span class="keyword">function</span> <span class="title function_">adjust</span>(<span class="params">idx, fn, list</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (idx &gt;= list.<span class="property">length</span> || idx &lt; -list.<span class="property">length</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> list;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">var</span> start = idx &lt; <span class="number">0</span> ? list.<span class="property">length</span> : <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">var</span> _idx = start + idx;</span><br><span class="line">  <span class="keyword">var</span> _list = <span class="title function_">_concat</span>(list);</span><br><span class="line">  _list[_idx] = <span class="title function_">fn</span>(list[_idx]);</span><br><span class="line">  <span class="keyword">return</span> _list;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>


<h4 id="all"><a href="#all" class="headerlink" title="all"></a><a target="_blank" rel="noopener" href="https://ramda.cn/docs/#all">all</a></h4><p><a href="/posts/2b6baf0c/#dispatchable">_dispatchable</a></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> all = <span class="title function_">_curry2</span>(<span class="title function_">_dispatchable</span>([<span class="string">&#x27;all&#x27;</span>], _xall, <span class="keyword">function</span> <span class="title function_">all</span>(<span class="params">fn, list</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> idx = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (idx &lt; list.<span class="property">length</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="title function_">fn</span>(list[idx])) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    idx += <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;));</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> all;</span><br></pre></td></tr></table></figure> 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Ramda/" rel="tag">Ramda</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/" rel="tag">函数式编程</a></li></ul>

    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-algorithm/leetcode/二叉树的最小深度"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/posts/8e3fe34f62a9/"
    >LeetCode 二叉树最小/大深度</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/posts/8e3fe34f62a9/" class="article-date">
  <time datetime="2021-01-19T04:31:12.000Z" itemprop="datePublished">2021-01-19</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E7%AE%97%E6%B3%95/">算法</a> / <a class="article-category-link" href="/categories/%E7%AE%97%E6%B3%95/%E5%85%B3%E8%81%94%E9%A2%98%E7%9B%AE/">关联题目</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/minimum-depth-of-binary-tree/description/">二叉树最小深度</a></p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximum-depth-of-binary-tree/">二叉树最大深度</a></p>
<h4 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h4><p>容易想到的是通过 DFS 遍历携带深度信息，记录深度最大值或最小值。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> minDepth = <span class="keyword">function</span> (<span class="params">root</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (root === <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 记录最小深度（根节点到最近的叶子节点的距离）</span></span><br><span class="line">  <span class="keyword">let</span> minDepthValue = <span class="title class_">Infinity</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 记录当前遍历到的节点深度</span></span><br><span class="line">  <span class="keyword">let</span> currentDepth = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> traverse = <span class="keyword">function</span> (<span class="params">root</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (root === <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 前序位置进入节点时增加当前深度</span></span><br><span class="line">    currentDepth++;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果当前节点是叶子节点，更新最小深度</span></span><br><span class="line">    <span class="keyword">if</span> (root.<span class="property">left</span> === <span class="literal">null</span> &amp;&amp; root.<span class="property">right</span> === <span class="literal">null</span>) &#123;</span><br><span class="line">      minDepthValue = <span class="title class_">Math</span>.<span class="title function_">min</span>(minDepthValue, currentDepth);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">traverse</span>(root.<span class="property">left</span>);</span><br><span class="line">    <span class="title function_">traverse</span>(root.<span class="property">right</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 后序位置离开节点时减少当前深度</span></span><br><span class="line">    currentDepth--;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 从根节点开始 DFS 遍历</span></span><br><span class="line">  <span class="title function_">traverse</span>(root);</span><br><span class="line">  <span class="keyword">return</span> minDepthValue;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>也可以想到为了避免全局定义深度变量，可以把深度放到递归的参数中，下面是最大深度的解法：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">dig</span> = (<span class="params">root, length</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> length;</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Math</span>.<span class="title function_">max</span>(<span class="title function_">dig</span>(root.<span class="property">left</span>, length + <span class="number">1</span>), <span class="title function_">dig</span>(root.<span class="property">right</span>, length + <span class="number">1</span>));</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> maxDepth = <span class="keyword">function</span> (<span class="params">root</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (root === <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 由于退出条件是在叶子节点的左或右的null节点</span></span><br><span class="line">  <span class="comment">// 因此深度会被多加1, 所以开始计数从0开始，可以满足条件</span></span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">dig</span>(root, <span class="number">0</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>但是当用这种思路解决最小深度时，就会遇到问题。</p>
<p>因为是求最小深度，因此递归到叶子节点拿到的高度，是一个无效值，它可能被一个更小的值取代。</p>
<p>但是子树如果为 null,不能参与计算，<strong>因此下面的逻辑当遍历到叶子节点时，仍然递归进入空节点，导致空的子树被算作 1 的长度</strong> 返回错误的结果。</p>
<p>接下来，如果只有左子树，或者右子树，是不会进入退出逻辑的，这会导致递归无法被正确的处理，当只有其中一个子树的时候，要正确处理子树的返回值。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">dig</span> = (<span class="params">root, length</span>) =&gt; &#123;</span><br><span class="line">  <span class="comment">// 避免递归进入空节点</span></span><br><span class="line">  <span class="comment">// + if(!node.left &amp;&amp; !node.right) return deep;</span></span><br><span class="line">  <span class="comment">// - if (root == null) return length;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 当只有一个子树的时候，给空的子树一个默认值 Infinity</span></span><br><span class="line">  <span class="comment">// 因为有值的子树，一定会进入推出逻辑返回一个当前深度值</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// + let left = Infinity,right=Infinity;</span></span><br><span class="line">  <span class="comment">// + if(node.left)  left =  dfs(node.left, deep + 1);</span></span><br><span class="line">  <span class="comment">// + if(node.right) right = dfs(node.right, deep + 1);</span></span><br><span class="line">  <span class="comment">// - return Math.min(dig(root.left, length + 1), dig(root.right, length + 1));</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Math</span>.<span class="title function_">min</span>(left, right);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> maxDepth = <span class="keyword">function</span> (<span class="params">root</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (root === <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// 从 1 开始计数</span></span><br><span class="line">  <span class="comment">// + return dig(root, 1);</span></span><br><span class="line">  <span class="comment">// - return dig(root, 0);</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h4><p>观察解题思路，是通过传递一个深度参数进行递归，也就是说这是从根节点开始计数，如果从叶子节点开始计数，就可以避免参数的传递。</p>
<p>最大深度计算：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var maxDepth = <span class="keyword">function</span> (root) &#123;</span><br><span class="line">    <span class="keyword">if</span> (root === null) <span class="built_in">return</span> 0;</span><br><span class="line">    <span class="built_in">return</span> Math.max(maxDepth(root.left), maxDepth(root.right)) + 1</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>最小深度计算：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> minDepth = <span class="keyword">function</span> (<span class="params">root</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (root === <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> left = <span class="title function_">minDepth</span>(root.<span class="property">left</span>);</span><br><span class="line">  <span class="keyword">let</span> right = <span class="title function_">minDepth</span>(root.<span class="property">right</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 解决左右子树其中一个为空的情况</span></span><br><span class="line">  <span class="keyword">if</span> (left === <span class="number">0</span>) <span class="keyword">return</span> right + <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span> (right === <span class="number">0</span>) <span class="keyword">return</span> left + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Math</span>.<span class="title function_">min</span>(left, right) + <span class="number">1</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>对于最小深度，还可以考虑用 BFS 层序遍历来优化，因为最小深度，是要找到第一个叶子节点所在的深度，而不需要像 DFS 那样，每一个分支走到头才知道哪一条路径是最短的。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> minDepth = <span class="keyword">function</span> (<span class="params">root</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> deep = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> (root === <span class="literal">null</span>) <span class="keyword">return</span> deep;</span><br><span class="line">  <span class="keyword">let</span> queue = [root];</span><br><span class="line">  <span class="keyword">let</span> len;</span><br><span class="line">  <span class="keyword">while</span> ((len = queue.<span class="property">length</span>)) &#123;</span><br><span class="line">    deep++;</span><br><span class="line">    <span class="keyword">const</span> q = queue.<span class="title function_">concat</span>([]);</span><br><span class="line">    queue = [];</span><br><span class="line">    <span class="keyword">while</span> (len--) &#123;</span><br><span class="line">      <span class="keyword">const</span> node = q.<span class="title function_">pop</span>();</span><br><span class="line">      <span class="keyword">if</span> (node.<span class="property">left</span> === <span class="literal">null</span> &amp;&amp; node.<span class="property">right</span> === <span class="literal">null</span>) <span class="keyword">return</span> deep;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (node.<span class="property">right</span>) queue.<span class="title function_">push</span>(node.<span class="property">right</span>);</span><br><span class="line">      <span class="keyword">if</span> (node.<span class="property">left</span>) queue.<span class="title function_">push</span>(node.<span class="property">left</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> deep;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%85%B3%E8%81%94%E9%A2%98%E7%9B%AE/" rel="tag">关联题目</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%AE%97%E6%B3%95/" rel="tag">算法</a></li></ul>

    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-algorithm/learn/二叉树"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/posts/6477f25bd014/"
    >二叉树</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/posts/6477f25bd014/" class="article-date">
  <time datetime="2021-01-19T03:09:56.000Z" itemprop="datePublished">2021-01-19</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E7%AE%97%E6%B3%95/">算法</a> / <a class="article-category-link" href="/categories/%E7%AE%97%E6%B3%95/%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E5%AD%A6/">常见算法与数学</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p>二叉树可以算是最基础的数据类型。</p>
<p>很多复杂的数据结构都是基于二叉树的，比如 红黑树（二叉搜索树）、多叉树、二叉堆、图、字典树、并查集、s 线段树 等等。</p>
<p>二叉树可以代表一种递归的思维方式,比如 回溯算法、BFS 算法、动态规划 本质上也是把具体问题抽象成树结构。</p>
<h4 id="树的概念"><a href="#树的概念" class="headerlink" title="树的概念"></a>树的概念</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">    1</span><br><span class="line">   / \</span><br><span class="line">  2   3</span><br><span class="line"> /   / \</span><br><span class="line">4   5   6</span><br><span class="line">   /     \</span><br><span class="line">  7       8</span><br></pre></td></tr></table></figure>

<ul>
<li><p>每个节点下方直接相连的节点称为<strong>子节点</strong>，上方直接相连的节点称为<strong>父节点</strong>。比方说节点 3 的父节点是 1，左子节点是 5，右子节点是 6；节点 5 的父节点是 3，左子节点是 7，没有右子节点。</p>
</li>
<li><p>我们称最上方那个没有父节点的节点 1 为<strong>根节点</strong>，称最下层没有子节点的节点 4、7、8 为<strong>叶子节点</strong>。</p>
</li>
<li><p>从根节点到最下方叶子节点经过的节点个数为二叉树的<strong>最大深度&#x2F;高度</strong>，上面这棵树的最大深度是 4，即从根节点 1 到叶子节点 7 或 8 的路径上的节点个数。</p>
</li>
<li><p>满二叉树: 每一层节点都是满的, 假设深度为 h，那么总节点数就是 <code>2^h - 1</code>。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">       1</span><br><span class="line">     /   \</span><br><span class="line">    2     3</span><br><span class="line">   / \   / \</span><br><span class="line">  4   9 5   6</span><br><span class="line"> / \ / \/ \ / \</span><br><span class="line">10 11 7 12 13 8 14</span><br></pre></td></tr></table></figure>
</li>
<li><p>完全二叉树： 二叉树的每一层的节点都紧凑靠左排列，且除了最后一层，其他每层都必须是满的, 满二叉树就是特殊的完全二叉树。也可以说 <strong>完全二叉树的左右子树也是完全二叉树。</strong> 或 <strong>完全二叉树的左右子树中，至少有一棵是满二叉树。</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">       1</span><br><span class="line">     /   \</span><br><span class="line">    2     3</span><br><span class="line">   / \   / \</span><br><span class="line">  4   9 5   6</span><br><span class="line"> / \ / \</span><br><span class="line">10 1 7 2</span><br></pre></td></tr></table></figure>
</li>
<li><p>二叉搜索树：对于树中的每个节点，其<strong>左子树的每个节点</strong>的值都要小于这个节点的值，<strong>右子树的每个节点</strong>的值都要大于这个节点的值。为左小右大的特性，可以让我们在 BST 中快速找到某个节点，或者找到某个范围内的所有节点，这是 BST 的优势所在。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    7</span><br><span class="line">   / \</span><br><span class="line">  4   9</span><br><span class="line"> / \   \</span><br><span class="line">1   8   10</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="遍历方式"><a href="#遍历方式" class="headerlink" title="遍历方式"></a>遍历方式</h4><h5 id="层序遍历"><a href="#层序遍历" class="headerlink" title="层序遍历"></a>层序遍历</h5><p>一层一层地遍历二叉树,显然先访问的节点需要先处理，而左右节点暂时用不到需要先存起来，自然想到用队列来处理。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> levelOrderTraverse = <span class="keyword">function</span> (<span class="params">root</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (root === <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">var</span> q = [];</span><br><span class="line">  q.<span class="title function_">push</span>(root);</span><br><span class="line">  <span class="keyword">while</span> (q.<span class="property">length</span> !== <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> cur = q.<span class="title function_">shift</span>();</span><br><span class="line">    <span class="comment">// 访问 cur 节点</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(cur.<span class="property">val</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 把 cur 的左右子节点加入队列</span></span><br><span class="line">    <span class="keyword">if</span> (cur.<span class="property">left</span> !== <span class="literal">null</span>) &#123;</span><br><span class="line">      q.<span class="title function_">push</span>(cur.<span class="property">left</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (cur.<span class="property">right</span> !== <span class="literal">null</span>) &#123;</span><br><span class="line">      q.<span class="title function_">push</span>(cur.<span class="property">right</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这种方式存在的问题就是不知道是第几层，因此可以使用额外的变量来记录。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> levelOrderTraverse = <span class="keyword">function</span> (<span class="params">root</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (root === <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> q = [];</span><br><span class="line">  q.<span class="title function_">push</span>(root);</span><br><span class="line">  <span class="comment">// 记录当前遍历到的层数（根节点视为第 1 层）</span></span><br><span class="line">  <span class="keyword">let</span> depth = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (q.<span class="property">length</span> !== <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> sz = q.<span class="property">length</span>;</span><br><span class="line">    <span class="comment">// 使用额外的变量，记录每层的节点个数</span></span><br><span class="line">    <span class="comment">// 也可以直接复制q队列，这样可以避免 shift 操作的O(n) 时间复杂度</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; sz; i++) &#123;</span><br><span class="line">      <span class="keyword">let</span> cur = q.<span class="title function_">shift</span>();</span><br><span class="line">      <span class="comment">// 访问 cur 节点，同时知道它所在的层数</span></span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;depth = &quot;</span> + depth + <span class="string">&quot;, val = &quot;</span> + cur.<span class="property">val</span>);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 把 cur 的左右子节点加入队列</span></span><br><span class="line">      <span class="keyword">if</span> (cur.<span class="property">left</span> !== <span class="literal">null</span>) &#123;</span><br><span class="line">        q.<span class="title function_">push</span>(cur.<span class="property">left</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (cur.<span class="property">right</span> !== <span class="literal">null</span>) &#123;</span><br><span class="line">        q.<span class="title function_">push</span>(cur.<span class="property">right</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    depth++;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>同理还可以添加更多的下信息，现在只知道整个树的层数，还可以为每个节点维护他的层数, 一般称作<strong>路径的权重</strong>，即从根节点到当前的节点。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">State</span>(<span class="params">node, depth</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">node</span> = node;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">depth</span> = depth;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> levelOrderTraverse = <span class="keyword">function</span> (<span class="params">root</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (root === <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// @visualize bfs</span></span><br><span class="line">  <span class="keyword">var</span> q = [];</span><br><span class="line">  <span class="comment">// 根节点的路径权重和是 1</span></span><br><span class="line">  q.<span class="title function_">push</span>(<span class="keyword">new</span> <span class="title class_">State</span>(root, <span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (q.<span class="property">length</span> !== <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> cur = q.<span class="title function_">shift</span>();</span><br><span class="line">    <span class="comment">// 访问 cur 节点，同时知道它的路径权重和</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;depth = &quot;</span> + cur.<span class="property">depth</span> + <span class="string">&quot;, val = &quot;</span> + cur.<span class="property">node</span>.<span class="property">val</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 把 cur 的左右子节点加入队列</span></span><br><span class="line">    <span class="keyword">if</span> (cur.<span class="property">node</span>.<span class="property">left</span> !== <span class="literal">null</span>) &#123;</span><br><span class="line">      q.<span class="title function_">push</span>(<span class="keyword">new</span> <span class="title class_">State</span>(cur.<span class="property">node</span>.<span class="property">left</span>, cur.<span class="property">depth</span> + <span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (cur.<span class="property">node</span>.<span class="property">right</span> !== <span class="literal">null</span>) &#123;</span><br><span class="line">      q.<span class="title function_">push</span>(<span class="keyword">new</span> <span class="title class_">State</span>(cur.<span class="property">node</span>.<span class="property">right</span>, cur.<span class="property">depth</span> + <span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="递归遍历"><a href="#递归遍历" class="headerlink" title="递归遍历"></a>递归遍历</h5><p>先深入到一个分支中，在逐层的返回。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 二叉树的遍历框架</span></span><br><span class="line"><span class="keyword">var</span> traverse = <span class="keyword">function</span> (<span class="params">root</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (root === <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 前序位置</span></span><br><span class="line">  <span class="title function_">traverse</span>(root.<span class="property">left</span>);</span><br><span class="line">  <span class="comment">// 中序位置</span></span><br><span class="line">  <span class="title function_">traverse</span>(root.<span class="property">right</span>);</span><br><span class="line">  <span class="comment">// 后序位置</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>但是在不同的位置写代码，获取到的信息是不同的，所谓的前中后，是相对于根节点的先后。</p>
<ul>
<li><p>前序遍历： 根节点 &#x3D;&gt; 左节点 &#x3D;&gt; 右节点， 代码位置写在接入左树之前，因此先访问根节点，在访问左树的根节点。对于一个子树，只有左子树遍历完成后，才回去处理右子树，可以看作是进入一个二叉树节点的时候执行</p>
</li>
<li><p>中序遍历： 左节点 &#x3D;&gt; 根节点 &#x3D;&gt; 右节点，代码会一直递归调用到左子树的左叶子节点，当左叶子节点访问完毕后，会弹出当前的调用栈，而上一个调用栈正是左节点的父节点，也就是根节点,可以看作是二叉树节点左子树都遍历完，即将开始遍历右子树的时候执行。</p>
</li>
<li><p>后序遍历： 左节点 &#x3D;&gt; 右节点 &#x3D;&gt; 根节点，代码会一直递归调用到左子树的右叶子节点，当左右子节点访问完毕后，会弹出当前的调用栈，而上一个调用栈正是右节点的父节点，也就是根节点,可以看作是离开一个二叉树节点的时候执行。</p>
</li>
</ul>
<p>而递归遍历常用于寻找最短路径， <a href="/posts/8e3fe34f62a9/"><strong>[二叉树最小&#x2F;大深度]</strong></a>, <a href="/posts/6a338e4e2cab/"><strong>[二叉树直径]</strong></a>,递归和遍历各有优势，遍历的思想是配合外部变量，递归则是将问题分解为子问题。</p>
<p>有一些问题虽然是在二叉树的遍历模型下，但是需要根据条件进入不同的分支处理，并在其中穿插其他的逻辑代码。 <a href="/posts/13ae1e52470a/"><strong>[二叉树展开为链表]</strong></a> <a href="/posts/0d16fafcd38e/"><strong>[填充每个节点的下一个右侧节点指针]</strong></a></p>
<h4 id="二叉树的序列化"><a href="#二叉树的序列化" class="headerlink" title="二叉树的序列化"></a>二叉树的序列化</h4><h5 id="层序遍历-1"><a href="#层序遍历-1" class="headerlink" title="层序遍历"></a>层序遍历</h5><p>这应该是最容易想到的一种方法，就像 LeetCode 题目给出的可视化数据一样，将每一层的数据依次放入到数组中，就可以对二叉树序列化，但是需要注意的是要保留空节点，这样才能描述每一层节点之间的关系</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> serialize = <span class="keyword">function</span> (<span class="params">root</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (root === <span class="literal">null</span>) <span class="keyword">return</span> [];</span><br><span class="line">  <span class="keyword">const</span> queue = [root];</span><br><span class="line">  <span class="keyword">const</span> res = [];</span><br><span class="line">  <span class="keyword">while</span> (queue.<span class="property">length</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> first = queue.<span class="title function_">shift</span>();</span><br><span class="line">    res.<span class="title function_">push</span>(first === <span class="literal">null</span> ? first : first.<span class="property">val</span>);</span><br><span class="line">    <span class="keyword">if</span> (first !== <span class="literal">null</span>) queue.<span class="title function_">push</span>(first.<span class="property">left</span>, first.<span class="property">right</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> deserialize = <span class="keyword">function</span> (<span class="params">data</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (data.<span class="property">length</span> === <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">let</span> index = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> root = <span class="keyword">new</span> <span class="title class_">TreeNode</span>(data[index++]);</span><br><span class="line">  <span class="keyword">let</span> queue = [root];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (data[index] !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> node = queue.<span class="title function_">shift</span>();</span><br><span class="line">    <span class="keyword">const</span> left = data[index++];</span><br><span class="line">    <span class="keyword">const</span> right = data[index++];</span><br><span class="line"></span><br><span class="line">    node.<span class="property">left</span> = left === <span class="literal">null</span> ? left : <span class="keyword">new</span> <span class="title class_">TreeNode</span>(left);</span><br><span class="line">    node.<span class="property">right</span> = right === <span class="literal">null</span> ? right : <span class="keyword">new</span> <span class="title class_">TreeNode</span>(right);</span><br><span class="line">    <span class="keyword">if</span> (left !== <span class="literal">null</span>) queue.<span class="title function_">push</span>(node.<span class="property">left</span>);</span><br><span class="line">    <span class="keyword">if</span> (right !== <span class="literal">null</span>) queue.<span class="title function_">push</span>(node.<span class="property">right</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> root;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="二叉树的唯一性"><a href="#二叉树的唯一性" class="headerlink" title="二叉树的唯一性"></a>二叉树的唯一性</h5> 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/" rel="tag">二叉树</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%AE%97%E6%B3%95/" rel="tag">算法</a></li></ul>

    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-devops/调试npm包"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/posts/61c0760886e4/"
    >调试npm包</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/posts/61c0760886e4/" class="article-date">
  <time datetime="2021-01-16T14:16:47.000Z" itemprop="datePublished">2021-01-16</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/DevOps/">DevOps</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h4 id="npm-x2F-yarn-link"><a href="#npm-x2F-yarn-link" class="headerlink" title="npm&#x2F;yarn link"></a>npm&#x2F;yarn link</h4><p>通过软链接使用第三方包</p>
<p>进入本地npm包文件夹，或通过 <code>git clone</code>拉去的第三方包文件夹 </p>
<p>执行 <code>yarn link</code> 或 <code>npm link</code> 连接到全局（yarn 不会污染全局）</p>
<p>在项目中使用 <code>yarn link [第三方包]</code>  或 <code>npm link [第三方包]</code></p>
<p>在项目中通过 <code>yarn unlink [第三方包]</code> 或 <code>npm unlink [第三方包]</code> 解除链接</p>
<p>通过一下命令去掉全局安装的包 </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm rm --<span class="variable language_">global</span> foo </span><br><span class="line">npm ls --<span class="variable language_">global</span> foo <span class="comment">// 检查包是否被安装</span></span><br></pre></td></tr></table></figure>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/DevOps/" rel="tag">DevOps</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/npm/" rel="tag">npm</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%B7%A5%E7%A8%8B%E5%8C%96/" rel="tag">工程化</a></li></ul>

    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-webpack/webpack核心概念"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/posts/dce700bcd907/"
    >webpack核心概念</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/posts/dce700bcd907/" class="article-date">
  <time datetime="2021-01-16T13:32:37.000Z" itemprop="datePublished">2021-01-16</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/webpack/">webpack</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><p>推荐就近安装，即安装在项目中，不要安装在全局中</p>
<p>通过 <code>npx webpack -v</code> 查看项目中 webpack 版本</p>
<p><strong>nrm 镜像源管理</strong></p>
<p><code>yarn add nrm</code></p>
<p>查看镜像源列表</p>
<p><code>nrm ls</code></p>
<p>测速</p>
<p><code>nrm test taobao</code></p>
<h4 id="常用工具"><a href="#常用工具" class="headerlink" title="常用工具"></a>常用工具</h4><h5 id="clean-webpack-plugin"><a href="#clean-webpack-plugin" class="headerlink" title="clean-webpack-plugin"></a>clean-webpack-plugin</h5><p><a target="_blank" rel="noopener" href="https://www.npmjs.com/package/clean-webpack-plugin">https://www.npmjs.com/package/clean-webpack-plugin</a></p>
<h4 id="source-map"><a href="#source-map" class="headerlink" title="source-map"></a>source-map</h4><p>cheap-module-source-map 用于生产环境，不能暴露源码</p>
<p>eval-cheap-module-source-map 开发环境中使用</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">devtool</span>:<span class="string">&#x27;cheap-module-source-map&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="devServer-和热模块更新"><a href="#devServer-和热模块更新" class="headerlink" title="devServer 和热模块更新"></a>devServer 和热模块更新</h4><p>安装devServer</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn add -D webpack-dev-server</span><br></pre></td></tr></table></figure>

<p>webpack.config.js 中添加配置项  </p>
<p>contentBase 只有需要在访问静态文件时候使用，默认下面三个配置项都可以不写</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">devServer</span>: &#123;</span><br><span class="line">  <span class="attr">contentBase</span>: path.<span class="title function_">join</span>(__dirname, <span class="string">&#x27;dist&#x27;</span>),</span><br><span class="line">  <span class="attr">compress</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">port</span>: <span class="number">9000</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>package.json 中添加启动命令</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;scripts&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;server&quot;</span><span class="punctuation">:</span> <span class="string">&quot;webpack-dev-server --open&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>开启hmr</p>
<p>1.配置webpack-dev-server<br>2.devServer配置hot:true<br>3.plugins hotModuleeReplaceMentPlugin<br>4.js 文件中添加hmr代码</p>
<p>webpack.config.js 中添加</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> webpack = <span class="built_in">require</span>(<span class="string">&#x27;webpack&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="attr">devServer</span>: &#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="attr">hot</span>:<span class="literal">true</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">plugins</span>: [</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">new</span> webpack.<span class="title class_">NamedModulesPlugin</span>(),</span><br><span class="line">    <span class="keyword">new</span> webpack.<span class="title class_">HotModuleReplacementPlugin</span>()</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>index.js 增加代码</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="variable language_">module</span>.<span class="property">hot</span>) &#123;</span><br><span class="line">  <span class="variable language_">module</span>.<span class="property">hot</span>.<span class="title function_">accept</span>(<span class="string">&#x27;./print.js&#x27;</span>, <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Accepting the updated printMe module!&#x27;</span>);</span><br><span class="line">   <span class="title function_">printMe</span>();</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="entry"><a href="#entry" class="headerlink" title="entry"></a>entry</h4><p><strong>string</strong> : 所有的资源打包成一个chunk,输出一个<code>bundle</code>文件，默认的名称是<code>main.js</code></p>
<p><strong>array</strong>: 多入口，所有的文件也只会被打包成一个<code>chunk</code>,通常只在配置html的HMR时使用</p>
<p><strong>object</strong> 多入口，有几个入口文件就可以形成几个<code>chunk</code>,输出几个<code>bundle</code>文件，文件的名称时对象中的<code>key</code>，每个key后面可以写一个数组，可以将数组中的文件打包成一个<code>bundle</code>,(参照dll的用法)</p>
<h4 id="output"><a href="#output" class="headerlink" title="output"></a>output</h4><p><strong>filename</strong> 输出的文件名称，可以指定目录和文件名 <code>js/[name].js</code></p>
<p><strong>publicpath</strong> 所有资源引入时候的公共路径，会拼在资源路径的前面作为基础路径， <code>publicpath:/</code>,<code>img/a.png</code> &#x3D;&gt; <code>/img/a.png</code>, <strong>注意：不是资源的输出路径</strong></p>
<p><strong>chunkFilename</strong> 非入口<code>chunk</code>的名称，通过动态<code>import</code>引入的文件名称通过id的形式命名，从0开始，依次递增，<strong>通常会使用<a target="_blank" rel="noopener" href="https://webpack.js.org/migrate/5/#using--webpackchunkname--">webpackchunkname</a>来重命名</strong></p>
<p><strong>library</strong> 会将<code>chunk</code>文件用一个变量接受，暴露给全局使用</p>
<p><strong>libraryTarget</strong> 指明以那种方式引入,<code>window</code>把输入的变量添加到浏览器全局环境<code>window[name]=xxx</code>, <code>global</code>把输入的变量添加到node全局环境<code>global[name]=xxx</code>,<code>commonjs</code>以commonjs模块化规范引入，通常配合<code>dll</code>使用 </p>
<p><strong>与 devserver 中的 publicpath 区别</strong></p>
<p><a target="_blank" rel="noopener" href="https://webpack.js.org/configuration/output/#outputpublicpath">output 中的 publicpath</a></p>
<p>这是一个在使用按需加载和引入外部资源（图片,文件等）非常重要的属性，如果设置了一个错误的值，当加载这些资源时会报404错误</p>
<p>这个配置项指定了输出目录在浏览器中引用时的公共路径（publicpath）,一个相对路径被解析为相对于HTML页面或<a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/HTML/Element/base">&lt;base&gt;标签</a></p>
<blockquote>
<base> 标签为页面上的所有链接规定默认地址或默认目标。
</blockquote>
<p>相对服务器的路径，相对与协议的路径，或绝对路径都是有可能的甚至有时是必须的，换句话说，在CDN 托管静态资源</p>
<p>在运行时或loader处理时，每一个URL的前缀都会被色设置配置项中的值，这就是为什么在很多例子中这个配置项被设置为 <code>/</code> 的原因</p>
<p>webpack-dev-server 也需要从publicPath获取信息，使用它来确定从何处提供输出文件。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  <span class="attr">output</span>: &#123;</span><br><span class="line">    <span class="comment">// One of the below</span></span><br><span class="line">    <span class="attr">publicPath</span>: <span class="string">&#x27;https://cdn.example.com/assets/&#x27;</span>, <span class="comment">// CDN (always HTTPS)</span></span><br><span class="line">    <span class="attr">publicPath</span>: <span class="string">&#x27;//cdn.example.com/assets/&#x27;</span>, <span class="comment">// CDN (same protocol)</span></span><br><span class="line">    <span class="attr">publicPath</span>: <span class="string">&#x27;/assets/&#x27;</span>, <span class="comment">// server-relative</span></span><br><span class="line">    <span class="attr">publicPath</span>: <span class="string">&#x27;assets/&#x27;</span>, <span class="comment">// relative to HTML page</span></span><br><span class="line">    <span class="attr">publicPath</span>: <span class="string">&#x27;../assets/&#x27;</span>, <span class="comment">// relative to HTML page</span></span><br><span class="line">    <span class="attr">publicPath</span>: <span class="string">&#x27;&#x27;</span>, <span class="comment">// relative to HTML page (same directory)</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://webpack.js.org/configuration/dev-server/#devserverpublicpath-">devServer 中的 publicpath</a></p>
<p>打包的文件可以在浏览器的这个目录下面得到</p>
<p>如果服务跑在 <a href="http://localhost:8080，打包的文件为bundle.js，publicPath为">http://localhost:8080，打包的文件为bundle.js，publicPath为</a> <code>/</code>, 可以在 <code>http://localhost:8080/bundle.js</code>访问到打包文件</p>
<p>如果 publicPath 改为 <code>/assets/</code>, 那么可以在 <code>http://localhost:8080/assets/bundle.js</code>访问，也可以把 publicPath 改为 <code>http://localhost:8080/assets/</code></p>
<p>这说明了 devServer.publicPath 与 output.publicPath 是一致的</p>
<h5 id="babel-x2F-polyfill-babel-x2F-plugin-transform-runtime-babel-x2F-runtime-corejs2"><a href="#babel-x2F-polyfill-babel-x2F-plugin-transform-runtime-babel-x2F-runtime-corejs2" class="headerlink" title="@babel&#x2F;polyfill  @babel&#x2F;plugin-transform-runtime @babel&#x2F;runtime-corejs2"></a>@babel&#x2F;polyfill  @babel&#x2F;plugin-transform-runtime @babel&#x2F;runtime-corejs2</h5><p>@babel&#x2F;preset-env 只会转换新语法，但是不会转换新的api,比如 <code>Array.from</code></p>
<p>需要 @babel&#x2F;polyfill 转换新的api,但是 @babel&#x2F;polyfill 会全量引入，不能按需引入</p>
<p>可以通过 <code>babel.rc</code> 配置文件来实现 </p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;presets&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">[</span></span><br><span class="line">      <span class="string">&quot;@babel/preset-env&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="comment">// This option was removed in v7 by just making it the default.在新版本中已经移除，无需添加</span></span><br><span class="line">      <span class="comment">// &#123;</span></span><br><span class="line">      <span class="comment">//   &quot;useBuiltIns&quot;: &quot;usage&quot;</span></span><br><span class="line">      <span class="comment">// &#125;</span></span><br><span class="line">    <span class="punctuation">]</span></span><br><span class="line">  <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>但是@babel&#x2F;preset-env也存在问题，虽然会按需引入但是每个文件如果有重复的方法，都会被编译成相同的代码引入，文件多的时候会让冗余的代码越来越多</p>
<p>@babel&#x2F;runtime-corejs2 是一个随着 <a target="_blank" rel="noopener" href="https://babeljs.io/docs/en/babel-plugin-transform-runtime">@babel&#x2F;plugin-transform-runtime</a> 一起时使用的运行时依赖，会把重复的函数覆盖为 @babel&#x2F;runtime-corejs2 中的引用</p>
<p>@babel&#x2F;runtime-corejs2 仅仅是一个包含着函数的包，把函数以模块化的形式引入, <strong>要安装到生产依赖中</strong></p>
<p>.babelrc</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;plugins&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">[</span></span><br><span class="line">      <span class="string">&quot;@babel/plugin-transform-runtime&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;corejs&quot;</span><span class="punctuation">:</span> <span class="number">3</span></span><br><span class="line">      <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">]</span></span><br><span class="line">  <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>


<h4 id="treeshaking"><a href="#treeshaking" class="headerlink" title="treeshaking"></a>treeshaking</h4><p>webpack4 production 默认开启，需要引入的库使用commonjs 模块化规范</p>
<p>如 loadsh-es</p>
<h4 id="全局引入"><a href="#全局引入" class="headerlink" title="全局引入"></a>全局引入</h4><p><a target="_blank" rel="noopener" href="https://webpack.js.org/plugins/provide-plugin/#root">provide-plugin</a></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">plugins</span>: [</span><br><span class="line">  <span class="keyword">new</span> webpack.<span class="title class_">ProvidePlugin</span>(&#123;</span><br><span class="line">    <span class="attr">$</span>: <span class="string">&#x27;jquery&#x27;</span>,</span><br><span class="line">  &#125;)</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>多入口文件的每一个都会被引入jquery，所以需要提取公共代码</p>
<h4 id="动态加载"><a href="#动态加载" class="headerlink" title="动态加载"></a>动态加载</h4><p><a target="_blank" rel="noopener" href="https://babeljs.io/docs/en/babel-plugin-syntax-dynamic-import">@babel&#x2F;plugin-syntax-dynamic-import</a></p>
<p><a target="_blank" rel="noopener" href="https://webpack.js.org/guides/code-splitting/#dynamic-imports">Dynamic Imports</a></p>
<p><strong>需要指明webpackChunkName才能被单独打包</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">import</span>(</span><br><span class="line">   <span class="comment">/* webpackChunkName: &quot;my-jquery&quot; */</span></span><br><span class="line">   <span class="string">&#x27;jquery&#x27;</span></span><br><span class="line"> )</span><br><span class="line">   .<span class="title function_">then</span>(<span class="function">(<span class="params">&#123; <span class="keyword">default</span>: $ &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">     <span class="variable language_">console</span>.<span class="title function_">log</span>($)</span><br><span class="line">     <span class="keyword">return</span> $(<span class="string">&#x27;body&#x27;</span>);</span><br><span class="line">   &#125;)</span><br></pre></td></tr></table></figure>

<h4 id="代码分割"><a href="#代码分割" class="headerlink" title="代码分割"></a>代码分割</h4><p><a target="_blank" rel="noopener" href="https://webpack.js.org/plugins/split-chunks-plugin/#root">SplitChunksPlugin</a> 代替原来的 commonChunksPlugin</p>
<ul>
<li>splitChunks.chunks</li>
</ul>
<p>async表示只从异步加载得模块（动态加载import()）里面进行拆分<br>initial表示只从入口模块进行拆分<br>all表示以上两者都包括</p>
<ul>
<li>splitChunks.maxInitialRequests</li>
</ul>
<p>每个入口的并发请求数, 如果拆出的包的个数大于maxInitialRequests，则不会把较小的包单独拆出</p>
<ul>
<li>splitChunks.maxInitialRequests</li>
</ul>
<p>动态引入的模块，最多拆分的数量</p>
<h4 id="css分割"><a href="#css分割" class="headerlink" title="css分割"></a>css分割</h4><p><a target="_blank" rel="noopener" href="https://webpack.js.org/plugins/css-minimizer-webpack-plugin/">css-minimizer-webpack-plugin</a></p>
<h4 id="压缩css代码"><a href="#压缩css代码" class="headerlink" title="压缩css代码"></a>压缩css代码</h4><p><a target="_blank" rel="noopener" href="https://webpack.js.org/plugins/mini-css-extract-plugin/#getting-started">MiniCssExtractPlugin</a></p>
<h4 id="可视化分析"><a href="#可视化分析" class="headerlink" title="可视化分析"></a>可视化分析</h4><p><a target="_blank" rel="noopener" href="https://www.npmjs.com/package/webpack-bundle-analyzer">webpack-bundle-analyzer</a></p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/webpack/" rel="tag">webpack</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%B7%A5%E7%A8%8B%E5%8C%96/" rel="tag">工程化</a></li></ul>

    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-javascript/Ramda_Objec方法"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/posts/f021f8110e5a/"
    >Ramda Object方法源码分析</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/posts/f021f8110e5a/" class="article-date">
  <time datetime="2021-01-16T09:15:23.000Z" itemprop="datePublished">2021-01-16</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/JavaScript/">JavaScript</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h4 id="keys"><a href="#keys" class="headerlink" title="keys"></a>keys</h4><p>Safari 可能存在 argument.length 可枚举的bug</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> hasArgsEnumBug = (<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="string">&#x27;use strict&#x27;</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="variable language_">arguments</span>.<span class="title function_">propertyIsEnumerable</span>(<span class="string">&#x27;length&#x27;</span>);</span><br><span class="line">&#125;());</span><br></pre></td></tr></table></figure>

<p>IE9一下<code>toString</code>方法存在可以枚举的bug</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// cover IE &lt; 9 keys issues</span></span><br><span class="line"><span class="keyword">var</span> hasEnumBug = !(&#123;<span class="attr">toString</span>: <span class="literal">null</span>&#125;).<span class="title function_">propertyIsEnumerable</span>(<span class="string">&#x27;toString&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> nonEnumerableProps = [</span><br><span class="line">  <span class="string">&#x27;constructor&#x27;</span>, <span class="string">&#x27;valueOf&#x27;</span>, <span class="string">&#x27;isPrototypeOf&#x27;</span>, <span class="string">&#x27;toString&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;propertyIsEnumerable&#x27;</span>, <span class="string">&#x27;hasOwnProperty&#x27;</span>, <span class="string">&#x27;toLocaleString&#x27;</span></span><br><span class="line">];</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果有原生 Object.keys 实现且Safari不存在bug</span></span><br><span class="line"><span class="keyword">var</span> keys = <span class="keyword">typeof</span> <span class="title class_">Object</span>.<span class="property">keys</span> === <span class="string">&#x27;function&#x27;</span> &amp;&amp; !hasArgsEnumBug ?</span><br><span class="line">  <span class="title function_">_curry1</span>(<span class="keyword">function</span> <span class="title function_">keys</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">    <span class="comment">// 参数错误处理</span></span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Object</span>(obj) !== obj ? [] : <span class="title class_">Object</span>.<span class="title function_">keys</span>(obj);</span><br><span class="line">  &#125;) :</span><br><span class="line">  <span class="title function_">_curry1</span>(<span class="keyword">function</span> <span class="title function_">keys</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="title class_">Object</span>(obj) !== obj) &#123;</span><br><span class="line">      <span class="keyword">return</span> [];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> prop, nIdx;</span><br><span class="line">    <span class="keyword">var</span> ks = [];</span><br><span class="line">    <span class="comment">// 如果传入的对象时argument，而且有bug</span></span><br><span class="line">    <span class="keyword">var</span> checkArgsLength = hasArgsEnumBug &amp;&amp; <span class="title function_">_isArguments</span>(obj);</span><br><span class="line">    <span class="comment">// 循环对象每一项检查</span></span><br><span class="line">    <span class="keyword">for</span> (prop <span class="keyword">in</span> obj) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="title function_">_has</span>(prop, obj) &amp;&amp; (!checkArgsLength || prop !== <span class="string">&#x27;length&#x27;</span>)) &#123;</span><br><span class="line">        ks[ks.<span class="property">length</span>] = prop;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果有toString可枚举的bug</span></span><br><span class="line">    <span class="keyword">if</span> (hasEnumBug) &#123;</span><br><span class="line">      nIdx = nonEnumerableProps.<span class="property">length</span> - <span class="number">1</span>;</span><br><span class="line">      <span class="comment">// 排除不可枚举的属性</span></span><br><span class="line">      <span class="keyword">while</span> (nIdx &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        prop = nonEnumerableProps[nIdx];</span><br><span class="line">        <span class="keyword">if</span> (<span class="title function_">_has</span>(prop, obj) &amp;&amp; !<span class="title function_">contains</span>(ks, prop)) &#123;</span><br><span class="line">          ks[ks.<span class="property">length</span>] = prop;</span><br><span class="line">        &#125;</span><br><span class="line">        nIdx -= <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ks;</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure> 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Ramda/" rel="tag">Ramda</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/" rel="tag">函数式编程</a></li></ul>

    </footer>
  </div>

   
    
</article>

    
  </article>
  

  
  <nav class="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/17/">上一页</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/16/">16</a><a class="page-number" href="/page/17/">17</a><span class="page-number current">18</span><a class="page-number" href="/page/19/">19</a><a class="page-number" href="/page/20/">20</a><span class="space">&hellip;</span><a class="page-number" href="/page/28/">28</a><a class="extend next" rel="next" href="/page/19/">下一页</a>
  </nav>
  
</section>
</div>

      <footer class="footer">
  <div class="outer">
    <ul>
      <li>
        Copyrights &copy;
        2015-2025
        <i class="ri-heart-fill heart_icon"></i> SunZhiqi
      </li>
    </ul>
    <ul>
      <li>
        
      </li>
    </ul>
    <ul>
      <li>
        
      </li>
    </ul>
    <ul>
      
    </ul>
    <ul>
      
    </ul>
    <ul>
      <li>
        <!-- cnzz统计 -->
        
      </li>
    </ul>
  </div>
</footer>    
    </main>
    <div class="float_btns">
      <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>

    </div>
    <aside class="sidebar on">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/ayer-side.png" alt="四月八日"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">归档</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories">分类</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags">标签</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="搜索">
        <i class="ri-search-line"></i>
      </a>
      
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>此时无声胜有声！</p>
  <div class="reward-box">
    
    <div class="reward-item">
      <img class="reward-img" src="/images/alipay.jpg">
      <span class="reward-type">支付宝</span>
    </div>
    
    
    <div class="reward-item">
      <img class="reward-img" src="/images/wechat.jpg">
      <span class="reward-type">微信</span>
    </div>
    
  </div>
</div>
    
<script src="/js/jquery-3.6.0.min.js"></script>
 
<script src="/js/lazyload.min.js"></script>

<!-- Tocbot -->

<script src="/js/jquery.modal.min.js"></script>
<link rel="stylesheet" href="/css/jquery.modal.min.css" />
<script src="/js/jquery.justifiedGallery.min.js"></script>

<script src="/dist/main.js"></script>

<!-- ImageViewer -->
 <!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">
  <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
  <div class="pswp__bg"></div>

  <!-- Slides wrapper with overflow:hidden. -->
  <div class="pswp__scroll-wrap">
    <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
    <div class="pswp__container">
      <div class="pswp__item"></div>
      <div class="pswp__item"></div>
      <div class="pswp__item"></div>
    </div>

    <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
    <div class="pswp__ui pswp__ui--hidden">
      <div class="pswp__top-bar">
        <!--  Controls are self-explanatory. Order can be changed. -->

        <div class="pswp__counter"></div>

        <button
          class="pswp__button pswp__button--close"
          title="Close (Esc)"
        ></button>

        <button
          class="pswp__button pswp__button--share"
          style="display: none"
          title="Share"
        ></button>

        <button
          class="pswp__button pswp__button--fs"
          title="Toggle fullscreen"
        ></button>

        <button
          class="pswp__button pswp__button--zoom"
          title="Zoom in/out"
        ></button>

        <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
        <!-- element will get class pswp__preloader--active when preloader is running -->
        <div class="pswp__preloader">
          <div class="pswp__preloader__icn">
            <div class="pswp__preloader__cut">
              <div class="pswp__preloader__donut"></div>
            </div>
          </div>
        </div>
      </div>

      <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
        <div class="pswp__share-tooltip"></div>
      </div>

      <button
        class="pswp__button pswp__button--arrow--left"
        title="Previous (arrow left)"
      ></button>

      <button
        class="pswp__button pswp__button--arrow--right"
        title="Next (arrow right)"
      ></button>

      <div class="pswp__caption">
        <div class="pswp__caption__center"></div>
      </div>
    </div>
  </div>
</div>

<link rel="stylesheet" href="/css/photoswipe.min.css" />
<link rel="stylesheet" href="/css/default-skin.min.css" />
<script src="/js/photoswipe.min.js"></script>
<script src="/js/photoswipe-ui-default.min.js"></script>

<script>
  function viewer_init() {
    let pswpElement = document.querySelectorAll(".pswp")[0];
    let $imgArr = document.querySelectorAll(
      ".article-entry img:not(.reward-img)"
    );

    $imgArr.forEach(($em, i) => {
      $em.onclick = () => {
        // slider展开状态
        // todo: 这样不好，后面改成状态
        if (document.querySelector(".left-col.show")) return;
        let items = [];
        $imgArr.forEach(($em2, i2) => {
          let img = $em2.getAttribute("data-idx", i2);
          let src =
            $em2.getAttribute("data-target") || $em2.getAttribute("src");
          let title = $em2.getAttribute("alt");
          // 获得原图尺寸
          const image = new Image();
          image.src = src;
          items.push({
            src: src,
            w: image.width || $em2.width,
            h: image.height || $em2.height,
            title: title,
          });
        });
        var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
          index: parseInt(i),
        });
        gallery.init();
      };
    });
  }
  viewer_init();
</script>
 
<!-- MathJax -->
 <script type="text/x-mathjax-config">
  MathJax.Hub.Config({
      tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
  });

  MathJax.Hub.Queue(function() {
      var all = MathJax.Hub.getAllJax(), i;
      for(i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
      }
  });
</script>

<script src="/js/MathJax.js"></script>
<script src="/js/TeX-AMS-MML_HTMLorMML-full.js"></script>

<script>
  var ayerConfig = {
    mathjax: true,
  };
</script>

<!-- Katex -->

<!-- busuanzi  -->

<!-- ClickLove -->

<!-- ClickBoom1 -->

<!-- ClickBoom2 -->

<!-- CodeCopy -->
 
<link rel="stylesheet" href="/css/clipboard.css">
 <script src="/js/clipboard.min.js"></script>
<script>
  function wait(callback, seconds) {
    var timelag = null;
    timelag = window.setTimeout(callback, seconds);
  }
  !(function (e, t, a) {
    var initCopyCode = function () {
      var copyHtml = "";
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="ri-file-copy-2-line"></i><span>COPY</span>';
      copyHtml += "</button>";
      $(".highlight .code pre").before(copyHtml);
      $(".article pre code").before(copyHtml);
      var clipboard = new ClipboardJS(".btn-copy", {
        target: function (trigger) {
          return trigger.nextElementSibling;
        },
      });
      clipboard.on("success", function (e) {
        let $btn = $(e.trigger);
        $btn.addClass("copied");
        let $icon = $($btn.find("i"));
        $icon.removeClass("ri-file-copy-2-line");
        $icon.addClass("ri-checkbox-circle-line");
        let $span = $($btn.find("span"));
        $span[0].innerText = "COPIED";

        wait(function () {
          // 等待两秒钟后恢复
          $icon.removeClass("ri-checkbox-circle-line");
          $icon.addClass("ri-file-copy-2-line");
          $span[0].innerText = "COPY";
        }, 2000);
      });
      clipboard.on("error", function (e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass("copy-failed");
        let $icon = $($btn.find("i"));
        $icon.removeClass("ri-file-copy-2-line");
        $icon.addClass("ri-time-line");
        let $span = $($btn.find("span"));
        $span[0].innerText = "COPY FAILED";

        wait(function () {
          // 等待两秒钟后恢复
          $icon.removeClass("ri-time-line");
          $icon.addClass("ri-file-copy-2-line");
          $span[0].innerText = "COPY";
        }, 2000);
      });
    };
    initCopyCode();
  })(window, document);
</script>
 
<!-- CanvasBackground -->

<script>
  if (window.mermaid) {
    mermaid.initialize({ theme: "default" });
  }
</script>


    
    

  </div>
</body>

</html>