<!DOCTYPE html>


<html lang="zh-CN">
  

    <head>
      <meta charset="utf-8" />
       
      <meta name="keywords" content="前端 web react" />
       
      <meta name="description" content="前端技术与生活。" />
      
      <meta
        name="viewport"
        content="width=device-width, initial-scale=1, maximum-scale=1"
      />
      <title> 四月八日</title>
  <meta name="generator" content="hexo-theme-ayer">
      
      <link rel="shortcut icon" href="/favicon.ico" />
       
<link rel="stylesheet" href="/dist/main.css">
 
<link rel="stylesheet" href="/css/fonts/remixicon.css">
 
<link rel="stylesheet" href="/css/custom.css">
 
      <script src="/js/pace.min.js"></script>
       
 

      <link rel="stylesheet" href="/css/bulma.min.css" />
      <script src="/js/sweetalert2.min.js"></script>

      <!-- mermaid -->
      
      <script src="https://cdn.staticfile.org/mermaid/8.14.0/mermaid.min.js"></script>
      
      <style>
        .swal2-styled.swal2-confirm {
          font-size: 1.6rem;
        }
      </style>
    <!-- hexo injector head_end start -->
<link rel="stylesheet" href="/css/katex.min.css">

<link rel="stylesheet" href="/css/style.css">
<!-- hexo injector head_end end --></head>
  </html>
</html>


<body>
  <div id="app">
    
      
    <main class="content on">
      
<section class="cover">
    
  <div class="cover-frame">
    <div class="bg-box">
      <img src="/images/cover1.jpg" alt="image frame" />
    </div>
    <div class="cover-inner text-center text-white">
      <h1><a href="/">四月八日</a></h1>
      <div id="subtitle-box">
        
        <span id="subtitle"></span>
        
      </div>
      <div>
        
      </div>
    </div>
  </div>
  <div class="cover-learn-more">
    <a href="javascript:void(0)" class="anchor"><i class="ri-arrow-down-line"></i></a>
  </div>
</section>



<script src="https://cdn.staticfile.org/typed.js/2.0.12/typed.min.js"></script>


<!-- Subtitle -->

  <script>
    try {
      var typed = new Typed("#subtitle", {
        strings: ['愿你足够强大，也要足够温柔', '最轻的并不是一根羽毛，而是一双飞鸟的翅膀', ''],
        startDelay: 0,
        typeSpeed: 200,
        loop: true,
        backSpeed: 100,
        showCursor: true
      });
    } catch (err) {
      console.log(err)
    }
  </script>
  
<div id="main">
  <section class="outer">
  
  
  <article class="articles">
    
    
    
    
    <article
  id="post-webpack/配置优化"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/posts/40f37b34d706/"
    >配置优化</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/posts/40f37b34d706/" class="article-date">
  <time datetime="2021-01-20T18:08:38.000Z" itemprop="datePublished">2021-01-21</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/webpack/">webpack</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h5 id="HMR-模块热替换"><a href="#HMR-模块热替换" class="headerlink" title="HMR 模块热替换"></a>HMR 模块热替换</h5><p>当一个模块改变时避免所有的模块都被重新编译一次，应该只更新修改的模块</p>
<p>通过 <code>hot:true</code> 开启hmr，此时样式文件(.css .scss) 可以进行热模块替换，<code>style-loader</code>内部的实现，但是js文件没有开启热替换，而且html的文件也不能更新了</p>
<p>因为热替换阻止了刷新，通过修改<code>webpack.config.js</code> 入口配置<code>entry: [&#39;./src/index.js&#39;,&#39;./src/index.html&#39;],</code>,可以重新开启<code>index.html</code>的刷新功能</p>
<p>另外 <code>html</code>文件不需要热替换的功能，因为每个入口只对应一个文件，一定要重新加载</p>
<p><code>.js</code>文件的热替换不能是入口文件</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="variable language_">module</span>.<span class="property">hot</span>) &#123;</span><br><span class="line">  <span class="variable language_">module</span>.<span class="property">hot</span>.<span class="title function_">accept</span>(<span class="string">&#x27;./print.js&#x27;</span>, <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Accepting the updated printMe module!&#x27;</span>);</span><br><span class="line">    <span class="title function_">printMe</span>();</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="source-map"><a href="#source-map" class="headerlink" title="source-map"></a>source-map</h5><p>提供源代码到编译后代码映射的方案，可以追踪源代码的位置 通过<a target="_blank" rel="noopener" href="https://webpack.docschina.org/configuration/devtool/#root">devtool</a>配置</p>
<p>[inline-|hidden-|eval][nosources-][cheap-[module-]]source-map</p>
<p>inline 构建速度快</p>
<p>source-map 能提示错误代码准确信息，和源代码中准确位置，会单独生成一个文件</p>
<p>inline-source-map source-map会内嵌到生成的js文件中，只生成一个内联的source-map ，能提示错误代码准确信息，和源代码中准确位置</p>
<p>eval-source-map source-map会内嵌到生成的js文件中,每个文件都会生成对应的source-map，可以提示错误原因，但不能追踪到源代码位置，只会定位到编译后的错误位置</p>
<p>hidden-source-map source-map文件会单独生成，可以提示错误原因，但不能追踪到源代码位置，只会定位到编译后的错误位置</p>
<p>cheap-source-map 在外部单独生成，只能提示到行，如果代码在一行中，不能准确的定位</p>
<p>cheap-module-source-map 在外部单独生成 与 cheap-source-map 类似,会将loader的source-map加入</p>
<p>nosources-source-map 可以提供作物信息，但是不能定位到错误位置，源代码和编译后代码都不可以</p>
<p>数度快慢: eval&#x3D;&gt; inline &#x3D;&gt; cheap</p>
<p>开发环境：cheap-source-map<br>  速度快<br>    eval-cheap-source-map<br>    eval-source-map 🆚<br>  调试友好<br>    source-map<br>    cheap-module-source-map<br>    cheap-source-map</p>
<p>生产环境<br>  简单调试，<br>  内联会让体积变大<br>  nosources-source-map 全部隐藏代码，在线上环境使用🆚<br>  hidden-source-map  只隐藏源代码</p>
<p>  source-map 🆚,单独生成文件且便于调试</p>
<h4 id="oneOf"><a href="#oneOf" class="headerlink" title="oneOf"></a>oneOf</h4><p>用于提升构建的速度，只要有一个loader匹配到就不会继续匹配</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">module</span>: &#123;</span><br><span class="line">    <span class="attr">rules</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        <span class="comment">// 指定优先级，都会先被这个loader处理</span></span><br><span class="line">        <span class="attr">enforce</span>:<span class="string">&#x27;pre&#x27;</span></span><br><span class="line">      &#125;，</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">oneOf</span>:[</span><br><span class="line">          <span class="comment">// 其他的loader</span></span><br><span class="line">        ]</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h4><p>在编译文件的时候，如果依赖文件没有改变，则直接使用编译好的缓存文件，无需所有文件都重新编译</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">test</span>: <span class="regexp">/\.js$/i</span>,</span><br><span class="line">  <span class="attr">use</span>: [&#123;</span><br><span class="line">    <span class="attr">loader</span>: <span class="string">&#x27;babel-loader&#x27;</span>,</span><br><span class="line">    <span class="attr">options</span>:&#123;</span><br><span class="line">      <span class="attr">cacheDirectory</span>:<span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;],</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<p>文件资源的缓存 </p>
<ul>
<li><p>hash 如果都使用hash的话，即每次修改任何一个文件，所有文件名的hash至都将改变。所以一旦修改了任何一个文件，整个项目的文件缓存都将失效.</p>
</li>
<li><p>chunkhash chunkhash根据不同的入口文件(Entry)进行依赖文件解析、构建对应的chunk，生成对应的哈希值。在生产环境里把一些公共库和程序入口文件区分开，单独打包构建，接着我们采用chunkhash的方式生成哈希值，那么只要我们不改动公共库的代码，就可以保证其哈希值不会受影响。动态import也受chunkhash的影响.</p>
</li>
</ul>
<p>因为我们是将样式作为模块import到JavaScript文件中的，所以它们的chunkhash是一致的,这样就会有个问题，只要对应css或则js改变，与其关联的文件hash值也会改变，但其内容并没有改变呢，所以没有达到缓存意义。固contenthash的用途随之而来。</p>
<ul>
<li>contenthash是针对文件内容级别的，只有你自己模块的内容变了，那么hash值才改变</li>
</ul>
<h4 id="tree-shaking"><a href="#tree-shaking" class="headerlink" title="tree-shaking"></a>tree-shaking</h4><p>使用es6模块化规范，开启production模式，webpack会自动启用tree-shaking</p>
<p><code>webpack.config.js</code> 中添加<code>sideEffects:false</code>表示所有的代码都没有副作用，如果标记为<code>false</code>, 全局引入的文件(polyfile),或没有通过模块化使用的css,都会被删除</p>
<p>可以通过一个数组来标记不需要处理的资源 <code>sideEffects:[&#39;*.css&#39;]</code></p>
<h4 id="代码分割-code-split"><a href="#代码分割-code-split" class="headerlink" title="代码分割 code-split"></a>代码分割 code-split</h4><p><strong>生成chunk的几种方式</strong></p>
<ul>
<li>多页面entry生成多个chunk</li>
<li>异步组件生成chunk</li>
<li>code split</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将node-modules 中代码单独打包成</span></span><br><span class="line"><span class="comment">// 分析多入口文件中有没有公共的依赖，会把依赖单独打包</span></span><br><span class="line"><span class="attr">optimization</span>: &#123;</span><br><span class="line">  <span class="attr">splitChunks</span>: &#123;</span><br><span class="line">    <span class="attr">chunks</span>: <span class="string">&#x27;all&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<h4 id="懒加载-预加载"><a href="#懒加载-预加载" class="headerlink" title="懒加载 预加载"></a>懒加载 预加载</h4><p><a target="_blank" rel="noopener" href="https://webpack.docschina.org/guides/code-splitting/#dynamic-imports">dynamic-imports</a></p>
<p><code>babel-loader</code>会自动处理 <code>dynamic-imports</code>语法， 如果<code>eslint</code>提示错误，在<code>.eslintrc</code>中添加<code>&quot;parser&quot;: &quot;babel-eslint&quot;</code></p>
<h4 id="PWA"><a href="#PWA" class="headerlink" title="PWA"></a>PWA</h4><p>work-box -&gt; <a target="_blank" rel="noopener" href="https://developers.google.com/web/tools/workbox/modules/workbox-webpack-plugin">workbox-webpack-plugin</a></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn add -D workbox-webpack-plugin</span><br></pre></td></tr></table></figure>

<p><code>webpack.config.js</code> 中添加插件和<a target="_blank" rel="noopener" href="https://developers.google.com/web/tools/workbox/reference-docs/latest/module-workbox-webpack-plugin.GenerateSW#GenerateSW">配置项</a></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">plugins</span>:[</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">GenerateSW</span>(&#123;</span><br><span class="line">      <span class="comment">// 帮助serviceWork快速启动，</span></span><br><span class="line">      <span class="comment">// 删除旧的serverwork</span></span><br><span class="line">      <span class="attr">clientsClaim</span>:<span class="literal">true</span>,</span><br><span class="line">      <span class="attr">skipWaiting</span>:<span class="literal">true</span></span><br><span class="line">    &#125;)</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注册servicework</p>
<p>在入口文件<code>index.js</code>中</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="string">&#x27;serviceWorker&#x27;</span> <span class="keyword">in</span> navigator) &#123;</span><br><span class="line">  <span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;load&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    navigator.<span class="property">serviceWorker</span>.<span class="title function_">register</span>(<span class="string">&#x27;./service-worker.js&#x27;</span>)</span><br><span class="line">      .<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;注册成功&#x27;</span>);</span><br><span class="line">      &#125;)</span><br><span class="line">      .<span class="title function_">catch</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;注册失败&#x27;</span>);</span><br><span class="line">      &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果<code>eslint</code>不支持全局变量,在<code>.eslinrc</code>添加<code>&#123;env:browser: true,&#125;</code></p>
<h4 id="多进程打包"><a href="#多进程打包" class="headerlink" title="多进程打包"></a>多进程打包</h4><p><a target="_blank" rel="noopener" href="https://www.npmjs.com/package/thread-loader">thread-loader</a></p>
<p>进程的启用会占用时间（大约600ms），只有复杂的任务处理的时候才会有明显的效果</p>
<h4 id="externals-忽略某些资源"><a href="#externals-忽略某些资源" class="headerlink" title="externals 忽略某些资源"></a>externals 忽略某些资源</h4><p>在<code>webpack.config.js</code>中添加<a target="_blank" rel="noopener" href="https://webpack.docschina.org/configuration/externals/#root"><code>externals</code></a></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  <span class="attr">externals</span>: &#123;</span><br><span class="line">    <span class="attr">jquery</span>: <span class="string">&#x27;jQuery&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>和dll的区别是，externals并没有打包文件，需要通过cdn的方式引入进来，dll只是把指定的包单独打包，并通过插件把单独打包的文件重新引入</p>
<h4 id="dll"><a href="#dll" class="headerlink" title="dll"></a>dll</h4><p>对第三方的库，进行单独打包 webpack5不适用</p>
<p>通过两份配置，可以避免每次对第三方的库重新打包</p>
<p>webpack.dll.js</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> webpack = <span class="built_in">require</span>(<span class="string">&#x27;webpack&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="attr">entry</span>:&#123;</span><br><span class="line">    <span class="attr">lodash</span>:[<span class="string">&#x27;lodash&#x27;</span>],</span><br><span class="line">    <span class="attr">jquery</span>:[<span class="string">&#x27;jquery&#x27;</span>],</span><br><span class="line">    <span class="attr">moment</span>:[<span class="string">&quot;moment&quot;</span>]</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">output</span>:&#123;</span><br><span class="line">    <span class="comment">// 生成文件的名称</span></span><br><span class="line">    <span class="attr">filename</span>:<span class="string">&#x27;[name]_[contenthash:8].js&#x27;</span>,</span><br><span class="line">    <span class="attr">path</span>:path.<span class="title function_">resolve</span>(__dirname,<span class="string">&#x27;dll&#x27;</span>),</span><br><span class="line">    <span class="comment">// 单独打包的库对外暴露的名称</span></span><br><span class="line">    <span class="attr">library</span>: <span class="string">&quot;[name]_[fullhash]&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">plugins</span>:[</span><br><span class="line">    <span class="keyword">new</span> webpack.<span class="title class_">DllPlugin</span>(&#123;</span><br><span class="line">      <span class="attr">context</span>: __dirname,</span><br><span class="line">      <span class="comment">// 映射单独打包的库的名称</span></span><br><span class="line">      <span class="attr">name</span>: <span class="string">&#x27;[name]_[fullhash]&#x27;</span>,</span><br><span class="line">      <span class="comment">// 生成的manifest文件</span></span><br><span class="line">      <span class="attr">path</span>:path.<span class="title function_">resolve</span>(__dirname,<span class="string">&#x27;dll/[name]_manifest.json&#x27;</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">mode</span>:<span class="string">&#x27;production&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>webpack.config.js</p>
<p>使用 <a target="_blank" rel="noopener" href="https://www.npmjs.com/package/add-asset-html-webpack-plugin">add-asset-html-webpack-plugin</a>把单独打包的资源引入</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">export</span> = &#123;</span><br><span class="line">  <span class="attr">plugins</span>:[</span><br><span class="line">    <span class="keyword">new</span> webpack.<span class="title class_">DllReferencePlugin</span>(&#123;</span><br><span class="line">      <span class="comment">// 存在于manifest文件中的包，不会被打包</span></span><br><span class="line">			<span class="attr">manifest</span>: <span class="built_in">require</span>(path.<span class="title function_">resolve</span>(__dirname,<span class="string">&#x27;dll/moment_manifest.json&#x27;</span>))</span><br><span class="line">    &#125;),</span><br><span class="line">    <span class="keyword">new</span> webpack.<span class="title class_">DllReferencePlugin</span>(&#123;</span><br><span class="line">			<span class="attr">manifest</span>: <span class="built_in">require</span>(path.<span class="title function_">resolve</span>(__dirname,<span class="string">&#x27;dll/lodash_manifest.json&#x27;</span>))</span><br><span class="line">    &#125;),</span><br><span class="line">    <span class="keyword">new</span> webpack.<span class="title class_">DllReferencePlugin</span>(&#123;</span><br><span class="line">			<span class="attr">manifest</span>: <span class="built_in">require</span>(path.<span class="title function_">resolve</span>(__dirname,<span class="string">&#x27;dll/jquery_manifest.json&#x27;</span>))</span><br><span class="line">		&#125;),</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">AddAssetHtmlPlugin</span>(&#123;</span><br><span class="line">      <span class="attr">filepath</span>: path.<span class="title function_">resolve</span>(__dirname, <span class="string">&#x27;./dll/*.js&#x27;</span>),</span><br><span class="line">    &#125;)</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="optimization"><a href="#optimization" class="headerlink" title="optimization"></a>optimization</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">optimization</span>: &#123;</span><br><span class="line">    <span class="attr">minimize</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="comment">// https://webpack.docschina.org/plugins/terser-webpack-plugin/</span></span><br><span class="line">    <span class="attr">minimizer</span>: [<span class="keyword">new</span> <span class="title class_">TerserPlugin</span>(&#123;</span><br><span class="line">      <span class="attr">cache</span>:<span class="literal">true</span>,<span class="comment">// 开启缓存</span></span><br><span class="line">      <span class="attr">parallel</span>:<span class="literal">true</span>,<span class="comment">//多进程打包</span></span><br><span class="line">      <span class="attr">sourceMap</span>:<span class="literal">true</span> <span class="comment">//启用source-map</span></span><br><span class="line">    &#125;)],</span><br><span class="line">   <span class="attr">splitChunks</span>: &#123;</span><br><span class="line">      <span class="comment">// async表示只从异步加载得模块（动态加载import()）里面进行拆分</span></span><br><span class="line">      <span class="comment">// initial表示只从入口模块进行拆分</span></span><br><span class="line">      <span class="comment">// all表示以上两者都包括</span></span><br><span class="line">      <span class="attr">chunks</span>: <span class="string">&#x27;async&#x27;</span>, <span class="comment">//all </span></span><br><span class="line">      <span class="attr">minSize</span>: <span class="number">1024</span> * <span class="number">30</span> , <span class="comment">//分割chunk的最小大小，大于30kb才会被提取</span></span><br><span class="line">      <span class="attr">minRemainingSize</span>: <span class="number">0</span>,</span><br><span class="line">      <span class="attr">maxSize</span>: <span class="number">0</span>,<span class="comment">// 没有最大限制</span></span><br><span class="line">      <span class="attr">minChunks</span>: <span class="number">1</span>, <span class="comment">// 至少被引用一次</span></span><br><span class="line">      <span class="comment">// 按需加载的时候并行加载文件的最大个数</span></span><br><span class="line">      <span class="comment">// 可以理解为针对一个模块拆分后的个数，包括模块本身</span></span><br><span class="line">      <span class="comment">// import()文件本身算一个请求</span></span><br><span class="line">      <span class="comment">// 并不算js以外的公共资源请求比如css</span></span><br><span class="line">      <span class="comment">// 如果同时有两个模块满足cacheGroup的规则要进行拆分，但是maxInitialRequests的值只能允许再拆分一个模块，那尺寸更大的模块会被拆分出来</span></span><br><span class="line">      <span class="comment">// 一个按需加载的包最终被拆分成 n 个包，maxAsyncRequests 就是用来限制 n 的最大值。</span></span><br><span class="line">      <span class="attr">maxAsyncRequests</span>: <span class="number">30</span>, </span><br><span class="line">      <span class="attr">maxInitialRequests</span>: <span class="number">30</span>, <span class="comment">//入口js文件最大请求数量</span></span><br><span class="line">      <span class="attr">enforceSizeThreshold</span>: <span class="number">50000</span>,</span><br><span class="line">      <span class="attr">name</span>: <span class="literal">true</span>, <span class="comment">// 可以使用命名规则</span></span><br><span class="line">      <span class="attr">cacheGroups</span>: &#123;</span><br><span class="line">        <span class="comment">// node_module中的包会被引入到defaultVendors包中</span></span><br><span class="line">        <span class="attr">defaultVendors</span>: &#123;</span><br><span class="line">          <span class="attr">test</span>: <span class="regexp">/[\\/]node_modules[\\/]/</span>,</span><br><span class="line">          <span class="attr">priority</span>: -<span class="number">10</span>,</span><br><span class="line">          <span class="comment">// 如果当前打包的模块和之前的是同一个就会复用，而不是重复打包</span></span><br><span class="line">          <span class="attr">reuseExistingChunk</span>: <span class="literal">true</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">default</span>: &#123;</span><br><span class="line">          <span class="attr">minChunks</span>: <span class="number">2</span>,</span><br><span class="line">          <span class="attr">priority</span>: -<span class="number">20</span>,</span><br><span class="line">          <span class="attr">reuseExistingChunk</span>: <span class="literal">true</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="comment">// 将当前模块中记录的其他模块的hash单独打包成一个文件</span></span><br><span class="line">      <span class="comment">// 因为如果main.js 引用 a.js,main.js中会保存a.js打包时生成的cotenthash</span></span><br><span class="line">      <span class="comment">// 如果a.js发生改变则contenthash发生改变，那么main.js的contenthash也会改变</span></span><br><span class="line">      <span class="comment">// 代码分割的时候一定要加</span></span><br><span class="line">      <span class="attr">runtimeChunk</span>:<span class="function">()=&gt;</span> &#123;</span><br><span class="line">        <span class="attr">name</span>:<span class="function"><span class="params">entrypoint</span>=&gt;</span><span class="string">`runtime-<span class="subst">$&#123;entrypoint.name&#125;</span>`</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/webpack/" rel="tag">webpack</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%B7%A5%E7%A8%8B%E5%8C%96/" rel="tag">工程化</a></li></ul>

    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-algorithm/leetcode/填充每个节点的下一个右侧节点指针"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/posts/0d16fafcd38e/"
    >LeetCode 填充每个节点的下一个右侧节点指针</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/posts/0d16fafcd38e/" class="article-date">
  <time datetime="2021-01-20T07:35:11.000Z" itemprop="datePublished">2021-01-20</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E7%AE%97%E6%B3%95/">算法</a> / <a class="article-category-link" href="/categories/%E7%AE%97%E6%B3%95/%E5%85%B3%E8%81%94%E9%A2%98%E7%9B%AE/">关联题目</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/populating-next-right-pointers-in-each-node/description/">填充每个节点的下一个右侧节点指针</a></p>
<h4 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h4><p>相同层级的操作可以想到的是层序遍,但是题目中有一个问题没有说清楚,下一个右侧节点表示紧邻的右侧节点,空节点也算是一个节点,换句话说空节点不能跳过</p>
<p>在思考一下其中的细节,需要清楚一层有多少个节点，这样才能准确遍历到一层的末尾, 链接的时候空的节点不能跳过，因为这也是合法的节点。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">connect</span> = (<span class="params">root</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (root === <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> queue = [root];</span><br><span class="line">  <span class="keyword">while</span> (queue.<span class="property">length</span>) &#123;</span><br><span class="line">    <span class="comment">// 记录每一层的长度</span></span><br><span class="line">    <span class="keyword">let</span> len = queue.<span class="property">length</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (len--) &#123;</span><br><span class="line">      <span class="keyword">const</span> node = queue.<span class="title function_">shift</span>();</span><br><span class="line">      <span class="keyword">if</span> (len &amp;&amp; node) node.<span class="property">next</span> = queue[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 不需要判断空节点</span></span><br><span class="line">      <span class="keyword">if</span> (node) queue.<span class="title function_">push</span>(node.<span class="property">left</span>, node.<span class="property">right</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> root;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这个问题也可以用,递归来解决,因为它可以抽象成更小的子问题，也就是链接两个节点，需要知道的是哪些节点是需要链接的。</p>
<p>如果盲目的套用递归框架就会困惑，在另外一个子树的节点，怎么能获取到呢。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">connect</span> = (<span class="params">root</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (root === <span class="literal">null</span>) <span class="keyword">return</span> root;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (root.<span class="property">left</span>) root.<span class="property">next</span> = root.<span class="property">right</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 无法获取另外子树的节点</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> root;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>所以需要指明，那两个节点需要链接，这也是一个先序遍历的模型，但是子问题需要传递更多的信息。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">dig</span> = (<span class="params">left, right</span>) =&gt; &#123;</span><br><span class="line">  <span class="comment">// 链接两个节点</span></span><br><span class="line">  <span class="keyword">if</span> (left) left.<span class="property">next</span> = right;</span><br><span class="line">  <span class="keyword">if</span> (left) <span class="title function_">dig</span>(left.<span class="property">left</span>, left.<span class="property">right</span>);</span><br><span class="line">  <span class="keyword">if</span> (right) <span class="title function_">dig</span>(right.<span class="property">left</span>, right.<span class="property">right</span>);</span><br><span class="line">  <span class="comment">// 不同子树中需要连接的节点</span></span><br><span class="line">  <span class="keyword">if</span> (left &amp;&amp; right) <span class="title function_">dig</span>(left.<span class="property">right</span>, right.<span class="property">left</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">connect</span> = (<span class="params">root</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (root === <span class="literal">null</span>) <span class="keyword">return</span> root;</span><br><span class="line">  <span class="title function_">dig</span>(root.<span class="property">left</span>, root.<span class="property">right</span>);</span><br><span class="line">  <span class="keyword">return</span> root;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%85%B3%E8%81%94%E9%A2%98%E7%9B%AE/" rel="tag">关联题目</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%AE%97%E6%B3%95/" rel="tag">算法</a></li></ul>

    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-algorithm/leetcode/二叉树展开为链表"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/posts/13ae1e52470a/"
    >LeetCode 二叉树展开为链表</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/posts/13ae1e52470a/" class="article-date">
  <time datetime="2021-01-20T02:20:22.000Z" itemprop="datePublished">2021-01-20</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E7%AE%97%E6%B3%95/">算法</a> / <a class="article-category-link" href="/categories/%E7%AE%97%E6%B3%95/%E5%85%B3%E8%81%94%E9%A2%98%E7%9B%AE/">关联题目</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/flatten-binary-tree-to-linked-list/description/">二叉树展开为链表</a></p>
<h4 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h4><p>可以很自然想到的是需要一个递归，因为他需要先序遍历<br>我们会直接进入到每个左边子树的左节点。<br>但是这经过的右子树是暂时用不到的，所以需要想办法把他们存起来，在稍后使用</p>
<!-- It's natural to think that a recursive approach is needed, as it requires a pre-order traversal.
We will directly move into the left node of each left subtree.
However, the right subtrees encountered along the way are temporarily unused,
so we need a way to store them for later use. -->

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">flatten</span> = (<span class="params">root</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (root === <span class="literal">null</span>) <span class="keyword">return</span> root;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> stack = [];</span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">dig</span> = (<span class="params">root</span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (root === <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">const</span> right = root.<span class="property">right</span>;</span><br><span class="line">    root.<span class="property">right</span> = <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">// 暂存右节点</span></span><br><span class="line">    <span class="keyword">if</span> (right !== <span class="literal">null</span>) stack.<span class="title function_">push</span>(right);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将左节点放到有节点上</span></span><br><span class="line">    <span class="comment">// 并先序遍历继续递归向下</span></span><br><span class="line">    <span class="keyword">if</span> (root.<span class="property">left</span> !== <span class="literal">null</span>) &#123;</span><br><span class="line">      root.<span class="property">right</span> = root.<span class="property">left</span>;</span><br><span class="line">      root.<span class="property">left</span> = <span class="literal">null</span>;</span><br><span class="line">      <span class="title function_">dig</span>(root.<span class="property">right</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 如果已经没有下面的节点</span></span><br><span class="line">      <span class="comment">// 从队列中取出最后的右子树遍历</span></span><br><span class="line">      <span class="keyword">const</span> next = stack.<span class="title function_">pop</span>();</span><br><span class="line">      <span class="keyword">if</span> (next == <span class="literal">undefined</span>) <span class="keyword">return</span>;</span><br><span class="line">      root.<span class="property">right</span> = next;</span><br><span class="line">      <span class="title function_">dig</span>(next);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="title function_">dig</span>(root);</span><br><span class="line">  <span class="keyword">return</span> root;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>还可以思考用 O(1) 的空间复杂度，解决这个问题。既然不能用额外的储存空间，那么可以考虑将用到的信息放在树的节点上操作。</p>
<p>题目要求是以先序遍历的顺序，并且通用右指针相连，对于右指针相连这个问题我们可以弱化它，因为这可以通过节点交换很容易的完成。</p>
<p>而以先序遍历顺序返回，并不意味着一定要先访问根节点，只要处理之后的链表的顺序是先序遍历就可以了，所以对于一个只有三个节点的子树来说，将右节点接在左节点的后面就是先序遍历。</p>
<p>那要如何保证在访问根节点的时候，左右子树都是一个处理好的链表，我们会想到后序遍历，因为在访问某个节点的时候，他的左右子树都已经在后序遍历的代码位置处理成了链表，可以直接拼接。</p>
<p>所以可以写出下面的框架</p>
<!-- We can also consider solving this problem with O(1) space complexity/kəmˈpleksəti/. Since(通常用于提供上下文或理由而不强调原因。) we cannot use extra/ˈekstrə/ storage space, we might think about leveraging(充分利用) the tree nodes themselves to store and operate on the required information.

The problem requires linking nodes in pre-order traversal order using the right pointer. However, we can simplify this requirement for right-pointer linking, as it can be easily achieved through node rearrangement later.

Returning the nodes in pre-order traversal order doesn't necessarily mean visiting the root node first. As long as the final linked list follows the pre-order traversal sequence, it's valid. For example, in a subtree with only three nodes, connecting the right child to the end of the left child's list achieves the pre-order traversal order.

So, how can we ensure that, when visiting a root node, its left and right subtrees are already processed into linked lists? Post-order traversal comes to mind, as it ensures that when processing a node, its left and right subtrees have already been transformed into linked lists, making it easy to concatenate them.

Based on this, we can construct the following framework: -->

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">dig</span> = (<span class="params">root</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (root === <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">  <span class="title function_">dig</span>(root.<span class="property">left</span>);</span><br><span class="line">  <span class="title function_">dig</span>(root.<span class="property">right</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 处理左右节点</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">flatten</span> = (<span class="params">root</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (root === <span class="literal">null</span>) <span class="keyword">return</span> root;</span><br><span class="line">  <span class="title function_">dig</span>(root);</span><br><span class="line">  <span class="keyword">return</span> root;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>思考一些具体的细节，当一个节点的左节点不存在的时候，可以直接跳过，因为它只有一个右节点的话不需要处理，或者右节点已经处理成一个链表。</p>
<p>而当一个左节点存在的时候，需要能获取到左节点这个链表中的最后一个，才能和右节点相连，最后还需要交换左右节点。</p>
<!-- When a node does not have a left child, we can simply skip it because if it only has a right child, there is no need for processing, or the right child has already been processed into a linked list.

However, when a left child exists, we need to find the last node in the linked list formed by the left child to connect it with the right child. Finally, we need to swap the left and right children. -->

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">dig</span> = (<span class="params">root</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (root === <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">  <span class="title function_">dig</span>(root.<span class="property">left</span>);</span><br><span class="line">  <span class="title function_">dig</span>(root.<span class="property">right</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> last = root.<span class="property">left</span>;</span><br><span class="line">  <span class="comment">// 左节点不存在，直接返回</span></span><br><span class="line">  <span class="keyword">if</span> (last === <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取最后一个节点</span></span><br><span class="line">  <span class="keyword">while</span> (last.<span class="property">right</span>) &#123;</span><br><span class="line">    last = last.<span class="property">right</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 交换左右子树</span></span><br><span class="line">  last.<span class="property">right</span> = root.<span class="property">right</span>;</span><br><span class="line">  root.<span class="property">right</span> = root.<span class="property">left</span>;</span><br><span class="line">  root.<span class="property">left</span> = <span class="literal">null</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">flatten</span> = (<span class="params">root</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (root === <span class="literal">null</span>) <span class="keyword">return</span> root;</span><br><span class="line">  <span class="title function_">dig</span>(root);</span><br><span class="line">  <span class="keyword">return</span> root;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%85%B3%E8%81%94%E9%A2%98%E7%9B%AE/" rel="tag">关联题目</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%AE%97%E6%B3%95/" rel="tag">算法</a></li></ul>

    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-algorithm/leetcode/二叉树直径"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/posts/6a338e4e2cab/"
    >LeetCode 二叉树直径</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/posts/6a338e4e2cab/" class="article-date">
  <time datetime="2021-01-19T15:31:22.000Z" itemprop="datePublished">2021-01-19</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E7%AE%97%E6%B3%95/">算法</a> / <a class="article-category-link" href="/categories/%E7%AE%97%E6%B3%95/%E5%85%B3%E8%81%94%E9%A2%98%E7%9B%AE/">关联题目</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/diameter-of-binary-tree/">二叉树直径</a></p>
<h4 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h4><p>可以观察到两个现象</p>
<ul>
<li>直径可能并不会经过根节点</li>
<li>所谓的直径就是某个节点的左子树深度加右子树深度最长的一条</li>
</ul>
<p>那既然是获取最长的子树，是不能能套用一个之前的求 <a href="/posts/8e3fe34f62a9/">二叉树最大深度</a> 的方法, 思考以下可以使用下面这个框架么</p>
<p>这可能行不通，因为提出了 maxDeep 方法导致调用时，只能作用在根节点的左右子树。替他节点无法调用这个模式递归。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">maxDeep</span> = (<span class="params">root</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (root === <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Math</span>.<span class="title function_">max</span>(<span class="title function_">maxDeep</span>(root.<span class="property">left</span>), <span class="title function_">maxDeep</span>(root.<span class="property">right</span>)) + <span class="number">1</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> diameterOfBinaryTree = <span class="keyword">function</span> (<span class="params">root</span>) &#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>既然这样就放到内部去做, 但是这种框架面临的问题是，返回值只有一个，希望可以知道左右子树的最大深度，又要保留着已经遍历过的子树的最大直径。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> diameterOfBinaryTree = <span class="keyword">function</span> (<span class="params">root</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (root === <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> l = <span class="title function_">diameterOfBinaryTree</span>(root.<span class="property">left</span>);</span><br><span class="line">  <span class="keyword">let</span> r = <span class="title function_">diameterOfBinaryTree</span>(root.<span class="property">right</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// return Math.max(l + r, l, r) + 1;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>那就再引入一个额外的变量去保存，最大直径，让递归可以专注与子树的最大深度</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> diameterOfBinaryTree = <span class="keyword">function</span> (<span class="params">root</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (root === <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> max = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">dig</span> = (<span class="params">root</span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (root === <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> left = <span class="title function_">dig</span>(root.<span class="property">left</span>);</span><br><span class="line">    <span class="keyword">let</span> right = <span class="title function_">dig</span>(root.<span class="property">right</span>);</span><br><span class="line">    max = <span class="title class_">Math</span>.<span class="title function_">max</span>(max, left + right);</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Math</span>.<span class="title function_">max</span>(left, right) + <span class="number">1</span>;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">dig</span>(root);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> max;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>再来看一下，其实用前序遍历也可以实现，但是需要每经历一个节点，就要获取以下当前节点的左右子树的最大深度。</p>
<p>这是因为前序遍历只能获取当前节点的信息，而后序遍历则可以携带上一个节点返回的信息。</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%85%B3%E8%81%94%E9%A2%98%E7%9B%AE/" rel="tag">关联题目</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%AE%97%E6%B3%95/" rel="tag">算法</a></li></ul>

    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-javascript/Ramda_Type方法"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/posts/4f5e1b8629c3/"
    >Ramda Type 方法源码解析</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/posts/4f5e1b8629c3/" class="article-date">
  <time datetime="2021-01-19T08:01:47.000Z" itemprop="datePublished">2021-01-19</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/JavaScript/">JavaScript</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h4 id="type"><a href="#type" class="headerlink" title="type"></a>type</h4><p>toString 方法是Object内部实现的原型方法，实现方式中规定了某种类型的返回值</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> type = <span class="title function_">_curry1</span>(<span class="keyword">function</span> <span class="title function_">type</span>(<span class="params">val</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> val === <span class="literal">null</span></span><br><span class="line">    ? <span class="string">&#x27;Null&#x27;</span></span><br><span class="line">    : val === <span class="literal">undefined</span></span><br><span class="line">      ? <span class="string">&#x27;Undefined&#x27;</span></span><br><span class="line">      : <span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(val).<span class="title function_">slice</span>(<span class="number">8</span>, -<span class="number">1</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> type;</span><br><span class="line"></span><br></pre></td></tr></table></figure> 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Ramda/" rel="tag">Ramda</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/" rel="tag">函数式编程</a></li></ul>

    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-javascript/Ramda_List方法"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/posts/f7e795e13d0b/"
    >Ramda List 方法源码分析</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/posts/f7e795e13d0b/" class="article-date">
  <time datetime="2021-01-19T04:57:53.000Z" itemprop="datePublished">2021-01-19</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/JavaScript/">JavaScript</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h4 id="adjust"><a href="#adjust" class="headerlink" title="adjust"></a><a target="_blank" rel="noopener" href="https://ramda.cn/docs/#adjust">adjust</a></h4><p>判断索引的合法性</p>
<p>定义开始节点，其实就是抽象了计算真实索引的计算</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> adjust = <span class="title function_">_curry3</span>(<span class="keyword">function</span> <span class="title function_">adjust</span>(<span class="params">idx, fn, list</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (idx &gt;= list.<span class="property">length</span> || idx &lt; -list.<span class="property">length</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> list;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">var</span> start = idx &lt; <span class="number">0</span> ? list.<span class="property">length</span> : <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">var</span> _idx = start + idx;</span><br><span class="line">  <span class="keyword">var</span> _list = <span class="title function_">_concat</span>(list);</span><br><span class="line">  _list[_idx] = <span class="title function_">fn</span>(list[_idx]);</span><br><span class="line">  <span class="keyword">return</span> _list;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>


<h4 id="all"><a href="#all" class="headerlink" title="all"></a><a target="_blank" rel="noopener" href="https://ramda.cn/docs/#all">all</a></h4><p><a href="/posts/2b6baf0c/#dispatchable">_dispatchable</a></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> all = <span class="title function_">_curry2</span>(<span class="title function_">_dispatchable</span>([<span class="string">&#x27;all&#x27;</span>], _xall, <span class="keyword">function</span> <span class="title function_">all</span>(<span class="params">fn, list</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> idx = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (idx &lt; list.<span class="property">length</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="title function_">fn</span>(list[idx])) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    idx += <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;));</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> all;</span><br></pre></td></tr></table></figure> 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Ramda/" rel="tag">Ramda</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/" rel="tag">函数式编程</a></li></ul>

    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-algorithm/leetcode/二叉树的最小深度"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/posts/8e3fe34f62a9/"
    >LeetCode 二叉树最小/大深度</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/posts/8e3fe34f62a9/" class="article-date">
  <time datetime="2021-01-19T04:31:12.000Z" itemprop="datePublished">2021-01-19</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E7%AE%97%E6%B3%95/">算法</a> / <a class="article-category-link" href="/categories/%E7%AE%97%E6%B3%95/%E5%85%B3%E8%81%94%E9%A2%98%E7%9B%AE/">关联题目</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/minimum-depth-of-binary-tree/description/">二叉树最小深度</a></p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximum-depth-of-binary-tree/">二叉树最大深度</a></p>
<h4 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h4><p>容易想到的是通过 DFS 遍历携带深度信息，记录深度最大值或最小值。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> minDepth = <span class="keyword">function</span> (<span class="params">root</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (root === <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 记录最小深度（根节点到最近的叶子节点的距离）</span></span><br><span class="line">  <span class="keyword">let</span> minDepthValue = <span class="title class_">Infinity</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 记录当前遍历到的节点深度</span></span><br><span class="line">  <span class="keyword">let</span> currentDepth = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> traverse = <span class="keyword">function</span> (<span class="params">root</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (root === <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 前序位置进入节点时增加当前深度</span></span><br><span class="line">    currentDepth++;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果当前节点是叶子节点，更新最小深度</span></span><br><span class="line">    <span class="keyword">if</span> (root.<span class="property">left</span> === <span class="literal">null</span> &amp;&amp; root.<span class="property">right</span> === <span class="literal">null</span>) &#123;</span><br><span class="line">      minDepthValue = <span class="title class_">Math</span>.<span class="title function_">min</span>(minDepthValue, currentDepth);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">traverse</span>(root.<span class="property">left</span>);</span><br><span class="line">    <span class="title function_">traverse</span>(root.<span class="property">right</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 后序位置离开节点时减少当前深度</span></span><br><span class="line">    currentDepth--;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 从根节点开始 DFS 遍历</span></span><br><span class="line">  <span class="title function_">traverse</span>(root);</span><br><span class="line">  <span class="keyword">return</span> minDepthValue;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>也可以想到为了避免全局定义深度变量，可以把深度放到递归的参数中，下面是最大深度的解法：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">dig</span> = (<span class="params">root, length</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> length;</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Math</span>.<span class="title function_">max</span>(<span class="title function_">dig</span>(root.<span class="property">left</span>, length + <span class="number">1</span>), <span class="title function_">dig</span>(root.<span class="property">right</span>, length + <span class="number">1</span>));</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> maxDepth = <span class="keyword">function</span> (<span class="params">root</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (root === <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 由于退出条件是在叶子节点的左或右的null节点</span></span><br><span class="line">  <span class="comment">// 因此深度会被多加1, 所以开始计数从0开始，可以满足条件</span></span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">dig</span>(root, <span class="number">0</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>但是当用这种思路解决最小深度时，就会遇到问题。</p>
<p>因为是求最小深度，因此递归到叶子节点拿到的高度，是一个无效值，它可能被一个更小的值取代。</p>
<p>但是子树如果为 null,不能参与计算，<strong>因此下面的逻辑当遍历到叶子节点时，仍然递归进入空节点，导致空的子树被算作 1 的长度</strong> 返回错误的结果。</p>
<p>接下来，如果只有左子树，或者右子树，是不会进入退出逻辑的，这会导致递归无法被正确的处理，当只有其中一个子树的时候，要正确处理子树的返回值。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">dig</span> = (<span class="params">root, length</span>) =&gt; &#123;</span><br><span class="line">  <span class="comment">// 避免递归进入空节点</span></span><br><span class="line">  <span class="comment">// + if(!node.left &amp;&amp; !node.right) return deep;</span></span><br><span class="line">  <span class="comment">// - if (root == null) return length;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 当只有一个子树的时候，给空的子树一个默认值 Infinity</span></span><br><span class="line">  <span class="comment">// 因为有值的子树，一定会进入推出逻辑返回一个当前深度值</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// + let left = Infinity,right=Infinity;</span></span><br><span class="line">  <span class="comment">// + if(node.left)  left =  dfs(node.left, deep + 1);</span></span><br><span class="line">  <span class="comment">// + if(node.right) right = dfs(node.right, deep + 1);</span></span><br><span class="line">  <span class="comment">// - return Math.min(dig(root.left, length + 1), dig(root.right, length + 1));</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Math</span>.<span class="title function_">min</span>(left, right);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> maxDepth = <span class="keyword">function</span> (<span class="params">root</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (root === <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// 从 1 开始计数</span></span><br><span class="line">  <span class="comment">// + return dig(root, 1);</span></span><br><span class="line">  <span class="comment">// - return dig(root, 0);</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h4><p>观察解题思路，是通过传递一个深度参数进行递归，也就是说这是从根节点开始计数，如果从叶子节点开始计数，就可以避免参数的传递。</p>
<p>最大深度计算：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var maxDepth = <span class="keyword">function</span> (root) &#123;</span><br><span class="line">    <span class="keyword">if</span> (root === null) <span class="built_in">return</span> 0;</span><br><span class="line">    <span class="built_in">return</span> Math.max(maxDepth(root.left), maxDepth(root.right)) + 1</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>最小深度计算：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> minDepth = <span class="keyword">function</span> (<span class="params">root</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (root === <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> left = <span class="title function_">minDepth</span>(root.<span class="property">left</span>);</span><br><span class="line">  <span class="keyword">let</span> right = <span class="title function_">minDepth</span>(root.<span class="property">right</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 解决左右子树其中一个为空的情况</span></span><br><span class="line">  <span class="keyword">if</span> (left === <span class="number">0</span>) <span class="keyword">return</span> right + <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span> (right === <span class="number">0</span>) <span class="keyword">return</span> left + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Math</span>.<span class="title function_">min</span>(left, right) + <span class="number">1</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>对于最小深度，还可以考虑用 BFS 层序遍历来优化，因为最小深度，是要找到第一个叶子节点所在的深度，而不需要像 DFS 那样，每一个分支走到头才知道哪一条路径是最短的。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> minDepth = <span class="keyword">function</span> (<span class="params">root</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> deep = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> (root === <span class="literal">null</span>) <span class="keyword">return</span> deep;</span><br><span class="line">  <span class="keyword">let</span> queue = [root];</span><br><span class="line">  <span class="keyword">let</span> len;</span><br><span class="line">  <span class="keyword">while</span> ((len = queue.<span class="property">length</span>)) &#123;</span><br><span class="line">    deep++;</span><br><span class="line">    <span class="keyword">const</span> q = queue.<span class="title function_">concat</span>([]);</span><br><span class="line">    queue = [];</span><br><span class="line">    <span class="keyword">while</span> (len--) &#123;</span><br><span class="line">      <span class="keyword">const</span> node = q.<span class="title function_">pop</span>();</span><br><span class="line">      <span class="keyword">if</span> (node.<span class="property">left</span> === <span class="literal">null</span> &amp;&amp; node.<span class="property">right</span> === <span class="literal">null</span>) <span class="keyword">return</span> deep;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (node.<span class="property">right</span>) queue.<span class="title function_">push</span>(node.<span class="property">right</span>);</span><br><span class="line">      <span class="keyword">if</span> (node.<span class="property">left</span>) queue.<span class="title function_">push</span>(node.<span class="property">left</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> deep;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%85%B3%E8%81%94%E9%A2%98%E7%9B%AE/" rel="tag">关联题目</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%AE%97%E6%B3%95/" rel="tag">算法</a></li></ul>

    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-algorithm/learn/二叉树"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/posts/6477f25bd014/"
    >二叉树</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/posts/6477f25bd014/" class="article-date">
  <time datetime="2021-01-19T03:09:56.000Z" itemprop="datePublished">2021-01-19</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E7%AE%97%E6%B3%95/">算法</a> / <a class="article-category-link" href="/categories/%E7%AE%97%E6%B3%95/%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E5%AD%A6/">常见算法与数学</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p>二叉树可以算是最基础的数据类型。</p>
<p>很多复杂的数据结构都是基于二叉树的，比如 红黑树（二叉搜索树）、多叉树、二叉堆、图、字典树、并查集、s 线段树 等等。</p>
<p>二叉树可以代表一种递归的思维方式,比如 回溯算法、BFS 算法、动态规划 本质上也是把具体问题抽象成树结构。</p>
<h4 id="树的概念"><a href="#树的概念" class="headerlink" title="树的概念"></a>树的概念</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">    1</span><br><span class="line">   / \</span><br><span class="line">  2   3</span><br><span class="line"> /   / \</span><br><span class="line">4   5   6</span><br><span class="line">   /     \</span><br><span class="line">  7       8</span><br></pre></td></tr></table></figure>

<ul>
<li><p>每个节点下方直接相连的节点称为<strong>子节点</strong>，上方直接相连的节点称为<strong>父节点</strong>。比方说节点 3 的父节点是 1，左子节点是 5，右子节点是 6；节点 5 的父节点是 3，左子节点是 7，没有右子节点。</p>
</li>
<li><p>我们称最上方那个没有父节点的节点 1 为<strong>根节点</strong>，称最下层没有子节点的节点 4、7、8 为<strong>叶子节点</strong>。</p>
</li>
<li><p>从根节点到最下方叶子节点经过的节点个数为二叉树的<strong>最大深度&#x2F;高度</strong>，上面这棵树的最大深度是 4，即从根节点 1 到叶子节点 7 或 8 的路径上的节点个数。</p>
</li>
<li><p>满二叉树: 每一层节点都是满的, 假设深度为 h，那么总节点数就是 <code>2^h - 1</code>。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">       1</span><br><span class="line">     /   \</span><br><span class="line">    2     3</span><br><span class="line">   / \   / \</span><br><span class="line">  4   9 5   6</span><br><span class="line"> / \ / \/ \ / \</span><br><span class="line">10 11 7 12 13 8 14</span><br></pre></td></tr></table></figure>
</li>
<li><p>完全二叉树： 二叉树的每一层的节点都紧凑靠左排列，且除了最后一层，其他每层都必须是满的, 满二叉树就是特殊的完全二叉树。也可以说 <strong>完全二叉树的左右子树也是完全二叉树。</strong> 或 <strong>完全二叉树的左右子树中，至少有一棵是满二叉树。</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">       1</span><br><span class="line">     /   \</span><br><span class="line">    2     3</span><br><span class="line">   / \   / \</span><br><span class="line">  4   9 5   6</span><br><span class="line"> / \ / \</span><br><span class="line">10 1 7 2</span><br></pre></td></tr></table></figure>
</li>
<li><p>二叉搜索树：对于树中的每个节点，其<strong>左子树的每个节点</strong>的值都要小于这个节点的值，<strong>右子树的每个节点</strong>的值都要大于这个节点的值。为左小右大的特性，可以让我们在 BST 中快速找到某个节点，或者找到某个范围内的所有节点，这是 BST 的优势所在。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    7</span><br><span class="line">   / \</span><br><span class="line">  4   9</span><br><span class="line"> / \   \</span><br><span class="line">1   8   10</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="遍历方式"><a href="#遍历方式" class="headerlink" title="遍历方式"></a>遍历方式</h4><h5 id="层序遍历"><a href="#层序遍历" class="headerlink" title="层序遍历"></a>层序遍历</h5><p>一层一层地遍历二叉树,显然先访问的节点需要先处理，而左右节点暂时用不到需要先存起来，自然想到用队列来处理。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> levelOrderTraverse = <span class="keyword">function</span> (<span class="params">root</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (root === <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">var</span> q = [];</span><br><span class="line">  q.<span class="title function_">push</span>(root);</span><br><span class="line">  <span class="keyword">while</span> (q.<span class="property">length</span> !== <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> cur = q.<span class="title function_">shift</span>();</span><br><span class="line">    <span class="comment">// 访问 cur 节点</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(cur.<span class="property">val</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 把 cur 的左右子节点加入队列</span></span><br><span class="line">    <span class="keyword">if</span> (cur.<span class="property">left</span> !== <span class="literal">null</span>) &#123;</span><br><span class="line">      q.<span class="title function_">push</span>(cur.<span class="property">left</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (cur.<span class="property">right</span> !== <span class="literal">null</span>) &#123;</span><br><span class="line">      q.<span class="title function_">push</span>(cur.<span class="property">right</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这种方式存在的问题就是不知道是第几层，因此可以使用额外的变量来记录。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> levelOrderTraverse = <span class="keyword">function</span> (<span class="params">root</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (root === <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> q = [];</span><br><span class="line">  q.<span class="title function_">push</span>(root);</span><br><span class="line">  <span class="comment">// 记录当前遍历到的层数（根节点视为第 1 层）</span></span><br><span class="line">  <span class="keyword">let</span> depth = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (q.<span class="property">length</span> !== <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> sz = q.<span class="property">length</span>;</span><br><span class="line">    <span class="comment">// 使用额外的变量，记录每层的节点个数</span></span><br><span class="line">    <span class="comment">// 也可以直接复制q队列，这样可以避免 shift 操作的O(n) 时间复杂度</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; sz; i++) &#123;</span><br><span class="line">      <span class="keyword">let</span> cur = q.<span class="title function_">shift</span>();</span><br><span class="line">      <span class="comment">// 访问 cur 节点，同时知道它所在的层数</span></span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;depth = &quot;</span> + depth + <span class="string">&quot;, val = &quot;</span> + cur.<span class="property">val</span>);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 把 cur 的左右子节点加入队列</span></span><br><span class="line">      <span class="keyword">if</span> (cur.<span class="property">left</span> !== <span class="literal">null</span>) &#123;</span><br><span class="line">        q.<span class="title function_">push</span>(cur.<span class="property">left</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (cur.<span class="property">right</span> !== <span class="literal">null</span>) &#123;</span><br><span class="line">        q.<span class="title function_">push</span>(cur.<span class="property">right</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    depth++;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>同理还可以添加更多的下信息，现在只知道整个树的层数，还可以为每个节点维护他的层数, 一般称作<strong>路径的权重</strong>，即从根节点到当前的节点。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">State</span>(<span class="params">node, depth</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">node</span> = node;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">depth</span> = depth;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> levelOrderTraverse = <span class="keyword">function</span> (<span class="params">root</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (root === <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// @visualize bfs</span></span><br><span class="line">  <span class="keyword">var</span> q = [];</span><br><span class="line">  <span class="comment">// 根节点的路径权重和是 1</span></span><br><span class="line">  q.<span class="title function_">push</span>(<span class="keyword">new</span> <span class="title class_">State</span>(root, <span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (q.<span class="property">length</span> !== <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> cur = q.<span class="title function_">shift</span>();</span><br><span class="line">    <span class="comment">// 访问 cur 节点，同时知道它的路径权重和</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;depth = &quot;</span> + cur.<span class="property">depth</span> + <span class="string">&quot;, val = &quot;</span> + cur.<span class="property">node</span>.<span class="property">val</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 把 cur 的左右子节点加入队列</span></span><br><span class="line">    <span class="keyword">if</span> (cur.<span class="property">node</span>.<span class="property">left</span> !== <span class="literal">null</span>) &#123;</span><br><span class="line">      q.<span class="title function_">push</span>(<span class="keyword">new</span> <span class="title class_">State</span>(cur.<span class="property">node</span>.<span class="property">left</span>, cur.<span class="property">depth</span> + <span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (cur.<span class="property">node</span>.<span class="property">right</span> !== <span class="literal">null</span>) &#123;</span><br><span class="line">      q.<span class="title function_">push</span>(<span class="keyword">new</span> <span class="title class_">State</span>(cur.<span class="property">node</span>.<span class="property">right</span>, cur.<span class="property">depth</span> + <span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="递归遍历"><a href="#递归遍历" class="headerlink" title="递归遍历"></a>递归遍历</h5><p>先深入到一个分支中，在逐层的返回。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 二叉树的遍历框架</span></span><br><span class="line"><span class="keyword">var</span> traverse = <span class="keyword">function</span> (<span class="params">root</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (root === <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 前序位置</span></span><br><span class="line">  <span class="title function_">traverse</span>(root.<span class="property">left</span>);</span><br><span class="line">  <span class="comment">// 中序位置</span></span><br><span class="line">  <span class="title function_">traverse</span>(root.<span class="property">right</span>);</span><br><span class="line">  <span class="comment">// 后序位置</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>但是在不同的位置写代码，获取到的信息是不同的，所谓的前中后，是相对于根节点的先后。</p>
<ul>
<li><p>前序遍历： 根节点 &#x3D;&gt; 左节点 &#x3D;&gt; 右节点， 代码位置写在接入左树之前，因此先访问根节点，在访问左树的根节点。对于一个子树，只有左子树遍历完成后，才回去处理右子树，可以看作是进入一个二叉树节点的时候执行</p>
</li>
<li><p>中序遍历： 左节点 &#x3D;&gt; 根节点 &#x3D;&gt; 右节点，代码会一直递归调用到左子树的左叶子节点，当左叶子节点访问完毕后，会弹出当前的调用栈，而上一个调用栈正是左节点的父节点，也就是根节点,可以看作是二叉树节点左子树都遍历完，即将开始遍历右子树的时候执行。</p>
</li>
<li><p>后序遍历： 左节点 &#x3D;&gt; 右节点 &#x3D;&gt; 根节点，代码会一直递归调用到左子树的右叶子节点，当左右子节点访问完毕后，会弹出当前的调用栈，而上一个调用栈正是右节点的父节点，也就是根节点,可以看作是离开一个二叉树节点的时候执行。</p>
</li>
</ul>
<p>而递归遍历常用于寻找最短路径， <a href="/posts/8e3fe34f62a9/"><strong>[二叉树最小&#x2F;大深度]</strong></a>, <a href="/posts/6a338e4e2cab/"><strong>[二叉树直径]</strong></a>,递归和遍历各有优势，遍历的思想是配合外部变量，递归则是将问题分解为子问题。</p>
<p>有一些问题虽然是在二叉树的遍历模型下，但是需要根据条件进入不同的分支处理，并在其中穿插其他的逻辑代码。 <a href="/posts/13ae1e52470a/"><strong>[二叉树展开为链表]</strong></a> <a href="/posts/0d16fafcd38e/"><strong>[填充每个节点的下一个右侧节点指针]</strong></a></p>
<h4 id="二叉树的序列化"><a href="#二叉树的序列化" class="headerlink" title="二叉树的序列化"></a>二叉树的序列化</h4><h5 id="层序遍历-1"><a href="#层序遍历-1" class="headerlink" title="层序遍历"></a>层序遍历</h5><p>这应该是最容易想到的一种方法，就像 LeetCode 题目给出的可视化数据一样，将每一层的数据依次放入到数组中，就可以对二叉树序列化，但是需要注意的是要保留空节点，这样才能描述每一层节点之间的关系</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> serialize = <span class="keyword">function</span> (<span class="params">root</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (root === <span class="literal">null</span>) <span class="keyword">return</span> [];</span><br><span class="line">  <span class="keyword">const</span> queue = [root];</span><br><span class="line">  <span class="keyword">const</span> res = [];</span><br><span class="line">  <span class="keyword">while</span> (queue.<span class="property">length</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> first = queue.<span class="title function_">shift</span>();</span><br><span class="line">    res.<span class="title function_">push</span>(first === <span class="literal">null</span> ? first : first.<span class="property">val</span>);</span><br><span class="line">    <span class="keyword">if</span> (first !== <span class="literal">null</span>) queue.<span class="title function_">push</span>(first.<span class="property">left</span>, first.<span class="property">right</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> deserialize = <span class="keyword">function</span> (<span class="params">data</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (data.<span class="property">length</span> === <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">let</span> index = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> root = <span class="keyword">new</span> <span class="title class_">TreeNode</span>(data[index++]);</span><br><span class="line">  <span class="keyword">let</span> queue = [root];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (data[index] !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> node = queue.<span class="title function_">shift</span>();</span><br><span class="line">    <span class="keyword">const</span> left = data[index++];</span><br><span class="line">    <span class="keyword">const</span> right = data[index++];</span><br><span class="line"></span><br><span class="line">    node.<span class="property">left</span> = left === <span class="literal">null</span> ? left : <span class="keyword">new</span> <span class="title class_">TreeNode</span>(left);</span><br><span class="line">    node.<span class="property">right</span> = right === <span class="literal">null</span> ? right : <span class="keyword">new</span> <span class="title class_">TreeNode</span>(right);</span><br><span class="line">    <span class="keyword">if</span> (left !== <span class="literal">null</span>) queue.<span class="title function_">push</span>(node.<span class="property">left</span>);</span><br><span class="line">    <span class="keyword">if</span> (right !== <span class="literal">null</span>) queue.<span class="title function_">push</span>(node.<span class="property">right</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> root;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="二叉树的唯一性"><a href="#二叉树的唯一性" class="headerlink" title="二叉树的唯一性"></a>二叉树的唯一性</h5> 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/" rel="tag">二叉树</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%AE%97%E6%B3%95/" rel="tag">算法</a></li></ul>

    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-devops/调试npm包"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/posts/61c0760886e4/"
    >调试npm包</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/posts/61c0760886e4/" class="article-date">
  <time datetime="2021-01-16T14:16:47.000Z" itemprop="datePublished">2021-01-16</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/DevOps/">DevOps</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h4 id="npm-x2F-yarn-link"><a href="#npm-x2F-yarn-link" class="headerlink" title="npm&#x2F;yarn link"></a>npm&#x2F;yarn link</h4><p>通过软链接使用第三方包</p>
<p>进入本地npm包文件夹，或通过 <code>git clone</code>拉去的第三方包文件夹 </p>
<p>执行 <code>yarn link</code> 或 <code>npm link</code> 连接到全局（yarn 不会污染全局）</p>
<p>在项目中使用 <code>yarn link [第三方包]</code>  或 <code>npm link [第三方包]</code></p>
<p>在项目中通过 <code>yarn unlink [第三方包]</code> 或 <code>npm unlink [第三方包]</code> 解除链接</p>
<p>通过一下命令去掉全局安装的包 </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm rm --<span class="variable language_">global</span> foo </span><br><span class="line">npm ls --<span class="variable language_">global</span> foo <span class="comment">// 检查包是否被安装</span></span><br></pre></td></tr></table></figure>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/DevOps/" rel="tag">DevOps</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/npm/" rel="tag">npm</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%B7%A5%E7%A8%8B%E5%8C%96/" rel="tag">工程化</a></li></ul>

    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-webpack/webpack核心概念"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/posts/dce700bcd907/"
    >webpack核心概念</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/posts/dce700bcd907/" class="article-date">
  <time datetime="2021-01-16T13:32:37.000Z" itemprop="datePublished">2021-01-16</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/webpack/">webpack</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><p>推荐就近安装，即安装在项目中，不要安装在全局中</p>
<p>通过 <code>npx webpack -v</code> 查看项目中 webpack 版本</p>
<p><strong>nrm 镜像源管理</strong></p>
<p><code>yarn add nrm</code></p>
<p>查看镜像源列表</p>
<p><code>nrm ls</code></p>
<p>测速</p>
<p><code>nrm test taobao</code></p>
<h4 id="常用工具"><a href="#常用工具" class="headerlink" title="常用工具"></a>常用工具</h4><h5 id="clean-webpack-plugin"><a href="#clean-webpack-plugin" class="headerlink" title="clean-webpack-plugin"></a>clean-webpack-plugin</h5><p><a target="_blank" rel="noopener" href="https://www.npmjs.com/package/clean-webpack-plugin">https://www.npmjs.com/package/clean-webpack-plugin</a></p>
<h4 id="source-map"><a href="#source-map" class="headerlink" title="source-map"></a>source-map</h4><p>cheap-module-source-map 用于生产环境，不能暴露源码</p>
<p>eval-cheap-module-source-map 开发环境中使用</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">devtool</span>:<span class="string">&#x27;cheap-module-source-map&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="devServer-和热模块更新"><a href="#devServer-和热模块更新" class="headerlink" title="devServer 和热模块更新"></a>devServer 和热模块更新</h4><p>安装devServer</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn add -D webpack-dev-server</span><br></pre></td></tr></table></figure>

<p>webpack.config.js 中添加配置项  </p>
<p>contentBase 只有需要在访问静态文件时候使用，默认下面三个配置项都可以不写</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">devServer</span>: &#123;</span><br><span class="line">  <span class="attr">contentBase</span>: path.<span class="title function_">join</span>(__dirname, <span class="string">&#x27;dist&#x27;</span>),</span><br><span class="line">  <span class="attr">compress</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">port</span>: <span class="number">9000</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>package.json 中添加启动命令</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;scripts&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;server&quot;</span><span class="punctuation">:</span> <span class="string">&quot;webpack-dev-server --open&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>开启hmr</p>
<p>1.配置webpack-dev-server<br>2.devServer配置hot:true<br>3.plugins hotModuleeReplaceMentPlugin<br>4.js 文件中添加hmr代码</p>
<p>webpack.config.js 中添加</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> webpack = <span class="built_in">require</span>(<span class="string">&#x27;webpack&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="attr">devServer</span>: &#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="attr">hot</span>:<span class="literal">true</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">plugins</span>: [</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">new</span> webpack.<span class="title class_">NamedModulesPlugin</span>(),</span><br><span class="line">    <span class="keyword">new</span> webpack.<span class="title class_">HotModuleReplacementPlugin</span>()</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>index.js 增加代码</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="variable language_">module</span>.<span class="property">hot</span>) &#123;</span><br><span class="line">  <span class="variable language_">module</span>.<span class="property">hot</span>.<span class="title function_">accept</span>(<span class="string">&#x27;./print.js&#x27;</span>, <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Accepting the updated printMe module!&#x27;</span>);</span><br><span class="line">   <span class="title function_">printMe</span>();</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="entry"><a href="#entry" class="headerlink" title="entry"></a>entry</h4><p><strong>string</strong> : 所有的资源打包成一个chunk,输出一个<code>bundle</code>文件，默认的名称是<code>main.js</code></p>
<p><strong>array</strong>: 多入口，所有的文件也只会被打包成一个<code>chunk</code>,通常只在配置html的HMR时使用</p>
<p><strong>object</strong> 多入口，有几个入口文件就可以形成几个<code>chunk</code>,输出几个<code>bundle</code>文件，文件的名称时对象中的<code>key</code>，每个key后面可以写一个数组，可以将数组中的文件打包成一个<code>bundle</code>,(参照dll的用法)</p>
<h4 id="output"><a href="#output" class="headerlink" title="output"></a>output</h4><p><strong>filename</strong> 输出的文件名称，可以指定目录和文件名 <code>js/[name].js</code></p>
<p><strong>publicpath</strong> 所有资源引入时候的公共路径，会拼在资源路径的前面作为基础路径， <code>publicpath:/</code>,<code>img/a.png</code> &#x3D;&gt; <code>/img/a.png</code>, <strong>注意：不是资源的输出路径</strong></p>
<p><strong>chunkFilename</strong> 非入口<code>chunk</code>的名称，通过动态<code>import</code>引入的文件名称通过id的形式命名，从0开始，依次递增，<strong>通常会使用<a target="_blank" rel="noopener" href="https://webpack.js.org/migrate/5/#using--webpackchunkname--">webpackchunkname</a>来重命名</strong></p>
<p><strong>library</strong> 会将<code>chunk</code>文件用一个变量接受，暴露给全局使用</p>
<p><strong>libraryTarget</strong> 指明以那种方式引入,<code>window</code>把输入的变量添加到浏览器全局环境<code>window[name]=xxx</code>, <code>global</code>把输入的变量添加到node全局环境<code>global[name]=xxx</code>,<code>commonjs</code>以commonjs模块化规范引入，通常配合<code>dll</code>使用 </p>
<p><strong>与 devserver 中的 publicpath 区别</strong></p>
<p><a target="_blank" rel="noopener" href="https://webpack.js.org/configuration/output/#outputpublicpath">output 中的 publicpath</a></p>
<p>这是一个在使用按需加载和引入外部资源（图片,文件等）非常重要的属性，如果设置了一个错误的值，当加载这些资源时会报404错误</p>
<p>这个配置项指定了输出目录在浏览器中引用时的公共路径（publicpath）,一个相对路径被解析为相对于HTML页面或<a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/HTML/Element/base">&lt;base&gt;标签</a></p>
<blockquote>
<base> 标签为页面上的所有链接规定默认地址或默认目标。
</blockquote>
<p>相对服务器的路径，相对与协议的路径，或绝对路径都是有可能的甚至有时是必须的，换句话说，在CDN 托管静态资源</p>
<p>在运行时或loader处理时，每一个URL的前缀都会被色设置配置项中的值，这就是为什么在很多例子中这个配置项被设置为 <code>/</code> 的原因</p>
<p>webpack-dev-server 也需要从publicPath获取信息，使用它来确定从何处提供输出文件。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  <span class="attr">output</span>: &#123;</span><br><span class="line">    <span class="comment">// One of the below</span></span><br><span class="line">    <span class="attr">publicPath</span>: <span class="string">&#x27;https://cdn.example.com/assets/&#x27;</span>, <span class="comment">// CDN (always HTTPS)</span></span><br><span class="line">    <span class="attr">publicPath</span>: <span class="string">&#x27;//cdn.example.com/assets/&#x27;</span>, <span class="comment">// CDN (same protocol)</span></span><br><span class="line">    <span class="attr">publicPath</span>: <span class="string">&#x27;/assets/&#x27;</span>, <span class="comment">// server-relative</span></span><br><span class="line">    <span class="attr">publicPath</span>: <span class="string">&#x27;assets/&#x27;</span>, <span class="comment">// relative to HTML page</span></span><br><span class="line">    <span class="attr">publicPath</span>: <span class="string">&#x27;../assets/&#x27;</span>, <span class="comment">// relative to HTML page</span></span><br><span class="line">    <span class="attr">publicPath</span>: <span class="string">&#x27;&#x27;</span>, <span class="comment">// relative to HTML page (same directory)</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://webpack.js.org/configuration/dev-server/#devserverpublicpath-">devServer 中的 publicpath</a></p>
<p>打包的文件可以在浏览器的这个目录下面得到</p>
<p>如果服务跑在 <a href="http://localhost:8080，打包的文件为bundle.js，publicPath为">http://localhost:8080，打包的文件为bundle.js，publicPath为</a> <code>/</code>, 可以在 <code>http://localhost:8080/bundle.js</code>访问到打包文件</p>
<p>如果 publicPath 改为 <code>/assets/</code>, 那么可以在 <code>http://localhost:8080/assets/bundle.js</code>访问，也可以把 publicPath 改为 <code>http://localhost:8080/assets/</code></p>
<p>这说明了 devServer.publicPath 与 output.publicPath 是一致的</p>
<h5 id="babel-x2F-polyfill-babel-x2F-plugin-transform-runtime-babel-x2F-runtime-corejs2"><a href="#babel-x2F-polyfill-babel-x2F-plugin-transform-runtime-babel-x2F-runtime-corejs2" class="headerlink" title="@babel&#x2F;polyfill  @babel&#x2F;plugin-transform-runtime @babel&#x2F;runtime-corejs2"></a>@babel&#x2F;polyfill  @babel&#x2F;plugin-transform-runtime @babel&#x2F;runtime-corejs2</h5><p>@babel&#x2F;preset-env 只会转换新语法，但是不会转换新的api,比如 <code>Array.from</code></p>
<p>需要 @babel&#x2F;polyfill 转换新的api,但是 @babel&#x2F;polyfill 会全量引入，不能按需引入</p>
<p>可以通过 <code>babel.rc</code> 配置文件来实现 </p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;presets&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">[</span></span><br><span class="line">      <span class="string">&quot;@babel/preset-env&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="comment">// This option was removed in v7 by just making it the default.在新版本中已经移除，无需添加</span></span><br><span class="line">      <span class="comment">// &#123;</span></span><br><span class="line">      <span class="comment">//   &quot;useBuiltIns&quot;: &quot;usage&quot;</span></span><br><span class="line">      <span class="comment">// &#125;</span></span><br><span class="line">    <span class="punctuation">]</span></span><br><span class="line">  <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>但是@babel&#x2F;preset-env也存在问题，虽然会按需引入但是每个文件如果有重复的方法，都会被编译成相同的代码引入，文件多的时候会让冗余的代码越来越多</p>
<p>@babel&#x2F;runtime-corejs2 是一个随着 <a target="_blank" rel="noopener" href="https://babeljs.io/docs/en/babel-plugin-transform-runtime">@babel&#x2F;plugin-transform-runtime</a> 一起时使用的运行时依赖，会把重复的函数覆盖为 @babel&#x2F;runtime-corejs2 中的引用</p>
<p>@babel&#x2F;runtime-corejs2 仅仅是一个包含着函数的包，把函数以模块化的形式引入, <strong>要安装到生产依赖中</strong></p>
<p>.babelrc</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;plugins&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">[</span></span><br><span class="line">      <span class="string">&quot;@babel/plugin-transform-runtime&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;corejs&quot;</span><span class="punctuation">:</span> <span class="number">3</span></span><br><span class="line">      <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">]</span></span><br><span class="line">  <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>


<h4 id="treeshaking"><a href="#treeshaking" class="headerlink" title="treeshaking"></a>treeshaking</h4><p>webpack4 production 默认开启，需要引入的库使用commonjs 模块化规范</p>
<p>如 loadsh-es</p>
<h4 id="全局引入"><a href="#全局引入" class="headerlink" title="全局引入"></a>全局引入</h4><p><a target="_blank" rel="noopener" href="https://webpack.js.org/plugins/provide-plugin/#root">provide-plugin</a></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">plugins</span>: [</span><br><span class="line">  <span class="keyword">new</span> webpack.<span class="title class_">ProvidePlugin</span>(&#123;</span><br><span class="line">    <span class="attr">$</span>: <span class="string">&#x27;jquery&#x27;</span>,</span><br><span class="line">  &#125;)</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>多入口文件的每一个都会被引入jquery，所以需要提取公共代码</p>
<h4 id="动态加载"><a href="#动态加载" class="headerlink" title="动态加载"></a>动态加载</h4><p><a target="_blank" rel="noopener" href="https://babeljs.io/docs/en/babel-plugin-syntax-dynamic-import">@babel&#x2F;plugin-syntax-dynamic-import</a></p>
<p><a target="_blank" rel="noopener" href="https://webpack.js.org/guides/code-splitting/#dynamic-imports">Dynamic Imports</a></p>
<p><strong>需要指明webpackChunkName才能被单独打包</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">import</span>(</span><br><span class="line">   <span class="comment">/* webpackChunkName: &quot;my-jquery&quot; */</span></span><br><span class="line">   <span class="string">&#x27;jquery&#x27;</span></span><br><span class="line"> )</span><br><span class="line">   .<span class="title function_">then</span>(<span class="function">(<span class="params">&#123; <span class="keyword">default</span>: $ &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">     <span class="variable language_">console</span>.<span class="title function_">log</span>($)</span><br><span class="line">     <span class="keyword">return</span> $(<span class="string">&#x27;body&#x27;</span>);</span><br><span class="line">   &#125;)</span><br></pre></td></tr></table></figure>

<h4 id="代码分割"><a href="#代码分割" class="headerlink" title="代码分割"></a>代码分割</h4><p><a target="_blank" rel="noopener" href="https://webpack.js.org/plugins/split-chunks-plugin/#root">SplitChunksPlugin</a> 代替原来的 commonChunksPlugin</p>
<ul>
<li>splitChunks.chunks</li>
</ul>
<p>async表示只从异步加载得模块（动态加载import()）里面进行拆分<br>initial表示只从入口模块进行拆分<br>all表示以上两者都包括</p>
<ul>
<li>splitChunks.maxInitialRequests</li>
</ul>
<p>每个入口的并发请求数, 如果拆出的包的个数大于maxInitialRequests，则不会把较小的包单独拆出</p>
<ul>
<li>splitChunks.maxInitialRequests</li>
</ul>
<p>动态引入的模块，最多拆分的数量</p>
<h4 id="css分割"><a href="#css分割" class="headerlink" title="css分割"></a>css分割</h4><p><a target="_blank" rel="noopener" href="https://webpack.js.org/plugins/css-minimizer-webpack-plugin/">css-minimizer-webpack-plugin</a></p>
<h4 id="压缩css代码"><a href="#压缩css代码" class="headerlink" title="压缩css代码"></a>压缩css代码</h4><p><a target="_blank" rel="noopener" href="https://webpack.js.org/plugins/mini-css-extract-plugin/#getting-started">MiniCssExtractPlugin</a></p>
<h4 id="可视化分析"><a href="#可视化分析" class="headerlink" title="可视化分析"></a>可视化分析</h4><p><a target="_blank" rel="noopener" href="https://www.npmjs.com/package/webpack-bundle-analyzer">webpack-bundle-analyzer</a></p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/webpack/" rel="tag">webpack</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%B7%A5%E7%A8%8B%E5%8C%96/" rel="tag">工程化</a></li></ul>

    </footer>
  </div>

   
    
</article>

    
  </article>
  

  
  <nav class="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/17/">上一页</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/16/">16</a><a class="page-number" href="/page/17/">17</a><span class="page-number current">18</span><a class="page-number" href="/page/19/">19</a><a class="page-number" href="/page/20/">20</a><span class="space">&hellip;</span><a class="page-number" href="/page/28/">28</a><a class="extend next" rel="next" href="/page/19/">下一页</a>
  </nav>
  
</section>
</div>

      <footer class="footer">
  <div class="outer">
    <ul>
      <li>
        Copyrights &copy;
        2015-2025
        <i class="ri-heart-fill heart_icon"></i> SunZhiqi
      </li>
    </ul>
    <ul>
      <li>
        
      </li>
    </ul>
    <ul>
      <li>
        
      </li>
    </ul>
    <ul>
      
    </ul>
    <ul>
      
    </ul>
    <ul>
      <li>
        <!-- cnzz统计 -->
        
      </li>
    </ul>
  </div>
</footer>    
    </main>
    <div class="float_btns">
      <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>

    </div>
    <aside class="sidebar on">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/ayer-side.png" alt="四月八日"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">归档</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories">分类</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags">标签</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="搜索">
        <i class="ri-search-line"></i>
      </a>
      
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>此时无声胜有声！</p>
  <div class="reward-box">
    
    <div class="reward-item">
      <img class="reward-img" src="/images/alipay.jpg">
      <span class="reward-type">支付宝</span>
    </div>
    
    
    <div class="reward-item">
      <img class="reward-img" src="/images/wechat.jpg">
      <span class="reward-type">微信</span>
    </div>
    
  </div>
</div>
    
<script src="/js/jquery-3.6.0.min.js"></script>
 
<script src="/js/lazyload.min.js"></script>

<!-- Tocbot -->

<script src="/js/jquery.modal.min.js"></script>
<link rel="stylesheet" href="/css/jquery.modal.min.css" />
<script src="/js/jquery.justifiedGallery.min.js"></script>

<script src="/dist/main.js"></script>

<!-- ImageViewer -->
 <!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">
  <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
  <div class="pswp__bg"></div>

  <!-- Slides wrapper with overflow:hidden. -->
  <div class="pswp__scroll-wrap">
    <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
    <div class="pswp__container">
      <div class="pswp__item"></div>
      <div class="pswp__item"></div>
      <div class="pswp__item"></div>
    </div>

    <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
    <div class="pswp__ui pswp__ui--hidden">
      <div class="pswp__top-bar">
        <!--  Controls are self-explanatory. Order can be changed. -->

        <div class="pswp__counter"></div>

        <button
          class="pswp__button pswp__button--close"
          title="Close (Esc)"
        ></button>

        <button
          class="pswp__button pswp__button--share"
          style="display: none"
          title="Share"
        ></button>

        <button
          class="pswp__button pswp__button--fs"
          title="Toggle fullscreen"
        ></button>

        <button
          class="pswp__button pswp__button--zoom"
          title="Zoom in/out"
        ></button>

        <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
        <!-- element will get class pswp__preloader--active when preloader is running -->
        <div class="pswp__preloader">
          <div class="pswp__preloader__icn">
            <div class="pswp__preloader__cut">
              <div class="pswp__preloader__donut"></div>
            </div>
          </div>
        </div>
      </div>

      <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
        <div class="pswp__share-tooltip"></div>
      </div>

      <button
        class="pswp__button pswp__button--arrow--left"
        title="Previous (arrow left)"
      ></button>

      <button
        class="pswp__button pswp__button--arrow--right"
        title="Next (arrow right)"
      ></button>

      <div class="pswp__caption">
        <div class="pswp__caption__center"></div>
      </div>
    </div>
  </div>
</div>

<link rel="stylesheet" href="/css/photoswipe.min.css" />
<link rel="stylesheet" href="/css/default-skin.min.css" />
<script src="/js/photoswipe.min.js"></script>
<script src="/js/photoswipe-ui-default.min.js"></script>

<script>
  function viewer_init() {
    let pswpElement = document.querySelectorAll(".pswp")[0];
    let $imgArr = document.querySelectorAll(
      ".article-entry img:not(.reward-img)"
    );

    $imgArr.forEach(($em, i) => {
      $em.onclick = () => {
        // slider展开状态
        // todo: 这样不好，后面改成状态
        if (document.querySelector(".left-col.show")) return;
        let items = [];
        $imgArr.forEach(($em2, i2) => {
          let img = $em2.getAttribute("data-idx", i2);
          let src =
            $em2.getAttribute("data-target") || $em2.getAttribute("src");
          let title = $em2.getAttribute("alt");
          // 获得原图尺寸
          const image = new Image();
          image.src = src;
          items.push({
            src: src,
            w: image.width || $em2.width,
            h: image.height || $em2.height,
            title: title,
          });
        });
        var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
          index: parseInt(i),
        });
        gallery.init();
      };
    });
  }
  viewer_init();
</script>
 
<!-- MathJax -->
 <script type="text/x-mathjax-config">
  MathJax.Hub.Config({
      tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
  });

  MathJax.Hub.Queue(function() {
      var all = MathJax.Hub.getAllJax(), i;
      for(i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
      }
  });
</script>

<script src="/js/MathJax.js"></script>
<script src="/js/TeX-AMS-MML_HTMLorMML-full.js"></script>

<script>
  var ayerConfig = {
    mathjax: true,
  };
</script>

<!-- Katex -->

<!-- busuanzi  -->

<!-- ClickLove -->

<!-- ClickBoom1 -->

<!-- ClickBoom2 -->

<!-- CodeCopy -->
 
<link rel="stylesheet" href="/css/clipboard.css">
 <script src="/js/clipboard.min.js"></script>
<script>
  function wait(callback, seconds) {
    var timelag = null;
    timelag = window.setTimeout(callback, seconds);
  }
  !(function (e, t, a) {
    var initCopyCode = function () {
      var copyHtml = "";
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="ri-file-copy-2-line"></i><span>COPY</span>';
      copyHtml += "</button>";
      $(".highlight .code pre").before(copyHtml);
      $(".article pre code").before(copyHtml);
      var clipboard = new ClipboardJS(".btn-copy", {
        target: function (trigger) {
          return trigger.nextElementSibling;
        },
      });
      clipboard.on("success", function (e) {
        let $btn = $(e.trigger);
        $btn.addClass("copied");
        let $icon = $($btn.find("i"));
        $icon.removeClass("ri-file-copy-2-line");
        $icon.addClass("ri-checkbox-circle-line");
        let $span = $($btn.find("span"));
        $span[0].innerText = "COPIED";

        wait(function () {
          // 等待两秒钟后恢复
          $icon.removeClass("ri-checkbox-circle-line");
          $icon.addClass("ri-file-copy-2-line");
          $span[0].innerText = "COPY";
        }, 2000);
      });
      clipboard.on("error", function (e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass("copy-failed");
        let $icon = $($btn.find("i"));
        $icon.removeClass("ri-file-copy-2-line");
        $icon.addClass("ri-time-line");
        let $span = $($btn.find("span"));
        $span[0].innerText = "COPY FAILED";

        wait(function () {
          // 等待两秒钟后恢复
          $icon.removeClass("ri-time-line");
          $icon.addClass("ri-file-copy-2-line");
          $span[0].innerText = "COPY";
        }, 2000);
      });
    };
    initCopyCode();
  })(window, document);
</script>
 
<!-- CanvasBackground -->

<script>
  if (window.mermaid) {
    mermaid.initialize({ theme: "default" });
  }
</script>


    
    

  </div>
</body>

</html>