---
layout: posts
title: 适配器模式-外观模式
mathjax: true
date: 2023-01-13 12:53:16
categories:
  - 设计模式
tags:
  - 设计模式
---

#### 适配器模式

适配器就像是转换国内充电器和香港充电器的插座一样，能让原本可以使用的插座在另一个地方也能正常使用。

而转换的过过程中，并没有修改原有插座的功能，只是将他的功能进行转换，这也是适配器的核心逻辑，有别于外观模式，和之前的装饰者模式。

**适配器模式：将一个类的接口，转换为消费方期望的另一个接口。适配器让原本不兼容的类可以正常使用。**， 而装饰着模式通常为类提供额外的功能接口，已达到增强类的目的。

真实的场景中适配器模式可以适配对象或类。

**通常对类的扩展操作会考虑继承，但是 JS 中的扩展方式很灵活，也可以通过函数的形式对对象或类进行操作。**

通过一个适配器，为对象实现 iterator

```ts
const obj = {
  a: 1,
  b: 2,
};

const objIteratorAdapter = (
  obj: Record<string, any>
): Record<string, any> & { [Symbol.iterator]: () => any } => {
  const iterator = (): { next: () => any } => {
    let keys = Object.keys(obj);
    let index = 0;
    return {
      next() {
        return index < keys.length
          ? {
              value: obj[keys[index++]],
              done: false,
            }
          : {
              value: undefined,
              done: true,
            };
      },
    };
  };
  const iteratorObj = Object.create(obj, {
    [Symbol.iterator]: {
      value: iterator,
      writable: false,
      enumerable: false,
      configurable: false,
    },
  });

  return iteratorObj;
};

const newObj = objIteratorAdapter(obj);
for (let i of newObj) {
  console.log(i);
}
```

#### 外观模式

**外观模式提供了统一的接口，用来访问子系统中的一群接口。外观定义了一个高层接口，让子系统的接口更容易使用。**

外观模式并不会封装新的功能，而是封装了一段子系统的接口。

虽然外观模式定义简单，但是引出了一个设计理念， **最少知识原则，只和你的密友谈话。**

在对象的方法调用中，应该遵循几个原则：

- 调用该对象本身的方法
- 调用当作参数出入对象中的方法
- 调用通过此方法创建或实例化对象中的方法
- 调用对象实例中引用的对象中的方法
