---
layout: posts
title: ④隐藏new操作符-工厂模式
mathjax: true
date: 2023-01-04 09:36:43
categories:
  - 设计模式
tags:
  - 设计模式
---

#### new 有什么不对

对 new 本身来讲并没有什么不对，需要通过 new 操作符实例化我么的对象。但是对于设计模式来讲，new 操作符让我们针对业务编写代码，初始化的逻辑可能在一段条件语句中，如果添加了新的类，必须修改原来的代码。也就是说我们代码没有对修改关闭。

#### 简单工厂

一个最简单的工厂就是把实例化对象的过程提取出来，单独放到一个工厂类中，并暴露方法，允许第三方类通过这个方法实例化对象。

```ts
class SomeFactory {
  public createSomeInstance() {
    // 用于实例化对象
    if (type == "apple") {
      return new Apple();
    } else if (type == "orange") {
      return new Orange();
    }
  }
}
```

这就已经实现了最简单的工厂模式，但这更像是代码编写习惯，抽取一些公用的代码，还有一种写法是把他写成静态方法，这更像是函数式编程，但坏处是不能继承对原有的对象扩展。

#### 工厂方法模式

简单工厂有不能覆盖的场景，如果在不同的地区 Apple 和 Orange 的实现细节不一样，也就是说他们可能实现了相同的接口，但是表现的行为不一样，这对于简单工厂或者说对于这种代码编写风格来说是处理不了的，因为在工厂类中已经明确了创建的行为。

所以在工厂方法中把工厂设计成一个抽象类，不同的场景会实现不同的工厂子类，在用对应的工厂类去实例化对象

```ts
abstract class FruitFactory {
  // 抽象工厂类的公用方法
  common() {}
  // 需要子类重新实现
  abstract makeTea(): void;
}

class Apple extends FruitFactory {
  // 水果味道
  taste() {
    console.log("苹果很甜");
  }
  public makeTea(): void {
    console.log("制作苹果茶");
    this.taste();
  }
}
class Orange extends FruitFactory {
  // 水果味道
  taste() {
    console.log("苹果很甜");
  }
  public makeTea(): void {
    console.log("制作橘子茶");
    this.taste();
  }
}

class FruitStore {
  factory: FruitFactory;
  constructor(factory: FruitFactory) {
    this.factory = factory;
  }
  makeFruitTea() {
    this.factory.makeTea();
  }
}

const store = new FruitStore(new Apple());
store.makeFruitTea();
```

**工厂方法模式： 定义了一个创建对象的接口，但由子类决定要实例化的类是哪一个的，工厂方法让类把实例化推迟到子类。**

#### 依赖倒置与抽象工厂

**依赖倒置原则：要依赖抽象，不要依赖具体类**，这句话很像是要面向接口编程，而不是具体的类。没错，但是这句话更强调，高层的组件不应该依赖低层的组件，而是应该两者都依赖于 **抽象**。抽象可以是接口，也可以是抽象类。

**抽象工厂模式：提供一个接口，用于创建相关或依赖对象的家族，而不需要明确指定具体类**。
