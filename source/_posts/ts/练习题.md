---
layout: posts
date: 2022-04-07 18:42:52
title: TypeScript 练习题
categories:
  - TypeScript
tags:
  - TypeScript
---

[^_^]: ①②③④⑤⑥⑦⑧⑨⑩⑪⑫⑬⑭⑮⑯⑰⑱⑲⑳㉑㉒㉓㉔㉕㉖㉗㉘㉙㉚㉛㉜㉝㉞㉟㊱㊲㊳㊴㊵㊶㊷㊸㊹㊺㊻㊼㊽㊾㊿

① [实现 Pick](#实现-Pick)
② [实现 Readonly](#实现-Readonly)
③ [元组转换为对象](#元组转换为对象)
④ [第一个元素](#第一个元素)
⑤ [实现 Exclude](#实现-Exclude)
⑥ [Promise 返回值类型](#Promise-返回值类型)
⑦ [实现 Array.Concat](#实现-Array-Concat)
⑧ [实现 Array.includes](#实现-Array-includes)
⑨ [实现 Parameters](#实现-Parameters)
⑩ [实现 ReturnType](#实现-ReturnType)
⑪ [实现 Omit](#实现-Omit)
⑫ [Pick Readonly](#Pick-Readonly)
⑬ [Deep Readonly](#Deep-Readonly)
⑭ [链式调用的类型](#链式调用的类型)
##### 实现 Pick

```ts
type Pick<T, K extends keyof T> = {
  [P in K]: T[P];
};
```

利用 [keyof](https://www.typescriptlang.org/docs/handbook/2/keyof-types.html) 将对象类型转换成键值的联合类型

利用 [extends](https://www.typescriptlang.org/docs/handbook/2/conditional-types.html) 进行泛型约束, K 可以分配给 T, 表示 K 是 T 的子集.

利用 [in](https://www.typescriptlang.org/docs/handbook/2/narrowing.html#the-in-operator-narrowing) 运算符,遍历联合类型

##### 实现 Readonly

```ts
type Readonly<T> = {
  readonly [P in keyof T]: T[P];
};
```

##### 元组转换为对象

```ts
const tuple = ["tesla", "model 3", "model X", "model Y"] as const;

type TupleToObject<T extends readonly any[]> = {
  [K in T[number]]: K;
};

type result = TupleToObject<typeof tuple>;
// expected { tesla: 'tesla', 'model 3': 'model 3', 'model X': 'model X', 'model Y': 'model Y'}
```

因为 [in](https://www.typescriptlang.org/docs/handbook/2/narrowing.html#the-in-operator-narrowing) 运算符可以遍历联合类型,所以把元组 T 转换成联合类型,在进行遍历

##### 第一个元素

实现一个通用 First<T>，它接受一个数组 T 并返回它的第一个元素的类型。

```ts
type arr2 = [3, 2, 1];

type First<T extends readonly any[]> = T[0];

type First<T extends readonly any[]> = T extends [infer F, ...infer R]
  ? F
  : never;

type head1 = First<arr1>; // expected to be 'a'
```

利用条件语句中 [infer](https://www.typescriptlang.org/docs/handbook/2/conditional-types.html#inferring-within-conditional-types) 类型推断,返回第一个元素所代表的类型

##### 实现 Exclude

Exclude 的用法是从联合类型中,排除指定的属性

```ts
type Exclude<T, U> = T extends U ? never : T;
```

[extends](https://www.typescriptlang.org/docs/handbook/2/conditional-types.html) 条件类型, T 是否能分配给 U, 会去拿 T 中的每一项与 U 进行匹配, 如果当前项可以分配,表示 U 中存在这种类型,需要排除,所以返回 never. 如果不存在则返回这一项的类型.

##### Promise 返回值类型

```ts
type Awaited<T extends Promise<any>> = T extends Promise<infer R> ? R : T;
```

##### 实现 Array.Concat

```ts
type Concat<T extends any[], U extends any[]> = [...T, ...U];
```

##### 实现 Array.includes

```ts
type Includes<T extends any[], U> = U extends T[number] ? true : false;
```

利用 [extends](https://www.typescriptlang.org/docs/handbook/2/conditional-types.html) 条件类型可以进行联合类型的判断,, 首先吧元组转换为联合类型, 如果类型可分配表示 U 存在与元组中.

##### 实现 Parameters

Parameters 作用是用于获得函数的参数类型组成的元组类型。

```ts
type Parameters<T extends (...args: any) => any> = T extends (
  ...args: infer P
) => any
  ? P
  : never;
```

##### 实现 ReturnType

```ts
type ReturnType<T extends (...args: any) => any> = T extends (
  ...args: any
) => infer R
  ? R
  : any;
```

##### 实现 Omit

```ts
type Omit<T, K extends keyof any> = Pick<T, Exclude<keyof T, K>>;
```

##### Pick Readonly

指定属性 ReadOnly

```ts
type PickReadonly<T, K extends keyof T = keyof T> = {
  [Key in Exclude<keyof T, K>]: T[Key];
} & {
  readonly [Key in K]: T[Key];
};

interface Todo {
  title: string
  description: string
  completed: boolean
}

const todo: MyReadonly2<Todo, 'title' | 'description'> = {
  title: "Hey",
  description: "foobar",
  completed: false,
}

todo.title = "Hello" // Error: cannot reassign a readonly property
todo.description = "barFoo" // Error: cannot reassign a readonly property
todo.completed = true // OK
```

##### Deep Readonly

```ts
type X = { 
  x: { 
    a: 1
    b: 'hi'
  }
  y: 'hey'
}

type DeepReadonly<T> = {
  readonly [K in keyof T]: T[K] extends object ? DeepReadonly<T[K]> : T[K];
};

type Todo = DeepReadonly<X> // should be same as `Expected`

type Expected = { 
  readonly x: { 
    readonly a: 1
    readonly b: 'hi'
  }
  readonly y: 'hey' 
}
```

##### 链式调用的类型

假设 key 只接受字符串而 value 接受任何类型，你只需要暴露它传递的类型而不需要进行任何处理。同样的 key 只会被使用一次。

```ts

type Chainable<T = {}> = {
  option: <K extends string, V>(k: K, v: V) => Chainable<T & { [P in K]: V }>;
  get: () => T;
};

declare const config: Chainable

const result = config
  .option('foo', 123)
  .option('name', 'type-challenges')
  .option('bar', { value: 'Hello World' })
  .get()

// 期望 result 的类型是：
interface Result {
  foo: number
  name: string
  bar: {
    value: string
  }
}
```

