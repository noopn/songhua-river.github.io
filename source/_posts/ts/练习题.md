---
layout: posts
date: 2022-04-07 18:42:52
title: TypeScript 练习题
categories:
  - TypeScript
tags:
  - TypeScript

---

[^_^]: ①②③④⑤⑥⑦⑧⑨⑩⑪⑫⑬⑭⑮⑯⑰⑱⑲⑳㉑㉒㉓㉔㉕㉖㉗㉘㉙㉚㉛㉜㉝㉞㉟㊱㊲㊳㊴㊵㊶㊷㊸㊹㊺㊻㊼㊽㊾㊿

① [实现 Pick](#实现-Pick)
② [实现 Readonly](#实现-Readonly)
③ [元组转换为对象](#元组转换为对象)
④ [第一个元素](#第一个元素)
⑤ [实现 Exclude](#实现-Exclude)
⑥ [Promise 返回值类型](#Promise-返回值类型)
⑦ [实现 Array.Concat](#实现-Array-Concat)
⑧ [实现 Array.includes](#实现-Array-includes)
⑨ [实现 Parameters](#实现-Parameters)



##### 实现 Pick

```ts
type Pick<T, K extends keyof T> = {
    [P in K]: T[P];
};
```

利用 [keyof](https://www.typescriptlang.org/docs/handbook/2/keyof-types.html) 将对象类型转换成键值的联合类型

利用 [extends](https://www.typescriptlang.org/docs/handbook/2/conditional-types.html) 进行泛型约束, K 可以分配给 T, 表示 K 是 T 的子集.

利用 [in](https://www.typescriptlang.org/docs/handbook/2/narrowing.html#the-in-operator-narrowing) 运算符,遍历联合类型

##### 实现 Readonly

```ts
type Readonly<T> = {
    readonly [P in keyof T]: T[P];
};
```

##### 元组转换为对象

```ts
const tuple = ['tesla', 'model 3', 'model X', 'model Y'] as const

type TupleToObject<T extends readonly any[]> = {
  [K in T[number]]:K
}

type result = TupleToObject<typeof tuple> 
// expected { tesla: 'tesla', 'model 3': 'model 3', 'model X': 'model X', 'model Y': 'model Y'}
```

因为 [in](https://www.typescriptlang.org/docs/handbook/2/narrowing.html#the-in-operator-narrowing) 运算符可以遍历联合类型,所以把元组 T 转换成联合类型,在进行遍历



##### 第一个元素

实现一个通用First<T>，它接受一个数组T并返回它的第一个元素的类型。

```ts
type arr2 = [3, 2, 1]

type First<T extends readonly any[]> = T[0];

type First<T extends readonly any[]> = T extends [infer F,...infer R] ? F:never;

type head1 = First<arr1> // expected to be 'a'
```

利用条件语句中 [infer](https://www.typescriptlang.org/docs/handbook/2/conditional-types.html#inferring-within-conditional-types) 类型推断,返回第一个元素所代表的类型

##### 实现 Exclude

Exclude 的用法是从联合类型中,排除指定的属性

```ts
type Exclude<T, U> = T extends U ? never : T;
```

[extends](https://www.typescriptlang.org/docs/handbook/2/conditional-types.html) 条件类型, T 是否能分配给 U, 会去拿 T 中的每一项与 U 进行匹配, 如果当前项可以分配,表示 U 中存在这种类型,需要排除,所以返回never. 如果不存在则返回这一项的类型.


##### Promise 返回值类型

```ts
type Awaited<T extends Promise<any>> = T extends Promise<infer R> ? R: T;
```

##### 实现 Array.Concat

```ts
type Concat<T extends any[],U extends any[]> = [...T,...U];
```

##### 实现 Array.includes

```ts
type Includes<T extends any[],U> = U extends T[number]?true:false; 
```

利用 [extends](https://www.typescriptlang.org/docs/handbook/2/conditional-types.html) 条件类型可以进行联合类型的判断,, 首先吧元组转换为联合类型, 如果类型可分配表示 U 存在与元组中.

#### 实现 Parameters

Parameters 作用是用于获得函数的参数类型组成的元组类型。

```ts
type Parameters<T extends (...args: any) => any> = T extends (...args: infer P) => any ? P : never;
```

