---
title: 点与线
mathjax: true
abbrlink: 528ec8a7
date: 2021-09-18 17:50:58
categories:
  - ThreeJS
tags:
  - ThreeJS
  - 动画
  - 3D
---


#### 点

ThreeJS 提供了一个构造函数用于创建点 [THREE.Vector3](https://threejs.org/docs/index.html?q=Vector3#api/zh/math/Vector3), Vector 的本意是向量的意思，但是向量在数学上可以有很多意义，其中一个就是表示点。

```javascript
const point = new THREE.Vector3(0,0,0);
```

[渲染一个立方体中](/posts/e875caf9/) 通过`THREE.BoxGeometry`创建了一个立方体，同样这里提供了[`THREE.BufferGeometry`](https://threejs.org/docs/index.html?q=Geometry#api/zh/core/BufferGeometry) 这个构造函数，它可以用来描述 点，线，面。

```javascript
const geometry = new THREE.BufferGeometry();
```

有了几何体，接下来就需要把点加入到几何体中，单独的点是不能用于渲染的，他只是一个点的描述。在最新的版本中可以使用`setAttribute`方法来将点加入到几何体中。

```javascript
geometry.setAttribute( 'position', new THREE.Float32BufferAttribute( point.toArray(), 3 ) );
```

下面就是纹理了，点同样用专属的创建纹理的方法

```javascript
const material = new THREE.PointsMaterial( { color: 'red' } );
```

这个例子中我们用了两个相机相关的方法，设置了一下相机的位置，等价于之前见到的`camera.position.z = 5;` 并且设置了相机的朝向，完整的代码为：

```javascript
import * as THREE from './js/three.module.js';
import './style/main.scss';

const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);

const renderer = new THREE.WebGLRenderer();
renderer.setSize( window.innerWidth, window.innerHeight );
document.body.appendChild( renderer.domElement );

camera.position.set( 0, 0, 100 );
camera.lookAt( 0, 0, 0 );

const point = new THREE.Vector3(0,0,0);

const geometry = new THREE.BufferGeometry();

geometry.setAttribute( 'position', new THREE.Float32BufferAttribute( point.toArray(), 3 ) );

const material = new THREE.PointsMaterial( { color: 'red' } );

const points = new THREE.Points( geometry, material );

scene.add( points );

const animate = function () {
    requestAnimationFrame(animate);
    renderer.render(scene, camera);
};

animate();
```


#### 线

线可以用两个点来表示，这是最基本的数学定理。另外关于创建几何体，材质，我们已经轻车熟路了。下面就是如何将两个点和几何体关联起来，可以调用 [`THREE.setFromPoints`](https://threejs.org/docs/index.html?q=BufferGeometry#api/zh/core/BufferGeometry.setFromPoints) 通过点队列来描述一条直线

另外画线的时候，点于点之间会自动相连变成直线，但是收尾点不会相连，所以一个闭合的三角型需要4个点来实现闭合。

```javascript
const point1 = new THREE.Vector3(0,0,0);
const point2 = new THREE.Vector3(0,10,0);
const points = [point1,point2];
const geometry = new THREE.BufferGeometry()
geometry.setFromPoints( points );
const material = new THREE.LineBasicMaterial({
	color: 0xffffff,
});
```

如果想让直线的颜色从一个点渐变到另一个点，可以在几何体上添加颜色的属性，并且开启[vertexColors](https://threejs.org/docs/index.html#api/zh/materials/Material.vertexColors)

需要注意的是，颜色适合点一一对应的，两个点之间的颜色会渐变，如果想在一条直线上有多个颜色渐变，需要添加多个点

```javascript
import * as THREE from './js/three.module.js';
import './style/main.scss';

const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);

const renderer = new THREE.WebGLRenderer();
renderer.setSize( window.innerWidth, window.innerHeight );
document.body.appendChild( renderer.domElement );

camera.position.set( 0, 0, 100 );
camera.lookAt( 0, 0, 0 );

const point1 = new THREE.Vector3(0,0,0);
const point2 = new THREE.Vector3(0,10,0);
const point3 = new THREE.Vector3(10,10,0);

const points = [point1,point2,point3];

const colors = new Float32Array([
    1.0, 0.0, 0.0,  // red (normalized)
    1.0, 1.0, 0.0,  // yellow (normalized)
    0.0, 0.0, 1.0,  // blue (normalized)
]);

const material = new THREE.LineBasicMaterial({
    vertexColors: THREE.VertexColors
});

const geometry = new THREE.BufferGeometry()
geometry.setFromPoints( points );
geometry.addAttribute('color',new THREE.BufferAttribute(colors,3))

const line = new THREE.Line( geometry, material );

scene.add( line );

const animate = function () {
    requestAnimationFrame(animate);
    renderer.render(scene, camera);
};

animate();
```

#### 画一个网格

画一个 200 * 200 的网格，每条线之间的距离为10

```javascript
const color = new THREE.Color('skyblue');
const material = new THREE.LineBasicMaterial({ color });

for (let i = 0; i <= 20; i++) {
    const geometryH = new THREE.BufferGeometry()
    geometryH.setFromPoints([
        new THREE.Vector3(-100, 100 - 10 * i, 0),
        new THREE.Vector3(100, 100 - 10 * i, 0),
    ]);
    const geometryV = new THREE.BufferGeometry()
    geometryV.setFromPoints([
        new THREE.Vector3(-100 + 10 * i, 100, 0),
        new THREE.Vector3(-100 + 10 * i, -100, 0),
    ]);
    const lineH = new THREE.Line(geometryH, material);
    const lineV = new THREE.Line(geometryV, material);
    scene.add(lineH);
    scene.add(lineV);
}
```

谁让上面的代码可以实现，但是每条线都创建了一个几何体的实例，可以考虑只用一个几何体，然后将创建的线平移到所在的位置，提高渲染的性能，完整的代码为:

```javascript
import * as THREE from './js/three.module.js';
import './style/main.scss';

const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);

const renderer = new THREE.WebGLRenderer();
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

camera.position.set(0, 0, 200);
camera.lookAt(0, 0, 0);


const color = new THREE.Color('skyblue');
const material = new THREE.LineBasicMaterial({ color });
const geometry = new THREE.BufferGeometry()
geometry.setFromPoints([
    new THREE.Vector3(0,100,0),
    new THREE.Vector3(0,-100,0),
]);

for (let i = 0; i <= 20; i++) {
    const lineV = new THREE.Line(geometry, material);
    lineV.position.x = -100 + 10 * i;
    const lineH = new THREE.Line(geometry, material);
    lineH.rotation.z = 90 * Math.PI / 180;
    lineH.position.y = 100 - 10 * i;

    scene.add(lineH);
    scene.add(lineV);
}

const animate = function () {
    requestAnimationFrame(animate);
    renderer.render(scene, camera);
};

animate();
```