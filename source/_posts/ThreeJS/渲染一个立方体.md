---
title: 渲染一个立方体
mathjax: true
categories:
  - ThreeJS
tags:
  - ThreeJS
  - 动画
  - 3D
abbrlink: e875caf9
date: 2021-09-18 15:19:56
---

#### 环境搭建

我们通过 webpack 来搭建一个开发服务器，它能让我们用最新的 ES6 语法开发，并且帮助我们在开发结束后，将代码打包并兼容旧版本的语法。

`package.json`

```javascript
{
  "name": "threeDev",
  "version": "1.0.0",
  "description": "",
  "main": "index.js",
  "scripts": {
    "build": "webpack --mode=production",
    "dev": "webpack-dev-server --mode=development"
  },
  "keywords": [],
  "author": "",
  "license": "ISC",
  "devDependencies": {
    "@babel/core": "^7.15.5",
    "@babel/plugin-transform-runtime": "^7.15.0",
    "@babel/preset-env": "^7.15.6",
    "babel": "^6.23.0",
    "babel-core": "^6.26.3",
    "babel-loader": "^8.2.2",
    "css-loader": "^6.2.0",
    "html-webpack-plugin": "^5.3.2",
    "sass": "^1.41.1",
    "sass-loader": "^12.1.0",
    "style-loader": "^3.2.1",
    "webpack": "^5.53.0",
    "webpack-cli": "^4.8.0",
    "webpack-dev-server": "^4.2.1"
  }
}
```

`webpack.config.js`

由于使用了 scss 样式文件，所以引入了 `sass-loader`,另外`babel-loader`用于转换新版本语法

```javascript
const HtmlWebpackPlugin = require('html-webpack-plugin');
const path = require('path');

module.exports = {
  entry: './src/index.js',
  output: {
    path: path.resolve(__dirname, './dist'),
    filename: 'three.[contenthash:6].js',
    clean: true,
  },
  module: {
    rules: [
      {
        test: /\.m?js$/,
        exclude: /node_modules/,
        use: {
          loader: "babel-loader",
        }
      },
      {
        test: /\.s[ac]ss$/i,
        use: [
          'style-loader',
          'css-loader',
          'sass-loader',
        ]
      }
    ]
  },
  devServer: {
    static: {
      directory: path.join(__dirname, 'public'),
    },
    compress: true,
    open:true,
    port: 9000,
  },
  plugins: [new HtmlWebpackPlugin()],
};
```

`.babelrc` 

需要注意的是我们需要引入 `@babel/plugin-transform-runtime` 来帮助我们转化新版本语法的Api, 因为默认babel只会帮助转换新版本语法。

```javascript
{
    "presets": [
        [
            "@babel/preset-env"
        ]
    ],
    "plugins": ["@babel/plugin-transform-runtime"]
}
```

配置完成之后我们把，在从git上拉取的官方的项目中，找到`build`文件夹， 把我们需要用到的文件 (`three.module.js`), 拷贝到我们的项目文件中，最终我们的项目目录结构为：

![](0001.png)

#### 创建一个场景

就像小说的三要素（时间，地点，人物）一样，一个场景也需要三个必要因素，分别是**场景、相机和渲染器**。

ThreeJS 已经为我们提供了封装好的方法，可以方便调用，只不过需要我们在调用的时候传入一些参数。

**创建场景**

```javascript
const scene = new THREE.Scene();
```

**创建相机**

```javascript
const camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 0.1, 1000 );
```

three.js里有几种不同的相机，在这里，我们使用的是PerspectiveCamera（透视摄像机），近大远小。另一种是正投影相机，远近的物体都保持一样的大小。

第一个属性是视野角度（FOV）。视野角度就是无论在什么时候，你所能在显示器上看到的场景的范围，它的值是一个角度。可以理解成汽车的驾驶室，左侧视线和右侧视线夹角范围内所能看见的东西，当在狭窄的山谷里行驶，会感觉看不远，周边被遮挡，一般说是视野狭窄，当在开阔的草原行驶，感觉看的很远，一般也称为视野开阔，但这是感官上的描述，实际上我们的视野角度没有变化，只是我们看到的场景中的内容有变化，所以视野角度也是位置无关的一个值。

第二个值是长宽比（aspect ratio）。 也就是你用一个物体的宽除以它的高的比值。比如说，当你在一个宽屏电视上播放老电影时，可以看到图像仿佛是被压扁的。

接下来的两个值是远剪切面和近剪切面。 也就是说当物体所在的位置比摄像机的远剪切面远或者所在位置比近剪切面近的时候，该物体超出的部分将不会被渲染到场景中。现在你或许并不用担心这个值的影响，但未来为了获得更好的渲染性能，你将可以在你的应用程序里去设置它。

**创建渲染器**

```javascript
const renderer = new THREE.WebGLRenderer();
renderer.setSize( window.innerWidth, window.innerHeight );
document.body.appendChild( renderer.domElement );
```

除了我们在这里用到的WebGLRenderer渲染器之外，Three.js同时提供了其他几种渲染器，当用户所使用的浏览器过于老旧，或者由于其他原因不支持WebGL时，可以使用这几种渲染器进行降级。

除了创建一个渲染器的实例之外，我们还需要在我们的应用程序里设置一个渲染器的大小尺寸。比如说，我们可以使用所需要的渲染区域的宽高，来让渲染器渲染出的场景填充满我们的应用程序。因此，我们可以将渲染器宽高设置为浏览器窗口宽高。对于性能比较敏感的应用程序来说，你可以给setSize传入一个较小的值，例如window.innerWidth/2和window.innerHeight/2，这将使得应用程序在渲染时，以一半的长宽尺寸渲染场景。其实这个尺寸也是 `renderer.domElement` 这个 `canvas` 元素的大小。

假设你的`<canvas>` 标签现在已经具有了100%的宽和高，调用setSize(window.innerWidth/2, window.innerHeight/2, false)将使得你的应用程序以一半的分辨率来进行渲染。

**画个立方体**

万事具备，只欠东风。我们想把一个立方体放到我们建好的场景中。那么这个立方体从哪里来呢，我们可以导入一个立方体模型，但是现在还是用最简单的方法，通过ThreeJS提供给我们的方法，画一个立方体出来。

```javascript
const geometry = new THREE.BoxGeometry( 1, 1, 1 );
```

有了这个立方体，但是他还是光秃秃的，像是没有树皮的书，所以要给他加上树皮，这里我们称之为材质。

```javascript
const material = new THREE.MeshBasicMaterial( { color: 0x00ff00 } );
```

现在有了一个16进制颜色（绿色）的材质，但是该没有应用到立方体上。

```javascript
const cube = new THREE.Mesh( geometry, material );
```

Mesh（网格）。 网格是包含有一个几何体以及应用在在此几何体上的材质的对象，它帮助我们将材质和立方体组合起来，然后直接将网格对象放入到我们的场景中，并让它在场景中自由移动。

```javascript
camera.position.z = 5;
```

默认情况下，当我们调用scene.add()的时候，物体将会被添加到坐标为(0,0,0)的位置。但这可能会使得摄像机的位置和立方体相互重叠（也就是摄像机位于立方体中）。为了防止这种情况的发生，我们只需要将摄像机稍微向外移动一些即可。

#### 渲染场景

到现在为止，你将不会在其中看到任何东西。这是因为我们还没有对它进行真正的渲染。为此，我们需要调用一个被叫做“渲染”或者“动画循环”的东西。

```javascript
function animate() {
	requestAnimationFrame( animate );
	renderer.render( scene, camera );
}
animate();
```

可以用setInterval，但是，requestAnimationFrame有很多的优点。最重要的一点或许就是当用户切换到其它的标签页时，它会暂停，因此不会浪费用户宝贵的处理器资源，以及损耗电池的使用寿命。

#### 使立方体动起来 

```javascript
cube.rotation.x += 0.01;
cube.rotation.y += 0.01;
```

这一段代码将在每一帧时被渲染时调用（正常情况下是60次/秒），这就让立方体有了一个看起来很不错的旋转动画。基本上来说，当应用程序运行时，如果你想要移动或者改变任何场景中的东西，都必须要经过这个动画循环。当然，在这个动画循环函数里，你也可以调用别的函数，这样你在写animate函数的时候，就不用在这里以成千上万的代码来结尾了。

#### 完整的代码

```javascript
import * as THREE from './js/three.module.js';
import './style/main.scss';

const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);

const renderer = new THREE.WebGLRenderer();
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

const geometry = new THREE.BoxGeometry(1, 1, 1);
const material = new THREE.MeshBasicMaterial({ color: 0x00ff00 });
const cube = new THREE.Mesh(geometry, material);
scene.add(cube);

camera.position.z = 5;

const animate = function () {
    requestAnimationFrame(animate);
    cube.rotation.x += 0.01;
    cube.rotation.y += 0.01;
    renderer.render(scene, camera);
};

animate();
```