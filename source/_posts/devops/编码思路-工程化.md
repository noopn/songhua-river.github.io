---
layout: posts
title: 编码思路-工程化
date: 2023-10-15 09:06:07
categories:
  - DevOps
tags:
  - DevOps
---

#### 检查包是否安装

```js
let dir = __dirname;

do {
  if (fs.statSync(path.join(dir, "node_modules", packageName)).isDirectory()) {
    return true;
  }
} while (dir !== (dir = path.dirname(dir)));

//require("module") 用于管理模块的接口
for (const internalPath of require("module").globalPaths) {
  if (fs.statSync(path.join(internalPath, packageName)).isDirectory()) {
    return true;
  }
}
return false;
```

#### 区分使用的是那种包管理器

```js
if (fs.existsSync(path.resolve(process.cwd(), "yarn.lock"))) {
  packageManager = "yarn";
} else if (fs.existsSync(path.resolve(process.cwd(), "pnpm-lock.yaml"))) {
  packageManager = "pnpm";
} else {
  packageManager = "npm";
}
```

#### 原生的命令行交互 readLine

```js
const readLine = require("readline");

const questionInterface = readLine.createInterface({
  input: process.stdin,
  output: process.stderr,
});

questionInterface.question("question one (yes/no):", (answer) => {
  if (answer.startsWith("y")) {
  }
});
```

## 子进程的 spawn 和 exec 函数之间的区别

Node.js 的子进程模块（child_process）有两个函数 spawn 和 exec，使用这两个函数，我们可以启动一个子进程来执行系统中的其他程序。刚接触 child_process 的人可能会问，为什么做同一件事会有两个函数，以及应该使用哪个函数。我将解释 spawn 和 exec 之间的区别，以帮助你决定何时使用哪个函数。

child_process.spawn 和 child_process.exec 的最大区别在于它们的返回值--spawn 返回一个流，而 exec 返回一个缓冲区。

child_process.spawn 返回一个包含 stdout 和 stderr 流的对象。您可以点击 stdout 流来读取子进程发回 Node 的数据。作为一个流，stdout 具有流所具有的 "data"（数据）、"end"（结束）和其他事件。当您希望子进程向 Node 返回大量数据（如图像处理、读取二进制数据等）时，最好使用 spawn。

child_process.spawn 是 "异步 asynchronous"（异步不同步）的，这意味着一旦子进程开始执行，它就会以流的形式从子进程发回数据。

这里有一个例子，我用 spawn 读取了 Node 的 curl 请求结果。

child_process.exec 返回子进程输出的整个缓冲区。默认情况下，缓冲区大小为 200k。如果子进程返回的数据超过该值，程序就会崩溃，并显示错误信息 "Error: maxBuffer exceeded"（错误：超过最大缓冲区）。你可以在执行选项中设置更大的缓冲区大小来解决这个问题。但你不应该这样做，因为 exec 并不适合向 Node 返回巨大缓冲区的进程。你应该使用 spawn 来解决这个问题。那么，exec 用来做什么呢？用它来运行返回结果状态而不是数据的程序。

child_process.exec 是 "同步异步 "的，也就是说，虽然 exec 是异步的，但它会等待子进程结束，并尝试一次性返回所有缓冲数据。如果 exec 的缓冲区大小设置得不够大，就会出现 "maxBuffer exceeded"（超过最大缓冲区）错误，导致执行失败。

请看这里的一个示例，我使用 exec 执行 wget 下载文件，并向 Node 更新执行状态。

这就是 Node 的子进程 span 和 exec 之间的区别。当你希望子进程向 Node 返回大量二进制数据时，请使用 spawn；当你希望子进程返回简单的状态信息时，请使用 exec。

```js
const cp = require("child_process");
new Promise((resolve, reject) => {
  const executedCommand = cp.spawn("echo 1", [], {
    stdio: "inherit",
    shell: true,
  });

  executedCommand.on("error", reject);

  executedCommand.on("exit", (code) => {
    if (code === 0) resolve();
  });
}).then(() => {});
```

#### 区分包的模块化方案

```js
const pkgPath = require.resolve(`${packageName}/package.json`);
const pkg = require(pkgPath);
if (pkg.type === "module" || /\.mjs/i.test(pkg.bin[name])) {
  import(path.resolve(path.dirname(pkgPath), pkg.bin[name])).catch();
} else {
  require(path.resolve(path.dirname(pkgPath), pkg.bin[name]));
}
```

#### 检查两个命令是否相似

(莱文斯坦距离)[https://zh.wikipedia.org/wiki/%E8%90%8A%E6%96%87%E6%96%AF%E5%9D%A6%E8%B7%9D%E9%9B%A2] (fastest-levenshtein)[https://github.com/ka-weihe/fastest-levenshtein]

#### 获取某个包的最新版本

推荐使用 cross-spawn

```js
const cp = require("child_process");

const { output } = cp.spawnSync(
  "npm.cmd",
  ["view", "react@latest", "version"],
  {
    stdio: "pipe",
  }
);
console.log(output.toString());
```
